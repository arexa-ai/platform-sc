{
  "language": "Solidity",
  "sources": {
    "contracts/ArexaToken/ArexaTokenAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenAdminFacet } from \"../base/ERC20Diamond/TokenAdminFacet.sol\";\r\n\r\ncontract ArexaTokenAdminFacet is TokenAdminFacet {\r\n\tconstructor() TokenAdminFacet() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenAMLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenAMLFacet } from \"../base/ERC20Diamond/TokenAMLFacet.sol\";\r\n\r\ncontract ArexaTokenAMLFacet is TokenAMLFacet {\r\n\tconstructor() TokenAMLFacet() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\n/**\n * Copyright (C) 2023 uSmart (Andras Szabolcsi)\n */\npragma solidity ^0.8.9;\n\nimport { TokenOwnershipFacet } from \"../base/ERC20Diamond/TokenOwnershipFacet.sol\";\n\ncontract ArexaTokenOwnershipFacet is TokenOwnershipFacet {\n\tconstructor() TokenOwnershipFacet() {}\n}\n"
    },
    "contracts/ArexaToken/ArexaTokenPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 uSmart (Andras Szabolcsi)\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenPausableFacet } from \"../base/ERC20Diamond/TokenPausableFacet.sol\";\r\n\r\ncontract ArexaTokenPausableFacet is TokenPausableFacet {\r\n\tconstructor() TokenPausableFacet() {}\r\n}\r\n"
    },
    "contracts/base/AccessControl/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibAccessControlStorage.sol\";\r\n\r\nimport { IERC173 } from \"../../interfaces/IERC173.sol\";\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport { UintUtils } from \"../../utils/UintUtils.sol\";\r\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\r\n\r\nlibrary LibAccessControl {\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\tusing UintUtils for uint256;\r\n\tusing AddressUtils for address;\r\n\r\n\terror Ownable__NotOwner();\r\n\terror Ownable__NotTransitiveOwner();\r\n\r\n\terror AccessDenied(bytes32 role, address account);\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\r\n\tbytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\tfunction _setOwner(address _newOwner) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\taddress previousOwner = acls.owner;\r\n\t\tacls.owner = _newOwner;\r\n\r\n\t\t//Init DEFAULT_ADMIN_ROLE to _newOwner\r\n\t\tLibAccessControl._grantRole(LibAccessControl.DEFAULT_ADMIN_ROLE, _newOwner);\r\n\r\n\t\temit OwnershipTransferred(previousOwner, _newOwner);\r\n\t}\r\n\r\n\tfunction _owner() internal view returns (address owner_) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\towner_ = acls.owner;\r\n\t}\r\n\r\n\tfunction _transitiveOwner() internal view returns (address owner_) {\r\n\t\towner_ = LibAccessControl._owner();\r\n\r\n\t\twhile (owner_.isContract()) {\r\n\t\t\ttry IERC173(owner_).owner() returns (address transitiveOwner) {\r\n\t\t\t\towner_ = transitiveOwner;\r\n\t\t\t} catch {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _enforceIsOwner() internal view {\r\n\t\t//require(msg.sender == _owner(), \"Not owner!\");\r\n\t\tif (msg.sender != _owner()) {\r\n\t\t\trevert Ownable__NotOwner();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _enforceIsTransitiveOwner() internal view {\r\n\t\t//require(msg.sender == _transitiveOwner(), \"Not transitive owner!\");\r\n\t\tif (msg.sender != _transitiveOwner()) {\r\n\t\t\trevert Ownable__NotTransitiveOwner();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice assign role to given account\r\n\t * @param _role role to assign\r\n\t * @param _account recipient of role assignment\r\n\t */\r\n\tfunction _grantRole(bytes32 _role, address _account) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\tif (!_hasRole(_role, _account)) {\r\n\t\t\tacls.roles[acls.owner][_role].members.add(_account);\r\n\t\t\temit RoleGranted(acls.owner, _role, _account, msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice unassign role from given account\r\n\t * @param _role role to unassign\r\n\t * @param _account account to revokeAccessControlStorage\r\n\t */\r\n\tfunction _revokeRole(bytes32 _role, address _account) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\t// require(_role != LibAccessControl.DEFAULT_ADMIN_ROLE && _account != acls.owner);\r\n\t\tacls.roles[acls.owner][_role].members.remove(_account);\r\n\t\temit RoleRevoked(acls.owner, _role, _account, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice relinquish role\r\n\t * @param _role role to relinquish\r\n\t */\r\n\tfunction _renounceRole(bytes32 _role) internal {\r\n\t\t_revokeRole(_role, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Query one of the accounts that have role of the project\r\n\t * @dev WARNING: When using _getProjectRoleMember and _getProjectRoleMemberCount, make sure you perform all queries on the same block.\r\n\t * @param _role role to query\r\n\t * @param _index index of role member\r\n\t */\r\n\tfunction _getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.at(_index);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Query the number of accounts that have role.\r\n\t * @dev WARNING: When using _getRoleMember and _getRoleMemberCount, make sure you perform all queries on the same block.\r\n\t * @param _role role to query\r\n\t */\r\n\tfunction _getRoleMemberCount(address, bytes32 _role) internal view returns (uint256) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.length();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query whether role is assigned to account\r\n\t * @param _role role to query\r\n\t * @param _account account to query\r\n\t * @return bool whether role is assigned to account\r\n\t */\r\n\tfunction _hasRole(bytes32 _role, address _account) internal view returns (bool) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.contains(_account);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice revert if sender does not have given role\r\n\t * @param _role role to query\r\n\t */\r\n\tfunction _checkRole(bytes32 _role) internal view {\r\n\t\t_checkRole(_role, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice revert if given account does not have given role\r\n\t * @param _role role to query\r\n\t * @param _account to query\r\n\t */\r\n\tfunction _checkRole(bytes32 _role, address _account) internal view {\r\n\t\tif (!_hasRole(_role, _account)) {\r\n\t\t\trevert AccessDenied({ role: _role, account: _account });\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query admin role for given role\r\n\t * @param _role role to query\r\n\t * @return admin role\r\n\t */\r\n\tfunction _getRoleAdmin(bytes32 _role) internal view returns (bytes32) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].adminRole;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice set role as admin role\r\n\t * @param _role role to set\r\n\t * @param _adminRole admin role to set\r\n\t */\r\n\tfunction _setRoleAdmin(bytes32 _role, bytes32 _adminRole) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\tbytes32 previousAdminRole = _getRoleAdmin(_role);\r\n\t\tacls.roles[acls.owner][_role].adminRole = _adminRole;\r\n\t\temit RoleAdminChanged(acls.owner, _role, previousAdminRole, _adminRole);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/LibAccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport \"./RoleData.sol\";\r\n\r\nstruct AccessControllStorage {\r\n\t//owner => role => adminRole, members mapping\r\n\taddress owner;\r\n\tmapping(address => mapping(bytes32 => RoleData)) roles;\r\n}\r\n\r\nlibrary LibAccessControlStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.access-control.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (AccessControllStorage storage acls_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tacls_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/ModifierRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"./LibAccessControl.sol\";\r\n\r\nabstract contract ModifierRole {\r\n\tmodifier onlyOwner() {\r\n\t\tLibAccessControl._enforceIsOwner();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyTransitiveOwner() {\r\n\t\tLibAccessControl._enforceIsTransitiveOwner();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyRole(bytes32 role) {\r\n\t\tLibAccessControl._checkRole(role);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyRoleAdmin(bytes32 role) {\r\n\t\tLibAccessControl._checkRole(LibAccessControl._getRoleAdmin(role));\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/RoleData.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct RoleData {\r\n\tbytes32 adminRole;\r\n\tEnumerableSet.AddressSet members;\r\n}\r\n"
    },
    "contracts/base/BlackWhiteList/LibBlackWhiteList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibBlackWhiteListStorage.sol\";\r\n\r\nlibrary LibBlackWhiteList {\r\n\t//_target: which list is belongs to...\r\n\t//_account: an account on a _target\r\n\t//_lockValue:\r\n\t//  - if _target is a blackList than true _lockValue means that the account is prohibited\r\n\t//  - if _target is a blackList than false _lockValue means that the account is acceptable\r\n\t//  - if _target is a whiteList than true _lockValue means that the account is acceptable\r\n\t//  - if _target is a whiteList than false _lockValue means that the account is prohibited\r\n\tevent AccountBlackWhiteList(bytes32 indexed _target, address indexed _account, bool _lockValue);\r\n\r\n\tfunction _getAccountBlackWhiteList(bytes32 _target, address _account) internal view returns (bool lockValue_) {\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\tlockValue_ = wls.whiteList[_target][_account];\r\n\t}\r\n\r\n\tfunction _setAccountBlackWhiteList(bytes32 _target, address _account, bool _lockValue) internal {\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\twls.whiteList[_target][_account] = _lockValue;\r\n\t\temit AccountBlackWhiteList(_target, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction _setBatchAccountBlackWhiteList(bytes32 _target, address[] calldata _accounts, bool _lockValue) internal {\r\n\t\trequire(_accounts.length <= 255, \"Batch: too many addresses\");\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\tfor (uint8 i = 0; i < _accounts.length; i++) {\r\n\t\t\twls.whiteList[_target][_accounts[i]] = _lockValue;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/BlackWhiteList/LibBlackWhiteListStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct BlackWhiteListStorage {\r\n\tmapping(bytes32 => mapping(address => bool)) whiteList;\r\n}\r\n\r\nlibrary LibBlackWhiteListStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.white-list.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (BlackWhiteListStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/Diamond/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport \"./LibDiamondStorage.sol\";\nimport { IDiamondCut } from \"../../interfaces/IDiamondCut.sol\";\n\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\tfunction setDiamondAddress(address _diamondAddress) internal {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(ds.diamondAddress == address(0), \"Already initialized!\");\n\t\tds.diamondAddress = _diamondAddress;\n\t}\n\n\tfunction getDiamondAddress() internal view returns (address) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\treturn ds.diamondAddress;\n\t}\n\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tLibAccessControl._setOwner(_newOwner);\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\tLibAccessControl._enforceIsOwner();\n\t}\n\n\t// Internal function version of diamondCut\n\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n\t\t\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n\t\t\tif (action == IDiamondCut.FacetCutAction.Add) {\n\t\t\t\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\t\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\t\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else {\n\t\t\t\trevert(\"LibDiamondCut: Incorrect FacetCutAction\");\n\t\t\t}\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\taddFacet(ds, _facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\t\t\taddFunction(ds, selector, selectorPosition, _facetAddress);\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\taddFacet(ds, _facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n\t\t\tremoveFunction(ds, oldFacetAddress, selector);\n\t\t\taddFunction(ds, selector, selectorPosition, _facetAddress);\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\t// if function does not exist then do nothing and return\n\t\trequire(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\tremoveFunction(ds, oldFacetAddress, selector);\n\t\t}\n\t}\n\n\tfunction addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n\t\tds.facetAddresses.push(_facetAddress);\n\t}\n\n\tfunction addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n\t\tds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n\t\tds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n\t}\n\n\tfunction removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\t\t// an immutable function is a function defined directly in a diamond\n\t\trequire(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n\t\t// replace selector with last selector, then delete last selector\n\t\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n\t\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\t\t// if not the same then replace _selector with lastSelector\n\t\tif (selectorPosition != lastSelectorPosition) {\n\t\t\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n\t\t\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n\t\t}\n\t\t// delete the last selector\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n\t\tdelete ds.selectorToFacetAndPosition[_selector];\n\n\t\t// if no more selectors for facet address then delete the facet address\n\t\tif (lastSelectorPosition == 0) {\n\t\t\t// replace facet address with last facet address and delete last facet address\n\t\t\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n\t\t\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t\tif (facetAddressPosition != lastFacetAddressPosition) {\n\t\t\t\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n\t\t\t\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n\t\t\t\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n\t\t\t}\n\t\t\tds.facetAddresses.pop();\n\t\t\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t}\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\treturn;\n\t\t}\n\t\tenforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\tif (!success) {\n\t\t\tif (error.length > 0) {\n\t\t\t\t// bubble up error\n\t\t\t\t/// @solidity memory-safe-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(error)\n\t\t\t\t\trevert(add(32, error), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert InitializationFunctionReverted(_init, _calldata);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/base/Diamond/LibDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct FacetAddressAndPosition {\r\n\taddress facetAddress;\r\n\tuint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n}\r\n\r\nstruct FacetFunctionSelectors {\r\n\tbytes4[] functionSelectors;\r\n\tuint256 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n}\r\n\r\nstruct DiamondStorage {\r\n\taddress diamondAddress;\r\n\t// maps function selector to the facet address and\r\n\t// the position of the selector in the facetFunctionSelectors.selectors array\r\n\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n\t// maps facet addresses to function selectors\r\n\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n\t// facet addresses\r\n\taddress[] facetAddresses;\r\n\t// Used to query if a contract implements an interface.\r\n\t// Used to implement ERC-165.\r\n\tmapping(bytes4 => bool) supportedInterfaces;\r\n\t//the whole diamond is paused or not\r\n\tbool paused;\r\n}\r\n\r\nlibrary LibDiamondStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.contracts.diamond.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (DiamondStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\n//import { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibCustomERC20Extension } from \"../ERC20Token/LibCustomERC20Extension.sol\";\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenAdminFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction getTreasuryAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getTreasuryAddress();\r\n\t}\r\n\r\n\tfunction setTreasuryAddress(\r\n\t\taddress _treasuryAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setTreasuryAddress(_treasuryAddress);\r\n\t}\r\n\r\n\tfunction getURL() external view protectedCall returns (string memory) {\r\n\t\treturn LibCustomERC20Extension._getURL();\r\n\t}\r\n\r\n\tfunction setURL(\r\n\t\tstring calldata _url\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setURL(_url);\r\n\t}\r\n\r\n\tfunction getGeneralFeeAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getGeneralFeeAddress();\r\n\t}\r\n\r\n\tfunction setGeneralFeeAddress(\r\n\t\taddress _generalFeeAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setGeneralFeeAddress(_generalFeeAddress);\r\n\t}\r\n\r\n\tfunction getGeneralFee() external view protectedCall returns (uint16) {\r\n\t\treturn LibCustomERC20Extension._getGeneralFee();\r\n\t}\r\n\r\n\tfunction setGeneralFee(\r\n\t\tuint16 _generalFee\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setGeneralFee(_generalFee);\r\n\t}\r\n\r\n\tfunction getPoolFee() external view protectedCall returns (uint16) {\r\n\t\treturn LibCustomERC20Extension._getPoolFee();\r\n\t}\r\n\r\n\tfunction setPoolFee(uint16 _PoolFee) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setPoolFee(_PoolFee);\r\n\t}\r\n\r\n\tfunction getPoolFeeAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getPoolFeeAddress();\r\n\t}\r\n\r\n\tfunction setPoolFeeAddress(\r\n\t\taddress _PoolFeeAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setPoolFeeAddress(_PoolFeeAddress);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenAMLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { LibBlackWhiteList } from \"../BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenAMLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tbytes32 public constant SENDER_BLACKLIST = LibTokenConst.SENDER_BL;\r\n\tbytes32 public constant RECIPIENT_BLACKLIST = LibTokenConst.RECIPIENT_BL;\r\n\r\n\tfunction getAccountBlackWhiteList(bytes32 _target, address _account) external view returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(_target, _account);\r\n\t}\r\n\r\n\tfunction setAccountBlackWhiteList(\r\n\t\tbytes32 _target,\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(_target, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction getSourceAccountBL(address _account) external view protectedCall returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(SENDER_BLACKLIST, _account);\r\n\t}\r\n\r\n\tfunction setSourceAccountBL(\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(SENDER_BLACKLIST, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction setBatchSourceAccountBL(\r\n\t\taddress[] calldata _addresses,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\trequire(_addresses.length <= 255, \"Batch: too many addresses\");\r\n\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\r\n\t\t\tLibBlackWhiteList._setAccountBlackWhiteList(SENDER_BLACKLIST, _addresses[i], _lockValue);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getDestinationAccountBL(address _account) external view protectedCall returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(RECIPIENT_BLACKLIST, _account);\r\n\t}\r\n\r\n\tfunction setDestinationAccountBL(\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(RECIPIENT_BLACKLIST, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction setBatchDestinationAccountBL(\r\n\t\taddress[] calldata _addresses,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\trequire(_addresses.length <= 255, \"Batch: too many addresses\");\r\n\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\r\n\t\t\tLibBlackWhiteList._setAccountBlackWhiteList(RECIPIENT_BLACKLIST, _addresses[i], _lockValue);\r\n\t\t}\r\n\t}\r\n\r\n\t//ide az blck lista kezelés, illetve 1404 kezelés kellene\r\n\t//végleg elégetni egy számlát, és tokent kivonni\r\n\tfunction withdrawUserTokenByCompliance(address _account) external protectedCall onlyRole(LibTokenConst.COMPLIANCE_ROLE) {\r\n\t\t//\r\n\t\t//ha számla végleg törölt listában van ÉS blacklistán is van\r\n\t\t//akkor a teljes összeget transferálni kell a treasury számlára???\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { Ownable } from \"../Ownable/Ownable.sol\";\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\n\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\n\n//import { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\n\nabstract contract TokenOwnershipFacet is Ownable, CallProtection, ModifierPausable {\n\tfunction transferOwnership(address _newOwner) public override protectedCall whenNotPaused(LibTokenConst.FULL) onlyOwner {\n\t\tsuper.transferOwnership(_newOwner);\n\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TOKEN_ADMIN_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TREASURY_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.AML_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.COMPLIANCE_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\n\t\tLibAccessControl._grantRole(LibTokenConst.TOKEN_ADMIN_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.TREASURY_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.AML_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.COMPLIANCE_ROLE, LibAccessControl._owner());\n\t}\n}\n"
    },
    "contracts/base/ERC20Diamond/TokenPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenPausableFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tbytes32 public constant PAUSABLE_FULL = LibTokenConst.FULL; //LibTokenConst LibBlockBenTokenConst\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction paused(bytes32 target) external view returns (bool status_) {\r\n\t\tstatus_ = LibTargetedPausable._paused(target);\r\n\t}\r\n\r\n\tfunction pause(bytes32 target) external whenNotPaused(target) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._pause(target, msg.sender);\r\n\t}\r\n\r\n\tfunction unpause(bytes32 target) external whenPaused(target) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._unpause(target, msg.sender);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibCustomERC20Extension.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibCustomERC20ExtensionStorage } from \"./LibCustomERC20ExtensionStorage.sol\";\r\n\r\nlibrary LibCustomERC20Extension {\r\n\t///LibBlockBenERC20ExtensionStorage\r\n\t//URL, Fee and other usfull extension will come here\r\n\r\n\tfunction _getTreasuryAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().treasuryAddress;\r\n\t}\r\n\r\n\tfunction _setTreasuryAddress(address _treasuryAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().treasuryAddress = _treasuryAddress;\r\n\t}\r\n\r\n\tfunction _getURL() internal view returns (string memory) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().url;\r\n\t}\r\n\r\n\tfunction _setURL(string calldata _url) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().url = _url;\r\n\t}\r\n\r\n\tfunction _getGeneralFeeAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().generalFeeAddress;\r\n\t}\r\n\r\n\tfunction _setGeneralFeeAddress(address _generalFeeAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().generalFeeAddress = _generalFeeAddress;\r\n\t}\r\n\r\n\tfunction _getGeneralFee() internal view returns (uint16) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().generalFee;\r\n\t}\r\n\r\n\tfunction _setGeneralFee(uint16 _generalFee) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().generalFee = _generalFee;\r\n\t}\r\n\r\n\tfunction _getPoolFee() internal view returns (uint16) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().poolFee;\r\n\t}\r\n\r\n\tfunction _setPoolFee(uint16 _poolFee) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().poolFee = _poolFee;\r\n\t}\r\n\r\n\tfunction _getPoolFeeAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().poolFeeAddress;\r\n\t}\r\n\r\n\tfunction _setPoolFeeAddress(address _poolFeeAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().poolFeeAddress = _poolFeeAddress;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibCustomERC20ExtensionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nstruct CustomERC20ExtensionStorage {\r\n\tstring url;\r\n\taddress treasuryAddress;\r\n\tuint16 generalFee;\r\n\taddress generalFeeAddress;\r\n\tuint16 poolFee;\r\n\taddress poolFeeAddress;\r\n}\r\n\r\nlibrary LibCustomERC20ExtensionStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.constract.custom-erc20-extension.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (CustomERC20ExtensionStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibTokenConst.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nlibrary LibTokenConst {\r\n\t//Pausable\r\n\tbytes32 public constant FULL = 0x00;\r\n\r\n\t//Roles\r\n\tbytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\"TOKEN_ADMIN_ROLE\");\r\n\tbytes32 public constant TREASURY_ROLE = keccak256(\"TREASURY_ROLE\");\r\n\tbytes32 public constant AML_ROLE = keccak256(\"AML_ROLE\");\r\n\tbytes32 public constant COMPLIANCE_ROLE = keccak256(\"COMPLIANCE_ROLE\");\r\n\r\n\t//BlackWhite lists, these accounts could not send/receive token\r\n\tbytes32 public constant SENDER_BL = keccak256(\"SENDER_BLACKLIST\");\r\n\tbytes32 public constant RECIPIENT_BL = keccak256(\"RECIPIENT_BLACKLIST\");\r\n\r\n\t//FreeFee WhiteList, these accounts don't pay fee...\r\n\tbytes32 public constant SENDER_FREE_FEE_WL = keccak256(\"SENDER_FREE_FEE_WHITELIST\");\r\n\tbytes32 public constant RECIPIENT_FREE_FEE_WL = keccak256(\"RECIPIENT_FREE_FEE_WHITELIST\");\r\n}\r\n"
    },
    "contracts/base/Ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { IERC173 } from \"../../interfaces/IERC173.sol\";\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\n\r\nabstract contract Ownable is IERC173, ModifierRole {\r\n\tusing AddressUtils for address;\r\n\r\n\t/**\r\n\t * @notice get the ERC173 contract owner\r\n\t * @return contract owner\r\n\t */\r\n\tfunction owner() external view returns (address) {\r\n\t\treturn LibAccessControl._owner();\r\n\t}\r\n\r\n\t/// @notice Set the address of the new owner of the contract\r\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\r\n\t/// @param _newOwner The address of the new owner of the contract\r\n\tfunction transferOwnership(address _newOwner) public virtual onlyOwner {\r\n\t\tLibAccessControl._setOwner(_newOwner);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/Shared/ProtectedCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibDiamond } from \"../Diamond/LibDiamond.sol\";\r\n\r\ncontract CallProtection {\r\n\tmodifier protectedCall() {\r\n\t\trequire(address(this) == LibDiamond.getDiamondAddress(), \"NOT_ALLOWED\");\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/LibTargetedPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibTargetedPausableStorage.sol\";\r\n\r\nlibrary LibTargetedPausable {\r\n\terror TargetedPausable__TargetedPaused();\r\n\terror TargetedPausable__NotTargetedPaused();\r\n\r\n\t//target: what was paused\r\n\t//account: the operator who is paused the target\r\n\tevent TargetedPaused(bytes32 indexed target, address indexed account);\r\n\r\n\t//target: what was unpaused\r\n\t//account: the operator who is unpaused the target\r\n\tevent TargetedUnpaused(bytes32 target, address indexed account);\r\n\r\n\tfunction _whenNotPaused(bytes32 _target) internal view {\r\n\t\tif (LibTargetedPausable._paused(_target)) revert TargetedPausable__TargetedPaused();\r\n\t}\r\n\r\n\tfunction _whenPaused(bytes32 _target) internal view {\r\n\t\tif (!LibTargetedPausable._paused(_target)) revert TargetedPausable__NotTargetedPaused();\r\n\t}\r\n\r\n\tfunction _paused(bytes32 _target) internal view returns (bool paused_) {\r\n\t\tpaused_ = LibTargetedPausableStorage.layout().paused[_target];\r\n\t}\r\n\r\n\tfunction _pause(bytes32 _target, address _operator) internal {\r\n\t\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\r\n\t\tif (ps.paused[_target]) revert TargetedPausable__TargetedPaused();\r\n\t\tps.paused[_target] = true;\r\n\t\temit TargetedPaused(_target, _operator);\r\n\t}\r\n\r\n\tfunction _unpause(bytes32 _target, address _operator) internal {\r\n\t\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\r\n\t\tif (!ps.paused[_target]) revert TargetedPausable__NotTargetedPaused();\r\n\t\tps.paused[_target] = false;\r\n\t\tdelete ps.paused[_target];\r\n\t\temit TargetedUnpaused(_target, _operator);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/LibTargetedPausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct TargetedPausableStorage {\r\n\tmapping(bytes32 => bool) paused;\r\n}\r\n\r\nlibrary LibTargetedPausableStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.targeted-pausable.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (TargetedPausableStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/ModifierPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibTargetedPausable } from \"./LibTargetedPausable.sol\";\r\n\r\nabstract contract ModifierPausable {\r\n\t//\r\n\tmodifier whenNotPaused(bytes32 target) {\r\n\t\tLibTargetedPausable._whenNotPaused(target);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenPaused(bytes32 target) {\r\n\t\tLibTargetedPausable._whenPaused(target);\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n\tenum FacetCutAction {\n\t\tAdd,\n\t\tReplace,\n\t\tRemove\n\t}\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\ninterface IERC173 {\r\n\t/// @dev This emits when ownership of a contract changes.\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/// @notice Get the address of the owner\r\n\t/// @return owner_ The address of the owner.\r\n\tfunction owner() external view returns (address owner_);\r\n\r\n\t/// @notice Set the address of the new owner of the contract\r\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\r\n\t/// @param _newOwner The address of the new owner of the contract\r\n\tfunction transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { UintUtils } from \"./UintUtils.sol\";\n\nlibrary AddressUtils {\n\tusing UintUtils for uint256;\n\n\terror AddressUtils__InsufficientBalance();\n\terror AddressUtils__NotContract();\n\terror AddressUtils__SendValueFailed();\n\n\tfunction toString(address account) internal pure returns (string memory) {\n\t\treturn uint256(uint160(account)).toHexString(20);\n\t}\n\n\tfunction isContract(address account) internal view returns (bool) {\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(account)\n\t\t}\n\t\treturn size > 0;\n\t}\n\n\tfunction sendValue(address payable account, uint256 amount) internal {\n\t\t(bool success, ) = account.call{ value: amount }(\"\");\n\t\tif (!success) revert AddressUtils__SendValueFailed();\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"AddressUtils: failed low-level call\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data, string memory error) internal returns (bytes memory) {\n\t\treturn _functionCallWithValue(target, data, 0, error);\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"AddressUtils: failed low-level call with value\");\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) internal returns (bytes memory) {\n\t\tif (value > address(this).balance) revert AddressUtils__InsufficientBalance();\n\t\treturn _functionCallWithValue(target, data, value, error);\n\t}\n\n\t/**\n\t * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n\t * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n\t * @param target recipient of call\n\t * @param gasAmount gas allowance for call\n\t * @param value native token value to include in call\n\t * @param maxCopy maximum number of bytes to copy from return data\n\t * @param data encoded call data\n\t * @return success whether call is successful\n\t * @return returnData copied return data\n\t */\n\tfunction excessivelySafeCall(\n\t\taddress target,\n\t\tuint256 gasAmount,\n\t\tuint256 value,\n\t\tuint16 maxCopy,\n\t\tbytes memory data\n\t) internal returns (bool success, bytes memory returnData) {\n\t\treturnData = new bytes(maxCopy);\n\n\t\tassembly {\n\t\t\t// execute external call via assembly to avoid automatic copying of return data\n\t\t\tsuccess := call(gasAmount, target, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\t// determine whether to limit amount of data to copy\n\t\t\tlet toCopy := returndatasize()\n\n\t\t\tif gt(toCopy, maxCopy) {\n\t\t\t\ttoCopy := maxCopy\n\t\t\t}\n\n\t\t\t// store the length of the copied bytes\n\t\t\tmstore(returnData, toCopy)\n\n\t\t\t// copy the bytes from returndata[0:toCopy]\n\t\t\treturndatacopy(add(returnData, 0x20), 0, toCopy)\n\t\t}\n\t}\n\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) private returns (bytes memory) {\n\t\tif (!isContract(target)) revert AddressUtils__NotContract();\n\n\t\t(bool success, bytes memory returnData) = target.call{ value: value }(data);\n\n\t\tif (success) {\n\t\t\treturn returnData;\n\t\t} else if (returnData.length > 0) {\n\t\t\tassembly {\n\t\t\t\tlet returnData_size := mload(returnData)\n\t\t\t\trevert(add(32, returnData), returnData_size)\n\t\t\t}\n\t\t} else {\n\t\t\trevert(error);\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n\terror EnumerableSet__IndexOutOfBounds();\n\n\tstruct Set {\n\t\tbytes32[] _values;\n\t\t// 1-indexed to allow 0 to signify nonexistence\n\t\tmapping(bytes32 => uint256) _indexes;\n\t}\n\n\tstruct Bytes32Set {\n\t\tSet _inner;\n\t}\n\n\tstruct AddressSet {\n\t\tSet _inner;\n\t}\n\n\tstruct UintSet {\n\t\tSet _inner;\n\t}\n\n\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n\t\treturn _at(set._inner, index);\n\t}\n\n\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\n\t}\n\n\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\t\treturn uint256(_at(set._inner, index));\n\t}\n\n\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, value);\n\t}\n\n\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(value));\n\t}\n\n\tfunction indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, value);\n\t}\n\n\tfunction indexOf(AddressSet storage set, address value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction indexOf(UintSet storage set, uint256 value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, bytes32(value));\n\t}\n\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction length(UintSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _add(set._inner, value);\n\t}\n\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(value));\n\t}\n\n\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _remove(set._inner, value);\n\t}\n\n\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(value));\n\t}\n\n\tfunction toArray(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n\t\treturn set._inner._values;\n\t}\n\n\tfunction toArray(AddressSet storage set) internal view returns (address[] memory) {\n\t\tbytes32[] storage values = set._inner._values;\n\t\taddress[] storage array;\n\n\t\tassembly {\n\t\t\tarray.slot := values.slot\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tfunction toArray(UintSet storage set) internal view returns (uint256[] memory) {\n\t\tbytes32[] storage values = set._inner._values;\n\t\tuint256[] storage array;\n\n\t\tassembly {\n\t\t\tarray.slot := values.slot\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n\t\tif (index >= set._values.length) revert EnumerableSet__IndexOutOfBounds();\n\t\treturn set._values[index];\n\t}\n\n\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n\t\treturn set._indexes[value] != 0;\n\t}\n\n\tfunction _indexOf(Set storage set, bytes32 value) private view returns (uint256) {\n\t\tunchecked {\n\t\t\treturn set._indexes[value] - 1;\n\t\t}\n\t}\n\n\tfunction _length(Set storage set) private view returns (uint256) {\n\t\treturn set._values.length;\n\t}\n\n\tfunction _add(Set storage set, bytes32 value) private returns (bool status) {\n\t\tif (!_contains(set, value)) {\n\t\t\tset._values.push(value);\n\t\t\tset._indexes[value] = set._values.length;\n\t\t\tstatus = true;\n\t\t}\n\t}\n\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool status) {\n\t\tuint256 valueIndex = set._indexes[value];\n\n\t\tif (valueIndex != 0) {\n\t\t\tunchecked {\n\t\t\t\tbytes32 last = set._values[set._values.length - 1];\n\n\t\t\t\t// move last value to now-vacant index\n\n\t\t\t\tset._values[valueIndex - 1] = last;\n\t\t\t\tset._indexes[last] = valueIndex;\n\t\t\t}\n\t\t\t// clear last index\n\n\t\t\tset._values.pop();\n\t\t\tdelete set._indexes[value];\n\n\t\t\tstatus = true;\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n\terror UintUtils__InsufficientHexLength();\n\n\tbytes16 private constant HEX_SYMBOLS = \"0123456789abcdef\";\n\n\tfunction add(uint256 a, int256 b) internal pure returns (uint256) {\n\t\treturn b < 0 ? sub(a, -b) : a + uint256(b);\n\t}\n\n\tfunction sub(uint256 a, int256 b) internal pure returns (uint256) {\n\t\treturn b < 0 ? add(a, -b) : a - uint256(b);\n\t}\n\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\n\t\tbytes memory buffer = new bytes(digits);\n\n\t\twhile (value != 0) {\n\t\t\tdigits -= 1;\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\t\t\tvalue /= 10;\n\t\t}\n\n\t\treturn string(buffer);\n\t}\n\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0x00\";\n\t\t}\n\n\t\tuint256 length = 0;\n\n\t\tfor (uint256 temp = value; temp != 0; temp >>= 8) {\n\t\t\tunchecked {\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\n\t\treturn toHexString(value, length);\n\t}\n\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n\t\tbytes memory buffer = new bytes(2 * length + 2);\n\t\tbuffer[0] = \"0\";\n\t\tbuffer[1] = \"x\";\n\n\t\tunchecked {\n\t\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\n\t\t\t\tbuffer[i] = HEX_SYMBOLS[value & 0xf];\n\t\t\t\tvalue >>= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (value != 0) revert UintUtils__InsufficientHexLength();\n\n\t\treturn string(buffer);\n\t}\n}\n"
    }
  },
  "settings": {
    "viaIR": false,
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}