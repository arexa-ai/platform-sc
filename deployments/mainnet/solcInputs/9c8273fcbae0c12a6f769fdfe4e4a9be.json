{
  "language": "Solidity",
  "sources": {
    "contracts/_dummy/ArexaDiamondDummyImplementation.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * This is a generated dummy diamond implementation for compatibility with\n * etherscan. For full contract implementation, check out the diamond on https://louper.dev\n */\n\ncontract ArexaDiamondDummyImplementation {\n\n\n    struct Tuple6871229 {\n        address facetAddress;\n        uint8 action;\n        bytes4[] functionSelectors;\n    }\n\n    struct Tuple1236461 {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    struct Tuple4951158 {\n        uint256 total;\n        uint256 sold;\n    }\n\n    struct Tuple9951786 {\n        int256 quantity;\n        int256 deltaPnl;\n        int256 payedPnl;\n    }\n    \n\n   function diamondCut(Tuple6871229[] memory _diamondCut, address  _init, bytes memory _calldata) external {}\n\n   function facetAddress(bytes4  _functionSelector) external view returns (address  facetAddress_) {}\n\n   function facetAddresses() external view returns (address[] memory facetAddresses_) {}\n\n   function facetFunctionSelectors(address  _facet) external view returns (bytes4[] memory facetFunctionSelectors_) {}\n\n   function facets() external view returns (Tuple1236461[] memory facets_) {}\n\n   function supportsInterface(bytes4  _interfaceId) external view returns (bool ) {}\n\n   function implementation() external view returns (address ) {}\n\n   function setDummyImplementation(address  _implementation) external {}\n\n   function owner() external view returns (address ) {}\n\n   function transferOwnership(address  _newOwner) external {}\n\n   function PAUSABLE_AREXA_TOKEN() external view returns (bytes32 ) {}\n\n   function PAUSABLE_FULL() external view returns (bytes32 ) {}\n\n   function PAUSABLE_MAGIC_TOKEN() external view returns (bytes32 ) {}\n\n   function PAUSABLE_SUBSCR1_TOKEN() external view returns (bytes32 ) {}\n\n   function PAUSABLE_SUBSCR2_TOKEN() external view returns (bytes32 ) {}\n\n   function PAUSABLE_TRADER_TOKEN() external view returns (bytes32 ) {}\n\n   function pause(bytes32  target) external {}\n\n   function pauseAllToken() external {}\n\n   function pauseToken(uint256  tokenId) external {}\n\n   function paused(bytes32  target) external view returns (bool  status_) {}\n\n   function unpause(bytes32  target) external {}\n\n   function unpauseAllToken() external {}\n\n   function unpauseToken(uint256  tokenId) external {}\n\n   function AREXA_ADMIN_ROLE() external view returns (bytes32 ) {}\n\n   function getRoleAdmin(bytes32  role) external view returns (bytes32 ) {}\n\n   function grantRole(bytes32  role, address  account) external {}\n\n   function hasRole(bytes32  role, address  account) external view returns (bool ) {}\n\n   function renounceRole(bytes32  role) external {}\n\n   function revokeRole(bytes32  role, address  account) external {}\n\n   function setRoleAdmin(bytes32  role, bytes32  adminRole) external {}\n\n   function getArexaERC20Token() external view returns (address ) {}\n\n   function getPayingToken() external view returns (address ) {}\n\n   function setPayingToken(address  _token) external {}\n\n   function MAGIC100_FIRST_BUYER() external view returns (bytes32 ) {}\n\n   function getAccountBlackWhiteList(bytes32  _target, address  _account) external view returns (bool ) {}\n\n   function getMagic100FirstBuyerWL(address  _account) external view returns (bool ) {}\n\n   function setAccountBlackWhiteList(bytes32  _target, address  _account, bool  _lockValue) external {}\n\n   function setBatchMagic100FirstBuyerWL(address[] memory _addresses, bool  _lockValue) external {}\n\n   function setMagic100FirstBuyerWL(address  _account, bool  _lockValue) external {}\n\n   function AMOUNT_VALUE_TYPE() external view returns (uint8 ) {}\n\n   function AREXA_TOKEN_ID() external view returns (uint256 ) {}\n\n   function AREXA_TOKEN_POOL_AREXAINC() external view returns (uint8 ) {}\n\n   function AREXA_TOKEN_POOL_DEVELOPMENT() external view returns (uint8 ) {}\n\n   function AREXA_TOKEN_POOL_INVESTOR() external view returns (uint8 ) {}\n\n   function AREXA_TOKEN_POOL_MARKETING() external view returns (uint8 ) {}\n\n   function AREXA_TOKEN_POOL_RESERVED() external view returns (uint8 ) {}\n\n   function MAGIC_TOKEN_ID() external view returns (uint256 ) {}\n\n   function QUANTITY_VALUE_TYPE() external view returns (uint8 ) {}\n\n   function SUBSCR1_TOKEN_TYPE() external view returns (uint256 ) {}\n\n   function SUBSCR2_TOKEN_TYPE() external view returns (uint256 ) {}\n\n   function TRADER_TOKEN_ID() external view returns (uint256 ) {}\n\n   function buyArexaToken(uint128  value, uint8  valueType) external {}\n\n   function buyEdgeSubscription(uint32  quantity) external {}\n\n   function buyMagic100Token() external {}\n\n   function buyOracleSubscription(uint32  quantity) external {}\n\n   function buySubscription(uint256  tokenId, uint32  quantity) external {}\n\n   function buyTraderToken(uint128  value, uint8  valueType) external {}\n\n   function calcSubscriptionPrice(uint256  tokenId, uint32  quantity) external view returns (uint256 ) {}\n\n   function getCurrentSubscriptionTokenId(uint256  tokenType) external view returns (uint256 ) {}\n\n   function buyMagic100TokenAdmin(address  toAccount) external {}\n\n   function createSubscription(uint256  tokenType, uint16  year, uint8  month, uint256  quantity, uint256  min, uint256  max) external returns (uint256  tokenId) {}\n\n   function getArexaTokenPool(uint8  _tokenType) external view returns (Tuple4951158 memory) {}\n\n   function payArexaTokenFromPool(uint8  poolType, address  account, uint32  quantity) external {}\n\n   function calcDivident(address  account) external view returns (int256 ) {}\n\n   function getArexaIncomeParameter(uint256  tokenId) external view returns (uint32  pool_, uint32  arexa_) {}\n\n   function getInventory() external view returns (bool  isEnabled, int256  sumQuantity, int256  sumAmount, int256  sumPnl) {}\n\n   function getInventoryItem(address  account) external view returns (Tuple9951786 memory) {}\n\n   function payoutArexaDivident(address  toAccount, uint256  value) external {}\n\n   function payoutArexaIncome(address  toAccount, uint256  value) external {}\n\n   function payoutDivident(uint256  value) external {}\n\n   function setArexaIncomeParameter(uint256  tokenId, uint32  pool, uint32  arexa) external {}\n\n   function calcUnrestrictedAmount(address  account, uint256  tokenId, uint256  amount) external view returns (uint256 ) {}\n\n   function checkRestriction(address  account, uint256  tokenId, uint256  amount) external view {}\n\n   function checkRestrictions(address  account, uint256[] memory tokenIds, uint256[] memory amounts) external view {}\n\n   function stakeArexaToken(uint256  quantity) external {}\n\n   function withdrawArexaToken(address  fromAccount, address  toAccount, uint256  _quantity) external {}\n\n   function balanceOf(address  _owner, uint256  _id) external view returns (uint256 ) {}\n\n   function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) external view returns (uint256[] memory) {}\n\n   function isApprovedForAll(address  _owner, address  _operator) external view returns (bool ) {}\n\n   function name() external view returns (string memory) {}\n\n   function safeBatchTransferFrom(address  _from, address  _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) external {}\n\n   function safeTransferFrom(address  _from, address  _to, uint256  _id, uint256  _value, bytes memory _data) external {}\n\n   function setApprovalForAll(address  _operator, bool  _approved) external {}\n\n   function symbol() external view returns (string memory) {}\n\n   function allowance(address  _owner, address  _operator, uint256  _id) external view returns (uint256 ) {}\n\n   function approve(address  _operator, uint256  _id, uint256  _currentValue, uint256  _newValue) external {}\n\n   function isOperatorSpendingLimitEnabled(uint256  _tokenId) external view returns (bool ) {}\n\n   function setOperatorSpendingLimitEnabled(uint256  _tokenId, bool  _enabled) external {}\n\n   function accountsByToken(uint256  _id) external view returns (address[] memory) {}\n\n   function tokensByAccount(address  _account) external view returns (uint256[] memory) {}\n\n   function totalHolders(uint256  _id) external view returns (uint256 ) {}\n\n   function totalSupply(uint256  _id) external view returns (uint256 ) {}\n\n   function getTokenBaseUri() external view returns (string memory) {}\n\n   function getTokenUri(uint256  _id) external view returns (string memory) {}\n\n   function getUri() external view returns (string memory) {}\n\n   function setTokenBaseURI(string memory newuri) external {}\n\n   function setTokenURI(uint256  _id, string memory newuri) external {}\n\n   function setURI(string memory newuri) external {}\n\n   function uri(uint256  _id) external view returns (string memory) {}\n\n   function onERC1155BatchReceived(address  _operator, address  _from, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) external returns (bytes4 ) {}\n\n   function onERC1155Received(address  _operator, address  _from, uint256  _id, uint256  _value, bytes memory _data) external returns (bytes4 ) {}\n}\n"
    },
    "contracts/_dummy/TokenDiamondDummyImplementation.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * This is a generated dummy diamond implementation for compatibility with\n * etherscan. For full contract implementation, check out the diamond on https://louper.dev\n */\n\ncontract TokenDiamondDummyImplementation {\n\n\n    struct Tuple6871229 {\n        address facetAddress;\n        uint8 action;\n        bytes4[] functionSelectors;\n    }\n\n    struct Tuple1236461 {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n    \n\n   function diamondCut(Tuple6871229[] memory _diamondCut, address  _init, bytes memory _calldata) external {}\n\n   function facetAddress(bytes4  _functionSelector) external view returns (address  facetAddress_) {}\n\n   function facetAddresses() external view returns (address[] memory facetAddresses_) {}\n\n   function facetFunctionSelectors(address  _facet) external view returns (bytes4[] memory facetFunctionSelectors_) {}\n\n   function facets() external view returns (Tuple1236461[] memory facets_) {}\n\n   function supportsInterface(bytes4  _interfaceId) external view returns (bool ) {}\n\n   function implementation() external view returns (address ) {}\n\n   function setDummyImplementation(address  _implementation) external {}\n\n   function owner() external view returns (address ) {}\n\n   function transferOwnership(address  _newOwner) external {}\n\n   function PAUSABLE_FULL() external view returns (bytes32 ) {}\n\n   function pause(bytes32  target) external {}\n\n   function paused(bytes32  target) external view returns (bool  status_) {}\n\n   function unpause(bytes32  target) external {}\n\n   function AML_ROLE() external view returns (bytes32 ) {}\n\n   function COMPLIANCE_ROLE() external view returns (bytes32 ) {}\n\n   function TOKEN_ADMIN_ROLE() external view returns (bytes32 ) {}\n\n   function TREASURY_ROLE() external view returns (bytes32 ) {}\n\n   function getRoleAdmin(bytes32  role) external view returns (bytes32 ) {}\n\n   function grantRole(bytes32  role, address  account) external {}\n\n   function hasRole(bytes32  role, address  account) external view returns (bool ) {}\n\n   function renounceRole(bytes32  role) external {}\n\n   function revokeRole(bytes32  role, address  account) external {}\n\n   function setRoleAdmin(bytes32  role, bytes32  adminRole) external {}\n\n   function getGeneralFee() external view returns (uint16 ) {}\n\n   function getGeneralFeeAddress() external view returns (address ) {}\n\n   function getPoolFee() external view returns (uint16 ) {}\n\n   function getPoolFeeAddress() external view returns (address ) {}\n\n   function getTreasuryAddress() external view returns (address ) {}\n\n   function getURL() external view returns (string memory) {}\n\n   function setGeneralFee(uint16  _generalFee) external {}\n\n   function setGeneralFeeAddress(address  _generalFeeAddress) external {}\n\n   function setPoolFee(uint16  _PoolFee) external {}\n\n   function setPoolFeeAddress(address  _PoolFeeAddress) external {}\n\n   function setTreasuryAddress(address  _treasuryAddress) external {}\n\n   function setURL(string memory _url) external {}\n\n   function RECIPIENT_BLACKLIST() external view returns (bytes32 ) {}\n\n   function SENDER_BLACKLIST() external view returns (bytes32 ) {}\n\n   function getAccountBlackWhiteList(bytes32  _target, address  _account) external view returns (bool ) {}\n\n   function getDestinationAccountBL(address  _account) external view returns (bool ) {}\n\n   function getSourceAccountBL(address  _account) external view returns (bool ) {}\n\n   function setAccountBlackWhiteList(bytes32  _target, address  _account, bool  _lockValue) external {}\n\n   function setBatchDestinationAccountBL(address[] memory _addresses, bool  _lockValue) external {}\n\n   function setBatchSourceAccountBL(address[] memory _addresses, bool  _lockValue) external {}\n\n   function setDestinationAccountBL(address  _account, bool  _lockValue) external {}\n\n   function setSourceAccountBL(address  _account, bool  _lockValue) external {}\n\n   function withdrawUserTokenByCompliance(address  _account) external {}\n\n   function allowance(address  holder, address  spender) external view returns (uint256  allowance_) {}\n\n   function approve(address  spender, uint256  amount) external returns (bool  status_) {}\n\n   function balanceOf(address  account) external view returns (uint256  balance_) {}\n\n   function burn(uint256  amount) external {}\n\n   function burnFrom(address  account, uint256  amount) external {}\n\n   function decimals() external view returns (uint8 ) {}\n\n   function decreaseAllowance(address  spender, uint256  amount) external returns (bool ) {}\n\n   function increaseAllowance(address  spender, uint256  amount) external returns (bool ) {}\n\n   function mint(address  account, uint256  amount) external {}\n\n   function name() external view returns (string memory) {}\n\n   function symbol() external view returns (string memory) {}\n\n   function totalSupply() external view returns (uint256  totalSupply_) {}\n\n   function transfer(address  recipient, uint256  amount) external returns (bool  status_) {}\n\n   function transferFrom(address  holder, address  recipient, uint256  amount) external returns (bool  status_) {}\n}\n"
    },
    "contracts/ArexaPlatform/ArexaACLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\r\n\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\n\r\ncontract ArexaACLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tbytes32 public constant AREXA_ADMIN_ROLE = LibArexaConst.AREXA_ADMIN_ROLE;\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction hasRole(bytes32 role, address account) external view virtual protectedCall returns (bool) {\r\n\t\treturn LibAccessControl._hasRole(role, account);\r\n\t}\r\n\r\n\tfunction grantRole(bytes32 role, address account) external virtual protectedCall onlyRoleAdmin(role) {\r\n\t\t_grantRole(role, account);\r\n\t}\r\n\r\n\tfunction revokeRole(bytes32 role, address account) external virtual protectedCall onlyRoleAdmin(role) {\r\n\t\trequire(!(role == AREXA_ADMIN_ROLE && account == LibAccessControl._owner()), \"Role cannot revoke from owner!\");\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction renounceRole(bytes32 role) external virtual protectedCall {\r\n\t\t_renounceRole(role);\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) external view virtual protectedCall returns (bytes32) {\r\n\t\treturn LibAccessControl._getRoleAdmin(role);\r\n\t}\r\n\r\n\tfunction setRoleAdmin(bytes32 role, bytes32 adminRole) external protectedCall onlyOwner {\r\n\t\t_setRoleAdmin(role, adminRole);\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual protectedCall {\r\n\t\tLibAccessControl._setRoleAdmin(role, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal virtual protectedCall {\r\n\t\tLibAccessControl._grantRole(role, account);\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal virtual protectedCall {\r\n\t\tLibAccessControl._revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction _renounceRole(bytes32 role) internal virtual protectedCall {\r\n\t\tLibAccessControl._renounceRole(role);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\r\n//import { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../base/TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\n\r\nimport { IERC20 } from \"../base/ERC20/IERC20.sol\";\r\n\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\n\r\ncontract ArexaAdminFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\t//Platform paraméterek állítása\r\n\tfunction getPayingToken() external view protectedCall returns (IERC20) {\r\n\t\treturn LibArexaPlatform.getPayingToken();\r\n\t}\r\n\r\n\tfunction setPayingToken(IERC20 _token) external whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\t//require(address(LibArexaPlatform.getPayingToken()) == address(0), \"Currently changing payment token is not permitted.\");\r\n\t\tLibArexaPlatform.setPayingToken(_token);\r\n\t}\r\n\r\n\tfunction getArexaERC20Token() external view protectedCall returns (IERC20) {\r\n\t\treturn LibArexaPlatform.getArexaERC20Token();\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaAMLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\r\nimport { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../base/TargetedPausable/LibTargetedPausable.sol\";\r\n\r\n//import { LibTokenConst } from \"./LibTokenConst.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaAMLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tbytes32 public constant MAGIC100_FIRST_BUYER = LibArexaConst.MAGIC100_FIRST_BUYER; //LibTokenConst LibBlockBenTokenConst\r\n\r\n\tfunction getAccountBlackWhiteList(bytes32 _target, address _account) external view returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(_target, _account);\r\n\t}\r\n\r\n\tfunction setAccountBlackWhiteList(\r\n\t\tbytes32 _target,\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(_target, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction getMagic100FirstBuyerWL(address _account) external view returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(MAGIC100_FIRST_BUYER, _account);\r\n\t}\r\n\r\n\tfunction setMagic100FirstBuyerWL(\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(MAGIC100_FIRST_BUYER, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction setBatchMagic100FirstBuyerWL(\r\n\t\taddress[] calldata _addresses,\r\n\t\tbool _lockValue\r\n\t) external whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\trequire(_addresses.length <= 255, \"Batch: too many addresses\");\r\n\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\r\n\t\t\tLibBlackWhiteList._setAccountBlackWhiteList(MAGIC100_FIRST_BUYER, _addresses[i], _lockValue);\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 AREXA\n */\npragma solidity ^0.8.9;\n\nimport { Ownable } from \"../base/Ownable/Ownable.sol\";\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\n\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\n\ncontract ArexaOwnershipFacet is Ownable {\n\tfunction transferOwnership(address _newOwner) public override onlyOwner {\n\t\tsuper.transferOwnership(_newOwner);\n\n\t\tLibAccessControl._setRoleAdmin(LibArexaConst.AREXA_ADMIN_ROLE, LibArexaConst.AREXA_ADMIN_ROLE);\n\n\t\tLibAccessControl._grantRole(LibArexaConst.AREXA_ADMIN_ROLE, LibAccessControl._owner());\n\t\t//LibAccessControl._grantRole(LibArexaConst.AREXA_ADMIN_ROLE, LibAccessControl._owner());\n\t}\n}\n"
    },
    "contracts/ArexaPlatform/ArexaPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\nimport { IERC1155Pausable } from \"../base/ERC1155/IERC1155Pausable.sol\";\r\n\r\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\r\nimport { LibTargetedPausable } from \"../base/TargetedPausable/LibTargetedPausable.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPausableFacet is IERC1155Pausable, ModifierRole, ModifierPausable {\r\n\tbytes32 public constant PAUSABLE_FULL = LibArexaConst.FULL; //LibTokenConst LibBlockBenTokenConst\r\n\tbytes32 public constant PAUSABLE_SUBSCR1_TOKEN = LibArexaConst.SUBSCR1_TOKEN; //LibTokenConst LibBlockBenTokenConst\r\n\tbytes32 public constant PAUSABLE_SUBSCR2_TOKEN = LibArexaConst.SUBSCR2_TOKEN; //LibTokenConst LibBlockBenTokenConst\r\n\tbytes32 public constant PAUSABLE_TRADER_TOKEN = LibArexaConst.TRADER_TOKEN; //LibTokenConst LibBlockBenTokenConst\r\n\tbytes32 public constant PAUSABLE_AREXA_TOKEN = LibArexaConst.AREXA_TOKEN; //LibTokenConst LibBlockBenTokenConst\r\n\tbytes32 public constant PAUSABLE_MAGIC_TOKEN = LibArexaConst.MAGIC_TOKEN; //LibTokenConst LibBlockBenTokenConst\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction paused(bytes32 target) external view returns (bool status_) {\r\n\t\tstatus_ = LibTargetedPausable._paused(target);\r\n\t}\r\n\r\n\tfunction pause(bytes32 target) external whenNotPaused(target) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._pause(target, msg.sender);\r\n\t}\r\n\r\n\tfunction unpause(bytes32 target) external whenPaused(target) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._unpause(target, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * WARNING! pause and unpause controls the token selling functions, but not the transfers\r\n\t *\r\n\t */\r\n\tfunction pauseAllToken() external override whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibERC1155.pauseAllToken(msg.sender);\r\n\t}\r\n\r\n\tfunction unpauseAllToken() external override whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibERC1155.unpauseAllToken(msg.sender);\r\n\t}\r\n\r\n\tfunction pauseToken(uint256 tokenId) external override whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibERC1155.pauseToken(msg.sender, tokenId);\r\n\t}\r\n\r\n\tfunction unpauseToken(uint256 tokenId) external override whenNotPaused(LibArexaConst.FULL) onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) {\r\n\t\tLibERC1155.unpauseToken(msg.sender, tokenId);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPfmTokenAllowanceFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\r\nimport { LibTargetedPausable } from \"../base/TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { IERC1155Allowance } from \"../base/ERC1155/IERC1155Allowance.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPfmTokenAllowanceFacet is IERC1155Allowance, CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction isOperatorSpendingLimitEnabled(uint256 _tokenId) external view returns (bool) {\r\n\t\treturn LibERC1155.isOperatorSpendingLimitEnabled(_tokenId);\r\n\t}\r\n\r\n\tfunction setOperatorSpendingLimitEnabled(uint256 _tokenId, bool _enabled) external protectedCall onlyOwner {\r\n\t\tLibERC1155.setOperatorSpendingLimitEnabled(_tokenId, _enabled);\r\n\t}\r\n\r\n\tfunction approve(\r\n\t\taddress _operator,\r\n\t\tuint256 _id,\r\n\t\tuint256 _currentValue,\r\n\t\tuint256 _newValue\r\n\t) external virtual override protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.approve(msg.sender, _operator, _id, _currentValue, _newValue);\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _operator, uint256 _id) external view override returns (uint256) {\r\n\t\treturn LibERC1155.allowance(_owner, _operator, _id);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPfmTokenEnumerableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\nimport { IERC1155Enumerable } from \"../base/ERC1155/IERC1155Enumerable.sol\";\r\n\r\ncontract ArexaPfmTokenEnumerableFacet is IERC1155Enumerable {\r\n\tconstructor() {}\r\n\r\n\tfunction totalSupply(uint256 _id) external view override returns (uint256) {\r\n\t\treturn LibERC1155.totalSupply(_id);\r\n\t}\r\n\r\n\tfunction totalHolders(uint256 _id) external view override returns (uint256) {\r\n\t\treturn LibERC1155.totalHolders(_id);\r\n\t}\r\n\r\n\tfunction accountsByToken(uint256 _id) external view override returns (address[] memory) {\r\n\t\treturn LibERC1155.accountsByToken(_id);\r\n\t}\r\n\r\n\tfunction tokensByAccount(address _account) external view override returns (uint256[] memory) {\r\n\t\treturn LibERC1155.tokensByAccount(_account);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPfmTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { IERC1155 } from \"../base/ERC1155/IERC1155.sol\";\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPfmTokenFacet is IERC1155, CallProtection, ModifierPausable {\r\n\tstring public constant name = \"Arexa AI Platform\";\r\n\tstring public constant symbol = \"AREXA\";\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _id,\r\n\t\tuint256 _value,\r\n\t\tbytes calldata _data\r\n\t) external override protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.safeTransfer(msg.sender, _from, _to, _id, _value, _data);\r\n\t}\r\n\r\n\tfunction safeBatchTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256[] calldata _ids,\r\n\t\tuint256[] calldata _values,\r\n\t\tbytes calldata _data\r\n\t) external override protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.safeTransferBatch(msg.sender, _from, _to, _ids, _values, _data);\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner, uint256 _id) external view override returns (uint256) {\r\n\t\treturn LibERC1155.balanceOf(_owner, _id);\r\n\t}\r\n\r\n\tfunction balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view override returns (uint256[] memory) {\r\n\t\treturn LibERC1155.balanceOfBatch(_owners, _ids);\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address _operator, bool _approved) external override protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.setApprovalForAll(msg.sender, _operator, _approved);\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\r\n\t\treturn LibERC1155.isApprovedForAll(_owner, _operator);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPfmTokenMetadataURIFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { IERC1155 } from \"../base/ERC1155/IERC1155.sol\";\r\nimport { IERC1155MetadataURI } from \"../base/ERC1155/IERC1155MetadataURI.sol\";\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPfmTokenMetadataURIFacet is IERC1155MetadataURI, CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction uri(uint256 _id) external view virtual override returns (string memory) {\r\n\t\treturn LibERC1155.getUri(_id);\r\n\t}\r\n\r\n\tfunction getUri() external view returns (string memory) {\r\n\t\treturn LibERC1155.getUri();\r\n\t}\r\n\r\n\tfunction setURI(string memory newuri) external virtual protectedCall onlyOwner whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.setURI(newuri);\r\n\t}\r\n\r\n\tfunction getTokenBaseUri() external view returns (string memory) {\r\n\t\treturn LibERC1155.getTokenBaseUri();\r\n\t}\r\n\r\n\tfunction setTokenBaseURI(string memory newuri) external virtual protectedCall onlyOwner whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibERC1155.setTokenBaseURI(newuri);\r\n\t}\r\n\r\n\tfunction getTokenUri(uint256 _id) external view returns (string memory) {\r\n\t\treturn LibERC1155.getTokenUri(_id);\r\n\t}\r\n\r\n\tfunction setTokenURI(\r\n\t\tuint256 _id,\r\n\t\tstring memory newuri\r\n\t) external virtual protectedCall onlyOwner whenNotPaused(LibArexaConst.FULL) whenNotPaused(keccak256(abi.encodePacked(_id))) {\r\n\t\tLibERC1155.setTokenURI(_id, newuri);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPfmTokenReceiverFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { IERC1155 } from \"../base/ERC1155/IERC1155.sol\";\r\nimport { IERC1155Receiver } from \"../base/ERC1155/IERC1155Receiver.sol\";\r\n\r\ncontract ArexaPfmTokenReceiverFacet is IERC1155Receiver {\r\n\tconstructor() {}\r\n\r\n\tfunction onERC1155Received(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256 _id,\r\n\t\tuint256 _value,\r\n\t\tbytes calldata _data\r\n\t) external override returns (bytes4) {\r\n\t\treturn LibERC1155.onERC1155Received(_operator, _from, _id, _value, _data);\r\n\t}\r\n\r\n\tfunction onERC1155BatchReceived(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256[] calldata _ids,\r\n\t\tuint256[] calldata _values,\r\n\t\tbytes calldata _data\r\n\t) external override returns (bytes4) {\r\n\t\treturn LibERC1155.onERC1155BatchReceived(_operator, _from, _ids, _values, _data);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPlatformAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\n\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\nimport { ArexaTokenPool } from \"./Platform/LibArexaPlatformStorage.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPlatformAdminFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction getArexaTokenPool(uint8 _tokenType) external view protectedCall returns (ArexaTokenPool memory) {\r\n\t\treturn LibArexaPlatform.getArexaTokenPool(_tokenType);\r\n\t}\r\n\r\n\tfunction createSubscription(\r\n\t\tuint256 tokenType,\r\n\t\tuint16 year,\r\n\t\tuint8 month,\r\n\t\tuint256 quantity,\r\n\t\tuint256 min,\r\n\t\tuint256 max\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) returns (uint256 tokenId) {\r\n\t\trequire(\r\n\t\t\ttokenType == LibArexaConst.SUBSCR1_TOKEN_TYPE || tokenType == LibArexaConst.SUBSCR2_TOKEN_TYPE,\r\n\t\t\t\"Only subscription token type is permitted!\"\r\n\t\t);\r\n\t\ttokenId = LibArexaPlatform.createSubscriptions(msg.sender, tokenType, year, month, quantity, min, max);\r\n\t\tLibERC1155.setTokenURI(tokenId, LibERC1155.getTokenUri(tokenType));\r\n\t}\r\n\r\n\tfunction payArexaTokenFromPool(\r\n\t\tuint8 poolType,\r\n\t\taddress account,\r\n\t\tuint32 quantity\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier4\r\n\t\t//AREXA_TOKEN\r\n\t\t//Price: priceless ;)\r\n\t\t//Quantity: No limit to buy\r\n\t\t//transfer from pool to account\r\n\t\trequire(\r\n\t\t\tpoolType == LibArexaConst.AREXA_TOKEN_POOL_AREXAINC ||\r\n\t\t\t\tpoolType == LibArexaConst.AREXA_TOKEN_POOL_MARKETING ||\r\n\t\t\t\tpoolType == LibArexaConst.AREXA_TOKEN_POOL_DEVELOPMENT,\r\n\t\t\t\"Payout can be made from Arexa, Marketing or Development pool!\"\r\n\t\t);\r\n\t\tLibArexaPlatform.payByArexaToken(poolType, account, quantity);\r\n\t}\r\n\r\n\tfunction buyMagic100TokenAdmin(\r\n\t\taddress toAccount\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier5\r\n\t\t//MAGIC_TOKEN_ID\r\n\t\t//Price: 100.0 USDT/piece\r\n\t\t//An ADMIN can buy to itself token, and then transfer for free\r\n\r\n\t\tLibArexaPlatform.buyMagic100Token(toAccount);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPlatformFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\n\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPlatformFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tuint256 public constant SUBSCR1_TOKEN_TYPE = LibArexaConst.SUBSCR1_TOKEN_TYPE; //Tier 1, every month\r\n\tuint256 public constant SUBSCR2_TOKEN_TYPE = LibArexaConst.SUBSCR2_TOKEN_TYPE; //Tier 2, every month\r\n\tuint256 public constant TRADER_TOKEN_ID = LibArexaConst.TRADER_TOKEN_ID; //Tier 3, unlimited, always mint\r\n\tuint256 public constant AREXA_TOKEN_ID = LibArexaConst.AREXA_TOKEN_ID; //Tier 4, 100000000 piece\r\n\tuint256 public constant MAGIC_TOKEN_ID = LibArexaConst.MAGIC_TOKEN_ID; //Tier 5, 100 piece\r\n\r\n\tuint8 public constant AREXA_TOKEN_POOL_INVESTOR = LibArexaConst.AREXA_TOKEN_POOL_INVESTOR;\r\n\tuint8 public constant AREXA_TOKEN_POOL_AREXAINC = LibArexaConst.AREXA_TOKEN_POOL_AREXAINC;\r\n\tuint8 public constant AREXA_TOKEN_POOL_MARKETING = LibArexaConst.AREXA_TOKEN_POOL_MARKETING;\r\n\tuint8 public constant AREXA_TOKEN_POOL_DEVELOPMENT = LibArexaConst.AREXA_TOKEN_POOL_DEVELOPMENT;\r\n\tuint8 public constant AREXA_TOKEN_POOL_RESERVED = LibArexaConst.AREXA_TOKEN_POOL_RESERVED;\r\n\r\n\tuint8 public constant AMOUNT_VALUE_TYPE = LibArexaPlatform.AMOUNT_VALUE_TYPE;\r\n\tuint8 public constant QUANTITY_VALUE_TYPE = LibArexaPlatform.QUANTITY_VALUE_TYPE;\r\n\r\n\tfunction getCurrentSubscriptionTokenId(uint256 tokenType) external view protectedCall returns (uint256) {\r\n\t\treturn LibArexaPlatform.getCurrentSubscriptionTokenId(tokenType);\r\n\t}\r\n\r\n\tfunction calcSubscriptionPrice(uint256 tokenId, uint32 quantity) external view protectedCall returns (uint256) {\r\n\t\treturn LibArexaPlatform.calcSubscriptionPrice(tokenId, quantity);\r\n\t}\r\n\r\n\tfunction buySubscription(uint256 tokenId, uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier1 Oracle or Tier2 Edge\r\n\t\t//Price: variable USDT/piece, based on algorithm\r\n\t\t//Quantity: 1 per account\r\n\t\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\r\n\t\t// require(balance == 0, \"Only 1 token can be bought per account!\");\r\n\t\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\r\n\t}\r\n\r\n\tfunction buyOracleSubscription(uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier1 Oracle\r\n\t\t//SUBSCR1_TOKEN_TYPE\r\n\t\t//Price: variable USDT/piece, based on algorithm\r\n\t\t//Quantity: 1 per account\r\n\t\tuint256 tokenId = LibArexaPlatform.getCurrentSubscriptionTokenId(SUBSCR1_TOKEN_TYPE);\r\n\t\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\r\n\t\t// require(balance == 0, \"Only 1 token can be bought per account!\");\r\n\t\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\r\n\t}\r\n\r\n\tfunction buyEdgeSubscription(uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier2 Edge\r\n\t\t//SUBSCR2_TOKEN_TYPE\r\n\t\t//Price: variable USDT/piece, based on algorithm\r\n\t\t//Quantity: 1 per account\r\n\t\tuint256 tokenId = LibArexaPlatform.getCurrentSubscriptionTokenId(SUBSCR2_TOKEN_TYPE);\r\n\t\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\r\n\t\t// require(balance == 1, \"Only 1 token can be bought per account!\");\r\n\t\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\r\n\t}\r\n\r\n\tfunction buyTraderToken(uint128 value, uint8 valueType) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier3 Singularity\r\n\t\t//TRADER_TOKEN\r\n\t\t//Price: 1.0 USDT/piece\r\n\t\t//Quantity: No limit to buy\r\n\t\t//valueType: 0 is amount, 1 is quantity\r\n\t\tLibArexaPlatform.buyTraderToken(msg.sender, msg.sender, value, valueType);\r\n\t}\r\n\r\n\tfunction buyArexaToken(uint128 value, uint8 valueType) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier4\r\n\t\t//AREXA_TOKEN\r\n\t\t//Price: 0.1 USDT/piece\r\n\t\t//Quantity: No limit to buy\r\n\t\t//valueType: 0 is amount, 1 is quantity\r\n\t\tLibArexaPlatform.buyArexaToken(msg.sender, value, valueType);\r\n\t}\r\n\r\n\tfunction buyMagic100Token() external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\t//Tier5\r\n\t\t//MAGIC_TOKEN_ID\r\n\t\t//Price: 100.0 USDT/piece\r\n\t\t//Quantity: 1\r\n\r\n\t\trequire(\r\n\t\t\tLibBlackWhiteList._getAccountBlackWhiteList(LibArexaConst.MAGIC100_FIRST_BUYER, msg.sender),\r\n\t\t\t\"Only an approved account can buy the Magic token\"\r\n\t\t);\r\n\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(LibArexaConst.MAGIC100_FIRST_BUYER, msg.sender, false);\r\n\r\n\t\tuint256 balance = LibERC1155.balanceOf(msg.sender, LibArexaConst.MAGIC_TOKEN_ID);\r\n\t\trequire(balance == 0, \"Only 1 Magic token can be bought now!\");\r\n\r\n\t\tLibArexaPlatform.buyMagic100Token(msg.sender);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaPoolPNLFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\n\r\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\r\n\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\nimport { LibTokenPNL } from \"../base/TokenPNL/LibTokenPNL.sol\";\r\nimport { InventoryItem } from \"../base/TokenPNL/LibTokenPNLStorage.sol\";\r\n//import { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\nimport { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\n\r\nimport { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaPoolPNLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction getInventory() external view protectedCall returns (bool isEnabled, int256 sumQuantity, int256 sumAmount, int256 sumPnl) {\r\n\t\treturn LibTokenPNL.getInventory(address(LibArexaPlatform.getPayingToken()), LibArexaConst.AREXA_TOKEN_ID);\r\n\t}\r\n\r\n\tfunction getInventoryItem(address account) external view protectedCall returns (InventoryItem memory) {\r\n\t\treturn LibTokenPNL.getInventoryItem(address(LibArexaPlatform.getPayingToken()), LibArexaConst.AREXA_TOKEN_ID, account);\r\n\t}\r\n\r\n\tfunction calcDivident(address account) external view protectedCall returns (int256) {\r\n\t\treturn LibTokenPNL.calcDivident(address(LibArexaPlatform.getPayingToken()), LibArexaConst.AREXA_TOKEN_ID, account);\r\n\t}\r\n\r\n\tfunction getArexaIncomeParameter(uint256 tokenId) external view protectedCall returns (uint32 pool_, uint32 arexa_) {\r\n\t\tuint256 tokenIdType = (tokenId / 100000000) * 100000000;\r\n\t\trequire(\r\n\t\t\ttokenIdType == LibArexaConst.SUBSCR1_TOKEN_TYPE ||\r\n\t\t\t\ttokenIdType == LibArexaConst.SUBSCR2_TOKEN_TYPE ||\r\n\t\t\t\ttokenIdType == LibArexaConst.TRADER_TOKEN_ID ||\r\n\t\t\t\ttokenIdType == LibArexaConst.AREXA_TOKEN_ID ||\r\n\t\t\t\ttokenIdType == LibArexaConst.MAGIC_TOKEN_ID\r\n\t\t);\r\n\t\t(pool_, arexa_) = LibArexaPlatform.getArexaIncomeParameter(tokenIdType);\r\n\t}\r\n\r\n\tfunction setArexaIncomeParameter(\r\n\t\tuint256 tokenId,\r\n\t\tuint32 pool,\r\n\t\tuint32 arexa\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) {\r\n\t\tuint256 tokenIdType = (tokenId / 100000000) * 100000000;\r\n\t\trequire(\r\n\t\t\ttokenIdType == LibArexaConst.SUBSCR1_TOKEN_TYPE ||\r\n\t\t\t\ttokenIdType == LibArexaConst.SUBSCR2_TOKEN_TYPE ||\r\n\t\t\t\ttokenIdType == LibArexaConst.TRADER_TOKEN_ID ||\r\n\t\t\t\ttokenIdType == LibArexaConst.AREXA_TOKEN_ID ||\r\n\t\t\t\ttokenIdType == LibArexaConst.MAGIC_TOKEN_ID\r\n\t\t);\r\n\t\tLibArexaPlatform.setArexaIncomeParameter(tokenId, pool, arexa);\r\n\t}\r\n\r\n\tfunction payoutArexaIncome(\r\n\t\taddress toAccount,\r\n\t\tuint256 value\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibArexaPlatform.payoutArexaIncome(toAccount, value);\r\n\t}\r\n\r\n\tfunction payoutArexaDivident(\r\n\t\taddress toAccount,\r\n\t\tuint256 value\r\n\t) external protectedCall onlyRole(LibArexaConst.AREXA_ADMIN_ROLE) whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibArexaPlatform.payoutPoolDivident(LibDiamond.getDiamondAddress(), toAccount, value);\r\n\t}\r\n\r\n\tfunction payoutDivident(uint256 value) external protectedCall whenNotPaused(LibArexaConst.FULL) {\r\n\t\tLibArexaPlatform.payoutPoolDivident(msg.sender, msg.sender, value);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaRestrictionFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\n\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\nimport { LibERC1155 } from \"../base/ERC1155/base/LibERC1155.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\n// import { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\n// import { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\n\r\n//import { LibArexaConst } from \"./LibArexaConst.sol\";\r\nimport { LibTokenRestriction } from \"../base/TokenRestriction/LibTokenRestriction.sol\";\r\n\r\ncontract ArexaRestrictionFacet is CallProtection {\r\n\tconstructor() {}\r\n\r\n\tfunction calcUnrestrictedAmount(address account, uint256 tokenId, uint256 amount) external view protectedCall returns (uint256) {\r\n\t\treturn LibTokenRestriction.calcUnrestrictedAmount(account, tokenId, amount);\r\n\t}\r\n\r\n\tfunction checkRestriction(address account, uint256 tokenId, uint256 amount) external view protectedCall {\r\n\t\tLibTokenRestriction.checkRestriction(account, tokenId, amount);\r\n\t}\r\n\r\n\tfunction checkRestrictions(address account, uint256[] calldata tokenIds, uint256[] calldata amounts) external view protectedCall {\r\n\t\tLibTokenRestriction.checkRestrictions(account, tokenIds, amounts);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/ArexaStakingFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibArexaPlatform } from \"./Platform/LibArexaPlatform.sol\";\r\n\r\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\r\n\r\n// import { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\r\n// import { ModifierPausable } from \"../base/TargetedPausable/ModifierPausable.sol\";\r\n\r\n//import { LibArexaConst } from \"./LibArexaConst.sol\";\r\n\r\ncontract ArexaStakingFacet is CallProtection {\r\n\tconstructor() {}\r\n\r\n\tfunction stakeArexaToken(uint256 quantity) external protectedCall {\r\n\t\tLibArexaPlatform.stakeArexaToken(msg.sender, msg.sender, quantity);\r\n\t}\r\n\r\n\tfunction withdrawArexaToken(address fromAccount, address toAccount, uint256 _quantity) external protectedCall {\r\n\t\tLibArexaPlatform.withdrawArexaToken(msg.sender, fromAccount, toAccount, _quantity);\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/LibArexaConst.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nlibrary LibArexaConst {\r\n\t//\r\n\t//Pausable\r\n\tbytes32 public constant FULL = 0x00;\r\n\tbytes32 public constant SUBSCR1_TOKEN = keccak256(abi.encode(\"TOKEN\", LibArexaConst.SUBSCR1_TOKEN_TYPE));\r\n\tbytes32 public constant SUBSCR2_TOKEN = keccak256(abi.encode(\"TOKEN\", LibArexaConst.SUBSCR2_TOKEN_TYPE));\r\n\tbytes32 public constant TRADER_TOKEN = keccak256(abi.encode(\"TOKEN\", LibArexaConst.TRADER_TOKEN_ID));\r\n\tbytes32 public constant AREXA_TOKEN = keccak256(abi.encode(\"TOKEN\", LibArexaConst.AREXA_TOKEN_ID));\r\n\tbytes32 public constant MAGIC_TOKEN = keccak256(abi.encode(\"TOKEN\", LibArexaConst.MAGIC_TOKEN_ID));\r\n\r\n\t//Roles\r\n\tbytes32 public constant AREXA_ADMIN_ROLE = keccak256(\"AREXA_ADMIN_ROLE\");\r\n\t//bytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\"AREXA_TOKEN_ADMIN_ROLE\");\r\n\t//bytes32 public constant TREASURY_ROLE = keccak256(\"AREXA_TREASURY_ROLE\");\r\n\r\n\t//BlackWhite lists\r\n\tbytes32 public constant MAGIC100_FIRST_BUYER = keccak256(\"MAGIC100_FIRST_BUYER\"); //WhiteList\r\n\r\n\t//TokenIDs:\r\n\tuint256 public constant SUBSCR1_TOKEN_TYPE = 100000000; //Tier 1, every month\r\n\tuint256 public constant SUBSCR2_TOKEN_TYPE = 200000000; //Tier 2, every month\r\n\tuint256 public constant TRADER_TOKEN_ID = 300000000; //Tier 3, unlimited, always mint\r\n\tuint256 public constant AREXA_TOKEN_ID = 400000000; //Tier 4, 100000000 piece\r\n\tuint256 public constant MAGIC_TOKEN_ID = 500000000; //Tier 5, 100 piece\r\n\r\n\t//AREXA TOKEN POOL TYPES:\r\n\tuint8 public constant AREXA_TOKEN_POOL_INVESTOR = 1; //35M\r\n\tuint8 public constant AREXA_TOKEN_POOL_AREXAINC = 2; //5M\r\n\tuint8 public constant AREXA_TOKEN_POOL_MARKETING = 3; //5M\r\n\tuint8 public constant AREXA_TOKEN_POOL_DEVELOPMENT = 4; //5M\r\n\tuint8 public constant AREXA_TOKEN_POOL_RESERVED = 5; //50M\r\n}\r\n"
    },
    "contracts/ArexaPlatform/Platform/LibArexaPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\nimport \"./LibArexaPlatformStorage.sol\";\r\nimport \"../../utils/Math.sol\";\r\nimport \"../../utils/SafeERC20.sol\";\r\nimport \"../../base/Diamond/LibDiamond.sol\";\r\nimport \"../../base/ERC1155/base/LibERC1155.sol\";\r\nimport \"../../base/TokenRestriction/LibTokenRestriction.sol\";\r\nimport \"../../base/TokenPNL/LibTokenPNL.sol\";\r\nimport \"../../base/TokenDynamicPricing/LibTokenDynamicPricing.sol\";\r\n\r\nimport \"../LibArexaConst.sol\";\r\n\r\nimport { IERC20 } from \"../../base/ERC20/IERC20.sol\";\r\nimport { IERC20Metadata } from \"../../base/ERC20/metadata/IERC20Metadata.sol\";\r\nimport \"../../base/BridgeCentralized/IBridgeableToken.sol\";\r\n\r\nlibrary LibArexaPlatform {\r\n\tuint8 public constant AMOUNT_VALUE_TYPE = 0;\r\n\tuint8 public constant QUANTITY_VALUE_TYPE = 1;\r\n\r\n\tfunction _initArexaTokenPool(uint8 _tokenType, address _operator, address _tokenOwner, uint256 _amount) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\trequire(arexa.arexaTokenPool[_tokenType].total == 0, \"Arexa token pool is already initialized with the give type!\");\r\n\t\tarexa.arexaTokenPool[_tokenType].total = _amount;\r\n\t\tLibERC1155.mint(_operator, _tokenOwner, LibArexaConst.AREXA_TOKEN_ID, _amount, \"\");\r\n\t}\r\n\r\n\tfunction initialize(address _operator, IERC20 payingToken, IERC20 arexaERC20Token, uint64 restrictionTimeDelta) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tarexa.payingERC20Token = payingToken;\r\n\t\tarexa.arexaERC20Token = arexaERC20Token;\r\n\r\n\t\t/*\r\n\t\t * Tier I: LibArexaConst.SUBSCR_TOKEN_TYPE_1\r\n\t\t */\r\n\t\tsetArexaIncomeParameter(LibArexaConst.SUBSCR1_TOKEN_TYPE, 90, 10);\r\n\r\n\t\t/*\r\n\t\t * Tier II: LibArexaConst.SUBSCR_TOKEN_TYPE_2\r\n\t\t */\r\n\t\tsetArexaIncomeParameter(LibArexaConst.SUBSCR2_TOKEN_TYPE, 95, 5);\r\n\r\n\t\t/*\r\n\t\t * Tier III: LibArexaConst.TRADER_TOKEN_ID\r\n\t\t */\r\n\t\tsetArexaIncomeParameter(LibArexaConst.TRADER_TOKEN_ID, 995, 5);\r\n\r\n\t\t/*\r\n\t\t * Tier IV: LibArexaConst.AREXA_TOKEN_ID\r\n\t\t */\r\n\t\tsetArexaIncomeParameter(LibArexaConst.AREXA_TOKEN_ID, 90, 10);\r\n\r\n\t\t//Engedélyezzük a tokenre a PNL számolást, így inicializálódik teljes darabszám is a PNLnél.\r\n\t\tLibTokenPNL.initTokenPNL(address(payingToken), LibArexaConst.AREXA_TOKEN_ID);\r\n\r\n\t\t//Ez által olyan mintha már nem kéne restriction-t kezelni, és a teljes összeg megy a kifizethetőbe\r\n\t\tLibTokenRestriction.initTokenRestriction(LibArexaConst.AREXA_TOKEN_ID, block.number, block.number + 1, restrictionTimeDelta);\r\n\r\n\t\t//kibocsájtjuk a poolba a tokeneket, de azonnal eladhatóak lesznek, a reserved tokeneket csak restriction élesítés után\r\n\t\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_INVESTOR, _operator, contractAddress, 35000000);\r\n\t\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_AREXAINC, _operator, contractAddress, 5000000);\r\n\t\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_MARKETING, _operator, contractAddress, 5000000);\r\n\t\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_DEVELOPMENT, _operator, contractAddress, 5000000);\r\n\r\n\t\t//Véglegesítjük a restriction paramétereket\r\n\t\tLibTokenRestriction.initTokenRestriction(\r\n\t\t\tLibArexaConst.AREXA_TOKEN_ID,\r\n\t\t\tblock.number + 12 * restrictionTimeDelta + 1,\r\n\t\t\tblock.number + 12 * restrictionTimeDelta + 1 + 12 * restrictionTimeDelta + 1,\r\n\t\t\trestrictionTimeDelta\r\n\t\t);\r\n\r\n\t\t//A reserved poolba most hozzuk létre, így a restriction érvényes lesz rá\r\n\t\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_RESERVED, _operator, contractAddress, 50000000);\r\n\r\n\t\t/*\r\n\t\t * Tier V: LibArexaConst.MAGIC_TOKEN_ID\r\n\t\t */\r\n\t\tsetArexaIncomeParameter(LibArexaConst.MAGIC_TOKEN_ID, 0, 100);\r\n\t\tLibERC1155.mint(_operator, contractAddress, LibArexaConst.MAGIC_TOKEN_ID, 100, \"\");\r\n\t}\r\n\r\n\t//TODO do the other functions...\r\n\tfunction getArexaTokenPool(uint8 _tokenType) internal view returns (ArexaTokenPool memory) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\treturn arexa.arexaTokenPool[_tokenType];\r\n\t}\r\n\r\n\tfunction setArexaIncomeParameter(uint256 _tokenId, uint32 _pool, uint32 _arexa) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\tarexa.arexaIncomeParameter[_tokenId].pool = _pool;\r\n\t\tarexa.arexaIncomeParameter[_tokenId].arexa = _arexa;\r\n\t}\r\n\r\n\tfunction getArexaIncomeParameter(uint256 _tokenId) internal view returns (uint32 pool_, uint32 arexa_) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\tpool_ = arexa.arexaIncomeParameter[_tokenId].pool;\r\n\t\tarexa_ = arexa.arexaIncomeParameter[_tokenId].arexa;\r\n\t}\r\n\r\n\tfunction getPayingToken() internal view returns (IERC20) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\treturn arexa.payingERC20Token;\r\n\t}\r\n\r\n\tfunction setPayingToken(IERC20 _token) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\tarexa.payingERC20Token = _token;\r\n\t}\r\n\r\n\tfunction getArexaERC20Token() internal view returns (IERC20) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\treturn arexa.arexaERC20Token;\r\n\t}\r\n\r\n\tfunction _divideAmountPoolAndArexa(uint256 _tokenId, uint256 _value) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tuint256 poolAmount = (_value * arexa.arexaIncomeParameter[_tokenId].pool) /\r\n\t\t\t(arexa.arexaIncomeParameter[_tokenId].pool + arexa.arexaIncomeParameter[_tokenId].arexa);\r\n\t\tuint256 arexaAmount = _value - poolAmount;\r\n\r\n\t\tLibTokenPNL.changeTotalValue(address(arexa.payingERC20Token), LibArexaConst.AREXA_TOKEN_ID, int256(poolAmount));\r\n\t\tarexa.poolBalance += poolAmount;\r\n\t\tarexa.arexaBalance += arexaAmount;\r\n\t}\r\n\r\n\tfunction createSubscriptions(\r\n\t\taddress _operator,\r\n\t\tuint256 _tokenType,\r\n\t\tuint16 _year,\r\n\t\tuint8 _month,\r\n\t\tuint256 _quantity,\r\n\t\tuint256 _min,\r\n\t\tuint256 _max\r\n\t) internal returns (uint256 tokenId) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\t//100 000 000 10**8\r\n\t\t// 20 240 000\r\n\t\tuint256 monthlyTokenType = _tokenType + uint256(_year) * 10 ** 4 + uint256(_month) * 10 ** 2;\r\n\r\n\t\trequire(int256(arexa.lastSubscriptionTokenIds[_tokenType]) - int256(monthlyTokenType) < 99, \"Can't create for old months\");\r\n\r\n\t\tif (arexa.lastSubscriptionTokenIds[_tokenType] < monthlyTokenType) {\r\n\t\t\tarexa.lastSubscriptionTokenIds[_tokenType] = monthlyTokenType;\r\n\t\t}\r\n\t\tarexa.lastSubscriptionTokenIds[_tokenType]++;\r\n\t\ttokenId = arexa.lastSubscriptionTokenIds[_tokenType];\r\n\t\tLibTokenDynamicPricing.initialize(tokenId, _quantity, _min, _max);\r\n\t\tLibERC1155.mint(_operator, LibDiamond.getDiamondAddress(), tokenId, _quantity, \"\");\r\n\t}\r\n\r\n\tfunction getCurrentSubscriptionTokenId(uint256 _tokenType) internal view returns (uint256) {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\treturn arexa.lastSubscriptionTokenIds[_tokenType];\r\n\t}\r\n\r\n\tfunction calcSubscriptionPrice(uint256 _tokenId, uint32 _quantity) internal view returns (uint256) {\r\n\t\treturn LibTokenDynamicPricing.calcTotalValue(_tokenId, _quantity);\r\n\t}\r\n\r\n\tfunction buySubscription(uint256 _tokenId, address _account, uint32 _quantity) internal {\r\n\t\t//Tier3\r\n\t\t//AREXA_TOKEN\r\n\t\t//Price: d USDT/piece\r\n\t\t//Quantity: No limit to buy\r\n\t\t//_valueType: 0 is amount, 1 is quantity\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tuint256 amount = LibTokenDynamicPricing.buyQuantity(_tokenId, _quantity);\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tSafeERC20.safeTransferFrom(arexa.payingERC20Token, _account, contractAddress, amount);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\r\n\t\t//divide the amount to pool and arexa\r\n\t\t//SUBSCR1_TOKEN_TYPE OR SUBSCR2_TOKEN_TYPE lesz a vége\r\n\t\tuint256 tokenType = (_tokenId / 100000000) * 100000000;\r\n\t\t_divideAmountPoolAndArexa(tokenType, amount);\r\n\r\n\t\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, _tokenId, _quantity, \"\");\r\n\t}\r\n\r\n\tfunction buyTraderToken(address _operator, address _account, uint128 _value, uint8 _valueType) internal {\r\n\t\t//Tier3\r\n\t\t//AREXA_TOKEN\r\n\t\t//Price: 1.0 USDT/piece\r\n\t\t//Quantity: No limit to buy\r\n\t\t//_valueType: 0 is amount, 1 is quantity\r\n\t\trequire(_valueType == 0 || _valueType == 1, \"valueType can be 0 or 1 only!\");\r\n\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\r\n\t\tuint256 priceFactor = 10;\r\n\t\tuint256 price = decimal * priceFactor * 1;\r\n\r\n\t\tuint256 amount = 0;\r\n\t\tuint256 quantity = 0;\r\n\t\tif (_valueType == 1) {\r\n\t\t\tamount = ((_value * 10 * price) / priceFactor + 5) / 10; //add 5 and div 10: rounding to the nearest\r\n\t\t\tquantity = (amount * priceFactor) / price;\r\n\t\t\trequire(amount > 0 && quantity > 0, \"The input quantity is too small for paying token!\");\r\n\t\t} else {\r\n\t\t\tquantity = (_value * priceFactor) / price;\r\n\t\t\tamount = (quantity * price) / priceFactor;\r\n\t\t\trequire(amount > 0 && quantity > 0, \"The input amount is too small for buying a token!\");\r\n\t\t}\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tSafeERC20.safeTransferFrom(arexa.payingERC20Token, _account, contractAddress, amount);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\r\n\t\t//divide the amount to pool and arexa, fontos a sorrend, mielőtt megkapta a tokent és adminisztráltuk a PNL változást, előtte növeljük a pool értéket\r\n\t\t//azért mert így a deltaPNLben nem napja meg maga után járó részt.\r\n\t\t_divideAmountPoolAndArexa(LibArexaConst.TRADER_TOKEN_ID, amount);\r\n\r\n\t\tLibERC1155.mint(_operator, _account, LibArexaConst.TRADER_TOKEN_ID, quantity, \"\");\r\n\t}\r\n\r\n\tfunction buyArexaToken(address _account, uint128 _value, uint8 _valueType) internal {\r\n\t\t//Tier4\r\n\t\t//AREXA_TOKEN\r\n\t\t//Price: 0.1 USDT/piece\r\n\t\t//Quantity: No limit to buy\r\n\t\t//_valueType: 0 is amount, 1 is quantity\r\n\r\n\t\trequire(_valueType == 0 || _valueType == 1, \"valueType can be 0 or 1 only!\");\r\n\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\r\n\t\tuint256 priceFactor = 10;\r\n\t\tuint256 price = ((decimal * priceFactor) * 1) / 10;\r\n\r\n\t\tuint256 amount = 0;\r\n\t\tuint256 quantity = 0;\r\n\t\tif (_valueType == 1) {\r\n\t\t\tamount = ((_value * 10 * price) / priceFactor + 5) / 10; //add 5 and div 10: rounding to the nearest\r\n\t\t\tquantity = (amount * priceFactor) / price;\r\n\t\t\trequire(amount > 0 && quantity > 0, \"The input quantity is too small for paying token\");\r\n\t\t} else {\r\n\t\t\tquantity = (_value * priceFactor) / price;\r\n\t\t\tamount = (quantity * price) / priceFactor;\r\n\t\t\trequire(amount > 0 && quantity > 0, \"The input amount is too small for buying a token\");\r\n\t\t}\r\n\r\n\t\tArexaTokenPool storage tokenPool = arexa.arexaTokenPool[LibArexaConst.AREXA_TOKEN_POOL_INVESTOR];\r\n\t\trequire(tokenPool.sold + quantity <= tokenPool.total, \"Not enough token to sell\");\r\n\t\ttokenPool.sold = tokenPool.sold + quantity;\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tSafeERC20.safeTransferFrom(arexa.payingERC20Token, _account, contractAddress, amount);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\r\n\t\t//divide the amount to pool and arexa, fontos a sorrend, mielőtt megkapta a tokent és adminisztráltuk a PNL változást, előtte növeljük a pool értéket\r\n\t\t//azért mert így a deltaPNLben nem napja meg maga után járó részt.\r\n\t\t_divideAmountPoolAndArexa(LibArexaConst.AREXA_TOKEN_ID, amount);\r\n\r\n\t\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.AREXA_TOKEN_ID, quantity, \"\");\r\n\t\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + quantity;\r\n\t}\r\n\r\n\tfunction payByArexaToken(uint8 _poolType, address _account, uint32 _quantity) internal {\r\n\t\t//Tier4\r\n\t\t//AREXA_TOKEN GIFT\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tArexaTokenPool storage tokenPool = arexa.arexaTokenPool[_poolType];\r\n\t\trequire(tokenPool.sold + _quantity <= tokenPool.total, \"Not enoguh token to gift\");\r\n\t\ttokenPool.sold = tokenPool.sold + _quantity;\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.AREXA_TOKEN_ID, _quantity, \"\");\r\n\t\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + _quantity;\r\n\t}\r\n\r\n\tfunction buyMagic100Token(address _account) internal {\r\n\t\t//Tier5\r\n\t\t//MAGIC_TOKEN_ID\r\n\t\t//Price: 100.0 USDT/piece\r\n\t\t//Quantity: 1\r\n\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\r\n\t\tuint256 amount = 100 * decimal;\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\tSafeERC20.safeTransferFrom(arexa.payingERC20Token, _account, contractAddress, amount);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\r\n\t\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.MAGIC_TOKEN_ID, 1, \"\");\r\n\r\n\t\t//divide the amount to pool and arexa, fontos a sorrend, miután megkapta a tokent és adminisztráltuk a PNL változást, utána növeljük a pool értéket csak!\r\n\t\t_divideAmountPoolAndArexa(LibArexaConst.MAGIC_TOKEN_ID, amount);\r\n\t}\r\n\r\n\tfunction payoutArexaIncome(address _account, uint256 _value) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\t\trequire(_value <= arexa.arexaBalance, \"Not enough amount to pay out!\");\r\n\r\n\t\tarexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _account, _value);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _account, _value);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\t}\r\n\r\n\tfunction payoutPoolDivident(address _collectingAccount, address _toAccount, uint256 _amount) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\tLibTokenPNL.refreshPayoutDivident(\r\n\t\t\taddress(LibArexaPlatform.getPayingToken()),\r\n\t\t\tLibArexaConst.AREXA_TOKEN_ID,\r\n\t\t\t_collectingAccount,\r\n\t\t\tint256(_amount)\r\n\t\t);\r\n\t\tarexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _toAccount, _amount);\r\n\t\t// bool result = arexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _toAccount, _amount);\r\n\t\t// require(result, \"Something wrong with the payment!\");\r\n\t}\r\n\r\n\tfunction stakeArexaToken(address _fromAccount, address _toAccount, uint256 _quantity) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\t//Caclulate each token quantity from input. Input is an arexa20Quantity, but can have decimals fractions, so have to \"round floor\"\r\n\t\t//arexa11555Quantity have only whole number\r\n\t\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.arexaERC20Token)).decimals();\r\n\t\tuint256 arexa11555Quantity = _quantity / decimal;\r\n\t\tuint256 arexa20Quantity = arexa11555Quantity * decimal;\r\n\r\n\t\trequire(arexa11555Quantity > 0 && arexa20Quantity > 0, \"The input amount is too small for staking (AREXA AI token)\");\r\n\r\n\t\t//Burn the Arexa AI ERC20 from user\r\n\t\tIBridgeableToken(address(arexa.arexaERC20Token)).burnFrom(_fromAccount, arexa20Quantity);\r\n\r\n\t\taddress contractAddress = LibDiamond.getDiamondAddress();\r\n\r\n\t\t//Transfer Arexa AI Token from contract to user\r\n\t\tLibERC1155.safeTransfer(contractAddress, contractAddress, _toAccount, LibArexaConst.AREXA_TOKEN_ID, arexa11555Quantity, \"\");\r\n\t\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + arexa11555Quantity;\r\n\t}\r\n\r\n\tfunction withdrawArexaToken(address _operator, address _fromAccount, address _toAccount, uint256 _quantity) internal {\r\n\t\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\r\n\r\n\t\t//Caclulate each token quantity from input. Input is an arexa11555Quantity\r\n\t\t//arexa11555Quantity have only whole number\r\n\t\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.arexaERC20Token)).decimals();\r\n\t\tuint256 arexa20Quantity = _quantity * decimal;\r\n\r\n\t\t//Transfer Arexa AI Token from user to contract\r\n\t\tLibERC1155.safeTransfer(_operator, _fromAccount, LibDiamond.getDiamondAddress(), LibArexaConst.AREXA_TOKEN_ID, _quantity, \"\");\r\n\r\n\t\t//Mint the Arexa AI ERC20 to user\r\n\t\tIBridgeableToken(address(arexa.arexaERC20Token)).mint(_toAccount, arexa20Quantity);\r\n\r\n\t\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity - _quantity;\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaPlatform/Platform/LibArexaPlatformStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 AREXA\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport { IERC20 } from \"../../base/ERC20/IERC20.sol\";\r\n\r\nstruct ArexaTokenPool {\r\n\tuint256 total;\r\n\tuint256 sold;\r\n}\r\n\r\nstruct ArexaIncomeParameter {\r\n\tuint32 pool;\r\n\tuint32 arexa;\r\n}\r\n\r\nstruct ArexaPlatformStorage {\r\n\tmapping(uint8 => ArexaTokenPool) arexaTokenPool;\r\n\tmapping(uint256 => ArexaIncomeParameter) arexaIncomeParameter;\r\n\tIERC20 payingERC20Token; //USDT\r\n\tuint256 poolBalance; //The \"pool\" part of the sum income\r\n\tuint256 arexaBalance; //The \"owner\" part of the sum income\r\n\t//tokenType => lastSubscriptionTokenId\r\n\tmapping(uint256 => uint256) lastSubscriptionTokenIds;\r\n\tIERC20 arexaERC20Token; //AREXA\r\n\tuint256 stakedArexaERC20TokenQuantity;\r\n}\r\n\r\nlibrary LibArexaPlatformStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.contracts.arexa-platform.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (ArexaPlatformStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenACLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenACLFacet } from \"../base/ERC20Diamond/TokenACLFacet.sol\";\r\n\r\ncontract ArexaTokenACLFacet is TokenACLFacet {\r\n\tconstructor() TokenACLFacet() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenAdminFacet } from \"../base/ERC20Diamond/TokenAdminFacet.sol\";\r\n\r\ncontract ArexaTokenAdminFacet is TokenAdminFacet {\r\n\tconstructor() TokenAdminFacet() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenAMLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenAMLFacet } from \"../base/ERC20Diamond/TokenAMLFacet.sol\";\r\n\r\ncontract ArexaTokenAMLFacet is TokenAMLFacet {\r\n\tconstructor() TokenAMLFacet() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { uSmartERC20 } from \"../base/ERC20Token/ERC20Token.sol\";\r\n\r\ncontract ArexaTokenFacet is uSmartERC20 {\r\n\tconstructor() uSmartERC20() {}\r\n}\r\n"
    },
    "contracts/ArexaToken/ArexaTokenOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\n/**\n * Copyright (C) 2023 uSmart (Andras Szabolcsi)\n */\npragma solidity ^0.8.9;\n\nimport { TokenOwnershipFacet } from \"../base/ERC20Diamond/TokenOwnershipFacet.sol\";\n\ncontract ArexaTokenOwnershipFacet is TokenOwnershipFacet {\n\tconstructor() TokenOwnershipFacet() {}\n}\n"
    },
    "contracts/ArexaToken/ArexaTokenPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\r\n/**\r\n * Copyright (C) 2023 uSmart (Andras Szabolcsi)\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { TokenPausableFacet } from \"../base/ERC20Diamond/TokenPausableFacet.sol\";\r\n\r\ncontract ArexaTokenPausableFacet is TokenPausableFacet {\r\n\tconstructor() TokenPausableFacet() {}\r\n}\r\n"
    },
    "contracts/base/AccessControl/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibAccessControl.sol\";\r\n\r\nimport { IAccessControl } from \"./IAccessControl.sol\";\r\n\r\nabstract contract AccessControl is IAccessControl {\r\n\tmodifier onlyRole(bytes32 role) {\r\n\t\tLibAccessControl._checkRole(role);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction hasRole(bytes32 role, address account) external view virtual returns (bool) {\r\n\t\treturn LibAccessControl._hasRole(role, account);\r\n\t}\r\n\r\n\tfunction grantRole(bytes32 role, address account) external virtual onlyRole(LibAccessControl._getRoleAdmin(role)) {\r\n\t\tLibAccessControl._grantRole(role, account);\r\n\t}\r\n\r\n\tfunction revokeRole(bytes32 role, address account) external virtual onlyRole(LibAccessControl._getRoleAdmin(role)) {\r\n\t\tLibAccessControl._revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction renounceRole(bytes32 role, address account) external virtual {\r\n\t\trequire(account == msg.sender, \"AccessControl: can only renounce roles for self\");\r\n\r\n\t\tLibAccessControl._revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) external view virtual override returns (bytes32) {\r\n\t\treturn LibAccessControl._getRoleAdmin(role);\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n\t\tLibAccessControl._setRoleAdmin(role, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal virtual {\r\n\t\tLibAccessControl._grantRole(role, account);\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal virtual {\r\n\t\tLibAccessControl._revokeRole(role, account);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title AccessControl interface\r\n */\r\ninterface IAccessControl {\r\n\t/*\r\n\t * @notice query whether role is assigned to account\r\n\t * @param role role to query\r\n\t * @param account account to query\r\n\t * @return whether role is assigned to account\r\n\t */\r\n\tfunction hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n\t/*\r\n\t * @notice assign role to given account\r\n\t * @param role role to assign\r\n\t * @param account recipient of role assignment\r\n\t */\r\n\tfunction grantRole(bytes32 role, address account) external;\r\n\r\n\t/*\r\n\t * @notice unassign role from given account\r\n\t * @param role role to unassign\r\n\t * @parm account\r\n\t */\r\n\tfunction revokeRole(bytes32 role, address account) external;\r\n\r\n\t/**\r\n\t * @notice relinquish role\r\n\t * @param role role to relinquish\r\n\t */\r\n\tfunction renounceRole(bytes32 role) external;\r\n\r\n\t/*\r\n\t * @notice query admin role for given role\r\n\t * @param role role to query\r\n\t * @return admin role\r\n\t */\r\n\tfunction getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n\t/**\r\n\t * @notice Returns one of the accounts that have `role`. `index` must be a\r\n\t * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n\t *\r\n\t * Role bearers are not sorted in any particular way, and their ordering may\r\n\t * change at any point.\r\n\t *\r\n\t * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n\t * you perform all queries on the same block. See the following\r\n\t * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n\t * for more information.\r\n\t */\r\n\tfunction getRoleMember(bytes32 role, uint256 index) external view returns (address);\r\n\r\n\t/**\r\n\t * @notice Returns the number of accounts that have `role`. Can be used\r\n\t * together with {getRoleMember} to enumerate all bearers of a role.\r\n\t */\r\n\tfunction getRoleMemberCount(bytes32 role) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/base/AccessControl/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibAccessControlStorage.sol\";\r\n\r\nimport { IERC173 } from \"../../interfaces/IERC173.sol\";\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport { UintUtils } from \"../../utils/UintUtils.sol\";\r\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\r\n\r\nlibrary LibAccessControl {\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\tusing UintUtils for uint256;\r\n\tusing AddressUtils for address;\r\n\r\n\terror Ownable__NotOwner();\r\n\terror Ownable__NotTransitiveOwner();\r\n\r\n\terror AccessDenied(bytes32 role, address account);\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\r\n\tbytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\tfunction _setOwner(address _newOwner) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\taddress previousOwner = acls.owner;\r\n\t\tacls.owner = _newOwner;\r\n\r\n\t\t//Init DEFAULT_ADMIN_ROLE to _newOwner\r\n\t\tLibAccessControl._grantRole(LibAccessControl.DEFAULT_ADMIN_ROLE, _newOwner);\r\n\r\n\t\temit OwnershipTransferred(previousOwner, _newOwner);\r\n\t}\r\n\r\n\tfunction _owner() internal view returns (address owner_) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\towner_ = acls.owner;\r\n\t}\r\n\r\n\tfunction _transitiveOwner() internal view returns (address owner_) {\r\n\t\towner_ = LibAccessControl._owner();\r\n\r\n\t\twhile (owner_.isContract()) {\r\n\t\t\ttry IERC173(owner_).owner() returns (address transitiveOwner) {\r\n\t\t\t\towner_ = transitiveOwner;\r\n\t\t\t} catch {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _enforceIsOwner() internal view {\r\n\t\t//require(msg.sender == _owner(), \"Not owner!\");\r\n\t\tif (msg.sender != _owner()) {\r\n\t\t\trevert Ownable__NotOwner();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _enforceIsTransitiveOwner() internal view {\r\n\t\t//require(msg.sender == _transitiveOwner(), \"Not transitive owner!\");\r\n\t\tif (msg.sender != _transitiveOwner()) {\r\n\t\t\trevert Ownable__NotTransitiveOwner();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice assign role to given account\r\n\t * @param _role role to assign\r\n\t * @param _account recipient of role assignment\r\n\t */\r\n\tfunction _grantRole(bytes32 _role, address _account) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\tif (!_hasRole(_role, _account)) {\r\n\t\t\tacls.roles[acls.owner][_role].members.add(_account);\r\n\t\t\temit RoleGranted(acls.owner, _role, _account, msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice unassign role from given account\r\n\t * @param _role role to unassign\r\n\t * @param _account account to revokeAccessControlStorage\r\n\t */\r\n\tfunction _revokeRole(bytes32 _role, address _account) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\t// require(_role != LibAccessControl.DEFAULT_ADMIN_ROLE && _account != acls.owner);\r\n\t\tacls.roles[acls.owner][_role].members.remove(_account);\r\n\t\temit RoleRevoked(acls.owner, _role, _account, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice relinquish role\r\n\t * @param _role role to relinquish\r\n\t */\r\n\tfunction _renounceRole(bytes32 _role) internal {\r\n\t\t_revokeRole(_role, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Query one of the accounts that have role of the project\r\n\t * @dev WARNING: When using _getProjectRoleMember and _getProjectRoleMemberCount, make sure you perform all queries on the same block.\r\n\t * @param _role role to query\r\n\t * @param _index index of role member\r\n\t */\r\n\tfunction _getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.at(_index);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Query the number of accounts that have role.\r\n\t * @dev WARNING: When using _getRoleMember and _getRoleMemberCount, make sure you perform all queries on the same block.\r\n\t * @param _role role to query\r\n\t */\r\n\tfunction _getRoleMemberCount(address, bytes32 _role) internal view returns (uint256) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.length();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query whether role is assigned to account\r\n\t * @param _role role to query\r\n\t * @param _account account to query\r\n\t * @return bool whether role is assigned to account\r\n\t */\r\n\tfunction _hasRole(bytes32 _role, address _account) internal view returns (bool) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].members.contains(_account);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice revert if sender does not have given role\r\n\t * @param _role role to query\r\n\t */\r\n\tfunction _checkRole(bytes32 _role) internal view {\r\n\t\t_checkRole(_role, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice revert if given account does not have given role\r\n\t * @param _role role to query\r\n\t * @param _account to query\r\n\t */\r\n\tfunction _checkRole(bytes32 _role, address _account) internal view {\r\n\t\tif (!_hasRole(_role, _account)) {\r\n\t\t\trevert AccessDenied({ role: _role, account: _account });\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query admin role for given role\r\n\t * @param _role role to query\r\n\t * @return admin role\r\n\t */\r\n\tfunction _getRoleAdmin(bytes32 _role) internal view returns (bytes32) {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\treturn acls.roles[acls.owner][_role].adminRole;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice set role as admin role\r\n\t * @param _role role to set\r\n\t * @param _adminRole admin role to set\r\n\t */\r\n\tfunction _setRoleAdmin(bytes32 _role, bytes32 _adminRole) internal {\r\n\t\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\r\n\t\tbytes32 previousAdminRole = _getRoleAdmin(_role);\r\n\t\tacls.roles[acls.owner][_role].adminRole = _adminRole;\r\n\t\temit RoleAdminChanged(acls.owner, _role, previousAdminRole, _adminRole);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/LibAccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport \"./RoleData.sol\";\r\n\r\nstruct AccessControllStorage {\r\n\t//owner => role => adminRole, members mapping\r\n\taddress owner;\r\n\tmapping(address => mapping(bytes32 => RoleData)) roles;\r\n}\r\n\r\nlibrary LibAccessControlStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.access-control.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (AccessControllStorage storage acls_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tacls_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/ModifierRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"./LibAccessControl.sol\";\r\n\r\nabstract contract ModifierRole {\r\n\tmodifier onlyOwner() {\r\n\t\tLibAccessControl._enforceIsOwner();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyTransitiveOwner() {\r\n\t\tLibAccessControl._enforceIsTransitiveOwner();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyRole(bytes32 role) {\r\n\t\tLibAccessControl._checkRole(role);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyRoleAdmin(bytes32 role) {\r\n\t\tLibAccessControl._checkRole(LibAccessControl._getRoleAdmin(role));\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/AccessControl/RoleData.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct RoleData {\r\n\tbytes32 adminRole;\r\n\tEnumerableSet.AddressSet members;\r\n}\r\n"
    },
    "contracts/base/BlackWhiteList/LibBlackWhiteList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibBlackWhiteListStorage.sol\";\r\n\r\nlibrary LibBlackWhiteList {\r\n\t//_target: which list is belongs to...\r\n\t//_account: an account on a _target\r\n\t//_lockValue:\r\n\t//  - if _target is a blackList than true _lockValue means that the account is prohibited\r\n\t//  - if _target is a blackList than false _lockValue means that the account is acceptable\r\n\t//  - if _target is a whiteList than true _lockValue means that the account is acceptable\r\n\t//  - if _target is a whiteList than false _lockValue means that the account is prohibited\r\n\tevent AccountBlackWhiteList(bytes32 indexed _target, address indexed _account, bool _lockValue);\r\n\r\n\tfunction _getAccountBlackWhiteList(bytes32 _target, address _account) internal view returns (bool lockValue_) {\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\tlockValue_ = wls.whiteList[_target][_account];\r\n\t}\r\n\r\n\tfunction _setAccountBlackWhiteList(bytes32 _target, address _account, bool _lockValue) internal {\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\twls.whiteList[_target][_account] = _lockValue;\r\n\t\temit AccountBlackWhiteList(_target, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction _setBatchAccountBlackWhiteList(bytes32 _target, address[] calldata _accounts, bool _lockValue) internal {\r\n\t\trequire(_accounts.length <= 255, \"Batch: too many addresses\");\r\n\t\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\r\n\t\tfor (uint8 i = 0; i < _accounts.length; i++) {\r\n\t\t\twls.whiteList[_target][_accounts[i]] = _lockValue;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/BlackWhiteList/LibBlackWhiteListStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct BlackWhiteListStorage {\r\n\tmapping(bytes32 => mapping(address => bool)) whiteList;\r\n}\r\n\r\nlibrary LibBlackWhiteListStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.white-list.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (BlackWhiteListStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/BridgeCentralized/BridgeRequest.struct.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nstruct BridgeRequest {\r\n\tuint256 fromChainId;\r\n\taddress fromToken;\r\n\taddress fromAddress;\r\n\tuint256 toChainId;\r\n\taddress toToken;\r\n\taddress toAddress;\r\n\tuint256 amount;\r\n\tuint256 nonce;\r\n}\r\n"
    },
    "contracts/base/BridgeCentralized/IBridgeableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IBridgeableToken {\r\n\tfunction mint(address to, uint256 amount) external;\r\n\r\n\tfunction burnFrom(address from, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/base/Diamond/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport \"./LibDiamondStorage.sol\";\nimport { IDiamondCut } from \"../../interfaces/IDiamondCut.sol\";\n\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\tfunction setDiamondAddress(address _diamondAddress) internal {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(ds.diamondAddress == address(0), \"Already initialized!\");\n\t\tds.diamondAddress = _diamondAddress;\n\t}\n\n\tfunction getDiamondAddress() internal view returns (address) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\treturn ds.diamondAddress;\n\t}\n\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tLibAccessControl._setOwner(_newOwner);\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\tLibAccessControl._enforceIsOwner();\n\t}\n\n\t// Internal function version of diamondCut\n\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n\t\t\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n\t\t\tif (action == IDiamondCut.FacetCutAction.Add) {\n\t\t\t\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\t\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\t\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else {\n\t\t\t\trevert(\"LibDiamondCut: Incorrect FacetCutAction\");\n\t\t\t}\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\taddFacet(ds, _facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\t\t\taddFunction(ds, selector, selectorPosition, _facetAddress);\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\taddFacet(ds, _facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n\t\t\tremoveFunction(ds, oldFacetAddress, selector);\n\t\t\taddFunction(ds, selector, selectorPosition, _facetAddress);\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\t// if function does not exist then do nothing and return\n\t\trequire(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\tremoveFunction(ds, oldFacetAddress, selector);\n\t\t}\n\t}\n\n\tfunction addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n\t\tds.facetAddresses.push(_facetAddress);\n\t}\n\n\tfunction addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n\t\tds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n\t\tds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n\t}\n\n\tfunction removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\t\t// an immutable function is a function defined directly in a diamond\n\t\trequire(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n\t\t// replace selector with last selector, then delete last selector\n\t\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n\t\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\t\t// if not the same then replace _selector with lastSelector\n\t\tif (selectorPosition != lastSelectorPosition) {\n\t\t\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n\t\t\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n\t\t}\n\t\t// delete the last selector\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n\t\tdelete ds.selectorToFacetAndPosition[_selector];\n\n\t\t// if no more selectors for facet address then delete the facet address\n\t\tif (lastSelectorPosition == 0) {\n\t\t\t// replace facet address with last facet address and delete last facet address\n\t\t\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n\t\t\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t\tif (facetAddressPosition != lastFacetAddressPosition) {\n\t\t\t\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n\t\t\t\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n\t\t\t\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n\t\t\t}\n\t\t\tds.facetAddresses.pop();\n\t\t\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t}\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\treturn;\n\t\t}\n\t\tenforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\tif (!success) {\n\t\t\tif (error.length > 0) {\n\t\t\t\t// bubble up error\n\t\t\t\t/// @solidity memory-safe-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(error)\n\t\t\t\t\trevert(add(32, error), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert InitializationFunctionReverted(_init, _calldata);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/base/Diamond/LibDiamondEtherscan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nstruct DiamondEtherscanStorage {\n\taddress proxyAddress;\n}\n\nlibrary LibDiamondEtherscan {\n\tevent Upgraded(address indexed implementation);\n\n\t/**\n\t * @dev Storage slot with the address of the current dummy-implementation.\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n\t */\n\tbytes32 internal constant STORAGE_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n\tfunction layout() internal pure returns (DiamondEtherscanStorage storage layout_) {\n\t\tbytes32 position = STORAGE_SLOT;\n\t\tassembly {\n\t\t\tlayout_.slot := position\n\t\t}\n\t}\n\n\tfunction _setDummyImplementation(address implementationAddress) internal {\n\t\tDiamondEtherscanStorage storage des = layout();\n\t\tdes.proxyAddress = implementationAddress;\n\t\temit Upgraded(implementationAddress);\n\t}\n\n\tfunction _dummyImplementation() internal view returns (address) {\n\t\tDiamondEtherscanStorage storage des = layout();\n\t\treturn des.proxyAddress;\n\t}\n}\n"
    },
    "contracts/base/Diamond/LibDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct FacetAddressAndPosition {\r\n\taddress facetAddress;\r\n\tuint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n}\r\n\r\nstruct FacetFunctionSelectors {\r\n\tbytes4[] functionSelectors;\r\n\tuint256 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n}\r\n\r\nstruct DiamondStorage {\r\n\taddress diamondAddress;\r\n\t// maps function selector to the facet address and\r\n\t// the position of the selector in the facetFunctionSelectors.selectors array\r\n\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n\t// maps facet addresses to function selectors\r\n\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n\t// facet addresses\r\n\taddress[] facetAddresses;\r\n\t// Used to query if a contract implements an interface.\r\n\t// Used to implement ERC-165.\r\n\tmapping(bytes4 => bool) supportedInterfaces;\r\n\t//the whole diamond is paused or not\r\n\tbool paused;\r\n}\r\n\r\nlibrary LibDiamondStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.contracts.diamond.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (DiamondStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/EIP712/LibEIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibEIP712Storage.sol\";\r\n\r\nimport { ECDSA } from \"../../utils/ECDSA.sol\";\r\n\r\nlibrary LibEIP712 {\r\n\tbytes32 constant EIP712DOMAIN_TYPEHASH =\r\n\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\r\n\tfunction buildCustomDomainSeapratorV4(\r\n\t\tstring memory name,\r\n\t\tstring memory version,\r\n\t\tuint256 chainid,\r\n\t\taddress verifyingContract\r\n\t) internal pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encode(EIP712DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), chainid, verifyingContract));\r\n\t}\r\n\r\n\tfunction buildDomainSeparatorV4(string memory name, string memory version, uint256 chainid, address verifyingContract) internal {\r\n\t\tEIP712Storage storage eip712s = LibEIP712Storage.layout();\r\n\t\teip712s.domainSeparator = keccak256(\r\n\t\t\tabi.encode(EIP712DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), chainid, verifyingContract)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction domainSeparatorV4() internal view returns (bytes32) {\r\n\t\tEIP712Storage storage eip712s = LibEIP712Storage.layout();\r\n\r\n\t\trequire(eip712s.domainSeparator != 0, \"DomainSeparator not initialized!\");\r\n\r\n\t\treturn eip712s.domainSeparator;\r\n\t}\r\n\r\n\tfunction isDomainSeparatorV4() internal view returns (bool) {\r\n\t\tEIP712Storage storage eip712s = LibEIP712Storage.layout();\r\n\t\treturn eip712s.domainSeparator != 0;\r\n\t}\r\n\r\n\tfunction hashTypedDataV4(bytes32 domainSeparator, bytes32 messageHash) internal pure returns (bytes32) {\r\n\t\treturn ECDSA.toTypedDataHash(domainSeparator, messageHash);\r\n\t}\r\n\r\n\tfunction hashTypedDataV4(bytes32 messageHash) internal view returns (bytes32) {\r\n\t\treturn ECDSA.toTypedDataHash(domainSeparatorV4(), messageHash);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/EIP712/LibEIP712Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nusing EnumerableSet for EnumerableSet.AddressSet;\r\nusing EnumerableSet for EnumerableSet.UintSet;\r\n\r\nstruct EIP712Storage {\r\n\tstring name;\r\n\tstring version;\r\n\tuint256 chainId;\r\n\taddress verifyingContract;\r\n\tbytes32 domainSeparator;\r\n}\r\n\r\nlibrary LibEIP712Storage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.eip712.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (EIP712Storage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC1155/base/LibERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibERC1155Storage.sol\";\r\n\r\nimport \"../customization/LibERC1155Customization.sol\";\r\n\r\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\r\nimport { EnumerableSet } from \"../../../utils/EnumerableSet.sol\";\r\nimport { IERC1155Receiver } from \"../IERC1155Receiver.sol\";\r\n\r\nerror LibERC1155__BalanceQueryZeroAddress(); //Ok\r\nerror LibERC1155__ArrayLengthMismatch(); //Ok\r\nerror LibERC1155__MintToZeroAddress(); //ok\r\nerror LibERC1155__BurnExceedsBalance(); ///Ok\r\nerror LibERC1155__BurnFromZeroAddress(); //Ok\r\nerror LibERC1155__ERC1155ReceiverRejected(); // OK\r\nerror LibERC1155__ERC1155ReceiverNotImplemented(); //ok\r\nerror LibERC1155__TransferExceedsBalance(); //Ok\r\nerror LibERC1155__TransferToZeroAddress(); //Ok\r\nerror LibERC1155__NotOwnerOrApproved(); //Ok\r\nerror LibERC1155__NotOwnerOrApprovedLimit(); //Ok\r\nerror LibERC1155__SelfApproval(); //OK\r\n\r\nlibrary LibERC1155 {\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * EVENTS from IERC1155\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tevent TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n\tevent TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n\tevent ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n\tevent URI(string value, uint256 indexed tokenId);\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * EVENTS from IERC1155Allowance\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tevent Approval(address indexed owner, address indexed operator, uint256 indexed id, uint256 currenctValue, uint256 newValue);\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * EVENTS from IERC1155Paused\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tevent AllTokenPaused(address indexed account);\r\n\r\n\tevent AllTokenUnpaused(address indexed account);\r\n\r\n\tevent TokenPaused(address indexed account, uint256 indexed tokenId);\r\n\r\n\tevent TokenUnpaused(address indexed account, uint256 indexed tokenId);\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * Usings\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tusing AddressUtils for address;\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\tusing EnumerableSet for EnumerableSet.UintSet;\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155\r\n\t *\r\n\t ************************************************************************************************************/\r\n\r\n\t/**\r\n\t * @notice query the balance of given token held by given address\r\n\t * @param _account address to query\r\n\t * @param _tokenId token to query\r\n\t * @return token balance\r\n\t */\r\n\tfunction balanceOf(address _account, uint256 _tokenId) internal view returns (uint256) {\r\n\t\tif (_account == address(0)) revert LibERC1155__BalanceQueryZeroAddress();\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.balances[_tokenId][_account];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query the balance of given token held by the given addresses\r\n\t * @param _accounts addresses to query\r\n\t * @param _tokenIds list of token IDs to query\r\n\t * @return tokens' balance\r\n\t */\r\n\tfunction balanceOfBatch(address[] memory _accounts, uint256[] memory _tokenIds) internal view returns (uint256[] memory) {\r\n\t\trequire(_accounts.length == _tokenIds.length, \"ERC1155: accounts and ids length mismatch\");\r\n\t\tif (_tokenIds.length != _accounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\tuint256[] memory batchBalances = new uint256[](_accounts.length);\r\n\r\n\t\tfor (uint256 i = 0; i < _accounts.length; ++i) {\r\n\t\t\tbatchBalances[i] = balanceOf(_accounts[i], _tokenIds[i]);\r\n\t\t}\r\n\r\n\t\treturn batchBalances;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice mint given quantity of tokens for given address\r\n\t * @param _operator caller, msg.sender or msgSender()\r\n\t * @param _toAccount beneficiary of minting\r\n\t * @param _tokenId token ID\r\n\t * @param _amount quantity of tokens to mint\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction mint(address _operator, address _toAccount, uint256 _tokenId, uint256 _amount, bytes memory _data) internal {\r\n\t\tif (_toAccount == address(0)) revert LibERC1155__MintToZeroAddress();\r\n\r\n\t\tuint256[] memory tokenIds = _asSingletonArray(_tokenId);\r\n\t\tuint256[] memory amounts = _asSingletonArray(_amount);\r\n\r\n\t\t_beforeTokenTransfer(_operator, address(0), _toAccount, tokenIds, amounts, _data);\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\t_whenTokenNotPaused(e1155s, _tokenId);\r\n\r\n\t\te1155s.balances[_tokenId][_toAccount] += _amount;\r\n\t\temit TransferSingle(_operator, address(0), _toAccount, _tokenId, _amount);\r\n\r\n\t\t_afterTokenTransfer(_operator, address(0), _toAccount, tokenIds, amounts, _data);\r\n\r\n\t\t_doSafeTransferAcceptanceCheck(_operator, address(0), _toAccount, _tokenId, _amount, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice mint batch of tokens for given address\r\n\t * @param _operator caller, msg.sender or msgSender()\r\n\t * @param _toAccount beneficiary of minting\r\n\t * @param _tokenIds list of token IDs\r\n\t * @param _amounts list of quantities of tokens to mint\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction mintBatch(\r\n\t\taddress _operator,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tif (_toAccount == address(0)) revert LibERC1155__MintToZeroAddress();\r\n\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\t_beforeTokenTransfer(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\r\n\t\tfor (uint256 i = 0; i < _tokenIds.length; ) {\r\n\t\t\tuint256 tokenId = _tokenIds[i];\r\n\t\t\t_whenTokenNotPaused(e1155s, tokenId);\r\n\t\t\te1155s.balances[tokenId][_toAccount] += _amounts[i];\r\n\t\t\tunchecked {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\temit TransferBatch(_operator, address(0), _toAccount, _tokenIds, _amounts);\r\n\r\n\t\t_afterTokenTransfer(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\r\n\r\n\t\t_doSafeBatchTransferAcceptanceCheck(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice burn given quantity of tokens held by given address\r\n\t * @param _operator caller, msg.sender or msgSender()\r\n\t * @param _fromAccount holder of tokens to burn\r\n\t * @param _tokenId token ID\r\n\t * @param _amount quantity of tokens to burn\r\n\t */\r\n\tfunction burn(address _operator, address _fromAccount, uint256 _tokenId, uint256 _amount) internal {\r\n\t\tif (_fromAccount == address(0)) revert LibERC1155__BurnFromZeroAddress();\r\n\r\n\t\t_beforeTokenTransfer(_operator, _fromAccount, address(0), _asSingletonArray(_tokenId), _asSingletonArray(_amount), \"\");\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\t_whenTokenNotPaused(e1155s, _tokenId);\r\n\r\n\t\tif (_amount > e1155s.balances[_tokenId][_fromAccount]) revert LibERC1155__BurnExceedsBalance();\r\n\r\n\t\tunchecked {\r\n\t\t\te1155s.balances[_tokenId][_fromAccount] -= _amount;\r\n\t\t}\r\n\r\n\t\temit TransferSingle(_operator, _fromAccount, address(0), _tokenId, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice burn given batch of tokens held by given address\r\n\t * @param _operator caller, msg.sender or msgSender()\r\n\t * @param _fromAccount holder of tokens to burn\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to burn\r\n\t */\r\n\tfunction burnBatch(address _operator, address _fromAccount, uint256[] memory _tokenIds, uint256[] memory _amounts) internal {\r\n\t\tif (_fromAccount == address(0)) revert LibERC1155__BurnFromZeroAddress();\r\n\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\t_beforeTokenTransfer(_operator, _fromAccount, address(0), _tokenIds, _amounts, \"\");\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\r\n\t\tunchecked {\r\n\t\t\tfor (uint256 i; i < _tokenIds.length; i++) {\r\n\t\t\t\tuint256 tokenId = _tokenIds[i];\r\n\t\t\t\t_whenTokenNotPaused(e1155s, tokenId);\r\n\t\t\t\tif (_amounts[i] > e1155s.balances[tokenId][_fromAccount]) revert LibERC1155__BurnExceedsBalance();\r\n\t\t\t\te1155s.balances[tokenId][_fromAccount] -= _amounts[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\temit TransferBatch(_operator, _fromAccount, address(0), _tokenIds, _amounts);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice transfer tokens between given addresses\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenId token ID\r\n\t * @param _amount quantity of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction safeTransfer(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256 _tokenId,\r\n\t\tuint256 _amount,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tif (_toAccount == address(0)) revert LibERC1155__TransferToZeroAddress();\r\n\r\n\t\tuint256[] memory tokenIds = _asSingletonArray(_tokenId);\r\n\t\tuint256[] memory amounts = _asSingletonArray(_amount);\r\n\r\n\t\t_beforeTokenTransfer(_operator, _fromAccount, _toAccount, tokenIds, amounts, _data);\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\t_whenTokenNotPaused(e1155s, _tokenId);\r\n\r\n\t\tuint256 senderBalance = e1155s.balances[_tokenId][_fromAccount];\r\n\r\n\t\tif (_amount > senderBalance) revert LibERC1155__TransferExceedsBalance();\r\n\t\tcheckAllowance(_operator, _fromAccount, _tokenId, _amount);\r\n\r\n\t\tunchecked {\r\n\t\t\te1155s.balances[_tokenId][_fromAccount] = senderBalance - _amount;\r\n\t\t\tif (_operator != _fromAccount) {\r\n\t\t\t\tif (e1155s.operatorSpendingLimitEnabled[_tokenId]) {\r\n\t\t\t\t\te1155s.allowances[_fromAccount][_operator][_tokenId] = e1155s.allowances[_fromAccount][_operator][_tokenId] - _amount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\te1155s.balances[_tokenId][_toAccount] += _amount;\r\n\r\n\t\temit TransferSingle(_operator, _fromAccount, _toAccount, _tokenId, _amount);\r\n\r\n\t\t_afterTokenTransfer(_operator, _fromAccount, _toAccount, tokenIds, amounts, _data);\r\n\r\n\t\t_doSafeTransferAcceptanceCheck(_operator, _fromAccount, _toAccount, _tokenId, _amount, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice transfer batch of tokens between given addresses\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction safeTransferBatch(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tif (_toAccount == address(0)) revert LibERC1155__TransferToZeroAddress();\r\n\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\t_beforeTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\r\n\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\r\n\t\tcheckAllowanceBach(_operator, _fromAccount, _tokenIds, _amounts);\r\n\r\n\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\tuint256 tokenId = _tokenIds[i];\r\n\t\t\tuint256 amount = _amounts[i];\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\t_whenTokenNotPaused(e1155s, tokenId);\r\n\r\n\t\t\t\tuint256 senderBalance = e1155s.balances[tokenId][_fromAccount];\r\n\r\n\t\t\t\tif (amount > senderBalance) revert LibERC1155__TransferExceedsBalance();\r\n\r\n\t\t\t\te1155s.balances[tokenId][_fromAccount] = senderBalance - amount;\r\n\r\n\t\t\t\tif (_operator != _fromAccount) {\r\n\t\t\t\t\tif (e1155s.operatorSpendingLimitEnabled[tokenId]) {\r\n\t\t\t\t\t\te1155s.allowances[_fromAccount][_operator][tokenId] = e1155s.allowances[_fromAccount][_operator][tokenId] - amount;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\r\n\t\t\t// balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\r\n\t\t\te1155s.balances[tokenId][_toAccount] += amount;\r\n\t\t}\r\n\r\n\t\temit TransferBatch(_operator, _fromAccount, _toAccount, _tokenIds, _amounts);\r\n\r\n\t\t_afterTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\r\n\r\n\t\t_doSafeBatchTransferAcceptanceCheck(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n\t * @dev MUST emit the ApprovalForAll event on success.\r\n\t * @param _account The owner of the tokens\r\n\t * @param _operator Address to add to the set of authorized operators\r\n\t * @param _approved True if the operator is approved, false to revoke approval\r\n\t */\r\n\tfunction setApprovalForAll(address _account, address _operator, bool _approved) internal {\r\n\t\tif (_account == _operator) revert LibERC1155__SelfApproval();\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\te1155s.operatorApprovals[_account][_operator] = _approved;\r\n\t\temit ApprovalForAll(_account, _operator, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Queries the approval status of an operator for a given owner.\r\n\t * @param _account The owner of the tokens\r\n\t * @param _operator Address of authorized operator\r\n\t * @return True if the operator is approved, false if not\r\n\t */\r\n\tfunction isApprovedForAll(address _account, address _operator) internal view returns (bool) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.operatorApprovals[_account][_operator];\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155Receiver\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tbytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n\tbytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n\r\n\tfunction onERC1155Received(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256 _id,\r\n\t\tuint256 _value,\r\n\t\tbytes calldata _data\r\n\t) internal returns (bytes4) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tERC1155ReceiverStorage storage receivedData = e1155s.receivedTokens[e1155s.receivedTokensLength];\r\n\t\treceivedData.operator = _operator;\r\n\t\treceivedData.from = _from;\r\n\t\treceivedData.ids = _asSingletonArray(_id);\r\n\t\treceivedData.values = _asSingletonArray(_value);\r\n\t\treceivedData.data = _data;\r\n\t\te1155s.receivedTokensLength++;\r\n\r\n\t\t// if (shouldReject == true) {\r\n\t\t// \trevert(\"onERC1155Received: transfer not accepted\");\r\n\t\t// } else {\r\n\t\t// \treturn ERC1155_ACCEPTED;\r\n\t\t// }\r\n\t\treturn ERC1155_ACCEPTED;\r\n\t}\r\n\r\n\tfunction onERC1155BatchReceived(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256[] calldata _ids,\r\n\t\tuint256[] calldata _values,\r\n\t\tbytes calldata _data\r\n\t) internal returns (bytes4) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tERC1155ReceiverStorage storage receivedData = e1155s.receivedTokens[e1155s.receivedTokensLength];\r\n\t\treceivedData.operator = _operator;\r\n\t\treceivedData.from = _from;\r\n\t\treceivedData.ids = _ids;\r\n\t\treceivedData.values = _values;\r\n\t\treceivedData.data = _data;\r\n\t\te1155s.receivedTokensLength++;\r\n\t\treturn ERC1155_BATCH_ACCEPTED;\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155Allowance\r\n\t *\r\n\t ************************************************************************************************************/\r\n\r\n\tfunction isOperatorSpendingLimitEnabled(uint256 _tokenId) internal view returns (bool) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.operatorSpendingLimitEnabled[_tokenId];\r\n\t}\r\n\r\n\tfunction setOperatorSpendingLimitEnabled(uint256 _tokenId, bool _enabled) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\te1155s.operatorSpendingLimitEnabled[_tokenId] = _enabled;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Allow other accounts/contracts to spend tokens on behalf of msg.sender\r\n\t * @dev MUST emit Approval event on success.\r\n\t * To minimize the risk of the approve/transferFrom attack vector (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), this function will throw if the current approved allowance does not equal the expected _currentValue, unless _value is 0.\r\n\t * @param _owner Address of token owner\r\n\t * @param _operator Address to approve, _operator will ba able to send token\r\n\t * @param _tokenId ID of the Token\r\n\t * @param _currentValue Expected current value of approved allowance.\r\n\t * @param _newValue Allowance amount\r\n\t */\r\n\tfunction approve(address _owner, address _operator, uint256 _tokenId, uint256 _currentValue, uint256 _newValue) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\trequire(e1155s.allowances[_owner][_operator][_tokenId] == _currentValue, \"Current value mismatch\");\r\n\t\te1155s.allowances[_owner][_operator][_tokenId] = _newValue;\r\n\r\n\t\temit Approval(_owner, _operator, _tokenId, _currentValue, _newValue);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Queries the spending limit approved for an account\r\n\t * @param _owner The owner allowing the spending\r\n\t * @param _operator The address allowed to spend.\r\n\t * @param _tokenId ID of the Token\r\n\t * @return The _operator's allowed spending balance of the Token requested\r\n\t */\r\n\tfunction allowance(address _owner, address _operator, uint256 _tokenId) internal view returns (uint256) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.allowances[_owner][_operator][_tokenId];\r\n\t}\r\n\r\n\tfunction checkAllowance(address _operator, address _fromAccount, uint256 _tokenId, uint256 _value) internal view {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tif (_fromAccount != _operator) {\r\n\t\t\tif (!e1155s.operatorApprovals[_fromAccount][_operator]) {\r\n\t\t\t\trevert LibERC1155__NotOwnerOrApproved();\r\n\t\t\t}\r\n\t\t\tif (e1155s.operatorSpendingLimitEnabled[_tokenId] && e1155s.allowances[_fromAccount][_operator][_tokenId] < _value) {\r\n\t\t\t\trevert LibERC1155__NotOwnerOrApprovedLimit();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction checkAllowanceBach(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts\r\n\t) internal view {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tif (_fromAccount != _operator) {\r\n\t\t\tif (!e1155s.operatorApprovals[_fromAccount][_operator]) {\r\n\t\t\t\trevert LibERC1155__NotOwnerOrApproved();\r\n\t\t\t}\r\n\r\n\t\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\tuint256 tokenId = _tokenIds[i];\r\n\t\t\t\t\tuint256 amount = _amounts[i];\r\n\t\t\t\t\tif (e1155s.operatorSpendingLimitEnabled[tokenId] && e1155s.allowances[_fromAccount][_operator][tokenId] < amount) {\r\n\t\t\t\t\t\trevert LibERC1155__NotOwnerOrApprovedLimit();\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155Metadata\r\n\t *\r\n\t ************************************************************************************************************/\r\n\r\n\t/**\r\n\t * @notice Query global metadata URI, can contain {id}, client will replace with a valid token id\r\n\t */\r\n\tfunction getUri() internal view returns (string memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.uri;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice set global metadata URI, can contain {id}, client will\r\n\t * @param _URI global URI\r\n\t */\r\n\tfunction setURI(string memory _URI) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\te1155s.uri = _URI;\r\n\t}\r\n\r\n\tfunction getTokenBaseUri() internal view returns (string memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.baseURI;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice set base metadata URI\r\n\t * @dev base URI is a non-standard feature adapted from the ERC721 specification\r\n\t * @param _baseURI base URI\r\n\t */\r\n\tfunction setTokenBaseURI(string memory _baseURI) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\te1155s.baseURI = _baseURI;\r\n\t}\r\n\r\n\tfunction getTokenUri(uint256 _tokenId) internal view returns (string memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.tokenURIs[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice set pre-token metadata URI\r\n\t * @param _tokenId token whose metadata URI to set\r\n\t * @param _tokenURI per-token URI\r\n\t */\r\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\te1155s.tokenURIs[_tokenId] = _tokenURI;\r\n\t\temit URI(_tokenURI, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * This implementation returns the concatenation of the `_baseURI`\r\n\t * and the token-specific uri if the latter is set\r\n\t *\r\n\t * This enables the following behaviors:\r\n\t *\r\n\t * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation\r\n\t *   of `_baseURI` and `_tokenURIs[tokenId]`\r\n\t *\r\n\t * - if `_tokenURIs[tokenId]` is NOT set then we fallback to the defaut URI\r\n\t *   which contains `ERC1155.uri`;\r\n\t */\r\n\tfunction getUri(uint256 tokenId) internal view returns (string memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tstring memory tokenURI = e1155s.tokenURIs[tokenId];\r\n\r\n\t\t// If token URI is set, concatenate base URI and tokenURI (via abi.encodePacked).\r\n\t\treturn bytes(tokenURI).length > 0 ? string(abi.encodePacked(e1155s.baseURI, tokenURI)) : e1155s.uri;\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155Enumerable\r\n\t *\r\n\t ************************************************************************************************************/\r\n\r\n\t/**\r\n\t * @notice query total minted supply of given token\r\n\t * @param _tokenId token id to query\r\n\t * @return token supply\r\n\t */\r\n\tfunction totalSupply(uint256 _tokenId) internal view returns (uint256) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.totalSupply[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query total number of holders for given token\r\n\t * @param id token id to query\r\n\t * @return quantity of holders\r\n\t */\r\n\tfunction totalHolders(uint256 id) internal view returns (uint256) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\treturn e1155s.accountsByToken[id].length();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query holders of given token\r\n\t * @param _tokenId token id to query\r\n\t * @return list of holder addresses\r\n\t */\r\n\tfunction accountsByToken(uint256 _tokenId) internal view returns (address[] memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tEnumerableSet.AddressSet storage accounts = e1155s.accountsByToken[_tokenId];\r\n\r\n\t\taddress[] memory addresses = new address[](accounts.length());\r\n\r\n\t\tunchecked {\r\n\t\t\tfor (uint256 i; i < accounts.length(); i++) {\r\n\t\t\t\taddresses[i] = accounts.at(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn addresses;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query tokens held by given address\r\n\t * @param _account address to query\r\n\t * @return list of token ids\r\n\t */\r\n\tfunction tokensByAccount(address _account) internal view returns (uint256[] memory) {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\tEnumerableSet.UintSet storage tokens = e1155s.tokensByAccount[_account];\r\n\r\n\t\tuint256[] memory ids = new uint256[](tokens.length());\r\n\r\n\t\tunchecked {\r\n\t\t\tfor (uint256 i; i < tokens.length(); i++) {\r\n\t\t\t\tids[i] = tokens.at(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ids;\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * IERC1155Pausable\r\n\t *\r\n\t ************************************************************************************************************/\r\n\tfunction _whenNotPaused(ERC1155Storage storage e1155s) internal view {\r\n\t\trequire(!e1155s.paused, \"All token is paused!\");\r\n\t}\r\n\r\n\tfunction _whenTokenNotPaused(ERC1155Storage storage e1155s, uint256 _tokenId) internal view {\r\n\t\t_whenNotPaused(e1155s);\r\n\t\trequire(!e1155s.pausedToken[_tokenId], \"Token is paused!\");\r\n\t}\r\n\r\n\tfunction whenNotPaused() internal view {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\t_whenNotPaused(e1155s);\r\n\t}\r\n\r\n\tfunction whenTokenNotPaused(uint256 _tokenId) internal view {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\t_whenTokenNotPaused(e1155s, _tokenId);\r\n\t}\r\n\r\n\tfunction pauseAllToken(address _operator) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\trequire(!e1155s.paused, \"All tokens are already paused\");\r\n\t\te1155s.paused = true;\r\n\t\temit AllTokenPaused(_operator);\r\n\t}\r\n\r\n\tfunction unpauseAllToken(address _operator) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\trequire(e1155s.paused, \"All tokens are not paused yet\");\r\n\t\te1155s.paused = false;\r\n\t\temit AllTokenUnpaused(_operator);\r\n\t}\r\n\r\n\tfunction pauseToken(address _operator, uint256 _tokenId) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\trequire(!e1155s.pausedToken[_tokenId], \"Token is already paused\");\r\n\t\te1155s.pausedToken[_tokenId] = true;\r\n\t\temit TokenPaused(_operator, _tokenId);\r\n\t}\r\n\r\n\tfunction unpauseToken(address _operator, uint256 _tokenId) internal {\r\n\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\t\trequire(e1155s.pausedToken[_tokenId], \"Token is not paused yet\");\r\n\t\te1155s.pausedToken[_tokenId] = false;\r\n\t\temit TokenUnpaused(_operator, _tokenId);\r\n\t}\r\n\r\n\t/************************************************************************************************************\r\n\t *\r\n\t * Library internal helper functions\r\n\t *\r\n\t ************************************************************************************************************/\r\n\r\n\t/**\r\n\t * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenId token ID\r\n\t * @param _amount quantity of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction _doSafeTransferAcceptanceCheck(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256 _tokenId,\r\n\t\tuint256 _amount,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tif (_toAccount.isContract()) {\r\n\t\t\ttry IERC1155Receiver(_toAccount).onERC1155Received(_operator, _fromAccount, _tokenId, _amount, _data) returns (\r\n\t\t\t\tbytes4 response\r\n\t\t\t) {\r\n\t\t\t\tif (response != IERC1155Receiver.onERC1155Received.selector) revert LibERC1155__ERC1155ReceiverRejected();\r\n\t\t\t} catch Error(string memory reason) {\r\n\t\t\t\trevert(reason);\r\n\t\t\t} catch {\r\n\t\t\t\trevert LibERC1155__ERC1155ReceiverNotImplemented();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction _doSafeBatchTransferAcceptanceCheck(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory _data\r\n\t) private {\r\n\t\tif (_toAccount.isContract()) {\r\n\t\t\ttry IERC1155Receiver(_toAccount).onERC1155BatchReceived(_operator, _fromAccount, _tokenIds, _amounts, _data) returns (\r\n\t\t\t\tbytes4 response\r\n\t\t\t) {\r\n\t\t\t\tif (response != IERC1155Receiver.onERC1155BatchReceived.selector) revert LibERC1155__ERC1155ReceiverRejected();\r\n\t\t\t} catch Error(string memory reason) {\r\n\t\t\t\trevert(reason);\r\n\t\t\t} catch {\r\n\t\t\t\trevert LibERC1155__ERC1155ReceiverNotImplemented();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\r\n\t\tuint256[] memory array = new uint256[](1);\r\n\t\tarray[0] = element;\r\n\t\treturn array;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice ERC1155 hook, called before all transfers including mint and burn\r\n\t * The same hook is called on both single and batched variants. For single\r\n\t * transfers, the length of the `ids` and `amounts` arrays will be 1.\r\n\t * Calling conditions (for each `id` and `amount` pair):\r\n\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\r\n\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t * - `ids` and `amounts` have the same, non-zero length.\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tif (_fromAccount != _toAccount) {\r\n\t\t\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\r\n\r\n\t\t\tmapping(uint256 => EnumerableSet.AddressSet) storage tokenAccounts = e1155s.accountsByToken;\r\n\r\n\t\t\tEnumerableSet.UintSet storage fromAccountTokens = e1155s.tokensByAccount[_fromAccount];\r\n\t\t\tEnumerableSet.UintSet storage toAccountTokens = e1155s.tokensByAccount[_toAccount];\r\n\r\n\t\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\t\tuint256 amount = _amounts[i];\r\n\r\n\t\t\t\tif (amount > 0) {\r\n\t\t\t\t\tuint256 id = _tokenIds[i];\r\n\r\n\t\t\t\t\tif (_fromAccount == address(0)) {\r\n\t\t\t\t\t\te1155s.totalSupply[id] += amount;\r\n\t\t\t\t\t} else if (balanceOf(_fromAccount, id) == amount) {\r\n\t\t\t\t\t\ttokenAccounts[id].remove(_fromAccount);\r\n\t\t\t\t\t\tfromAccountTokens.remove(id);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (_toAccount == address(0)) {\r\n\t\t\t\t\t\te1155s.totalSupply[id] -= amount;\r\n\t\t\t\t\t} else if (balanceOf(_toAccount, id) == 0) {\r\n\t\t\t\t\t\ttokenAccounts[id].add(_toAccount);\r\n\t\t\t\t\t\ttoAccountTokens.add(id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tLibERC1155Customization._beforeTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice ERC1155 hook, called after all transfers including mint and burn\r\n\t * The same hook is called on both single and batched variants. For single\r\n\t * transfers, the length of the `id` and `amount` arrays will be 1.\r\n\t * Calling conditions (for each `id` and `amount` pair):\r\n\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\r\n\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t * - `ids` and `amounts` have the same, non-zero length.\r\n\t * @param _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t * @param _data data payload\r\n\t */\r\n\tfunction _afterTokenTransfer(\r\n\t\taddress _operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\tLibERC1155Customization._afterTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC1155/base/LibERC1155Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../../utils/EnumerableSet.sol\";\r\n\r\nstruct ERC1155ReceiverStorage {\r\n\tbytes data;\r\n\taddress operator;\r\n\taddress from;\r\n\tuint256[] ids;\r\n\tuint256[] values;\r\n}\r\n\r\nstruct ERC1155Storage {\r\n\tmapping(uint256 => mapping(address => uint256)) balances; // Mapping from token ID to account balances\r\n\tmapping(address => mapping(address => bool)) operatorApprovals; // Mapping from account to operator approvals\r\n\tmapping(uint256 => bool) operatorSpendingLimitEnabled;\r\n\tmapping(address => mapping(address => mapping(uint256 => uint256))) allowances;\r\n\tmapping(uint256 => uint256) totalSupply;\r\n\tmapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\r\n\tmapping(address => EnumerableSet.UintSet) tokensByAccount;\r\n\tstring uri; // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n\tstring baseURI; // Optional base URI, e.g. ipfs://53453534\r\n\tmapping(uint256 => string) tokenURIs; // Optional mapping for token URIs, e.g. 4236464216781, so tokenURI will be: ipfs://53453534/4236464216781\r\n\tbool paused;\r\n\tmapping(uint256 => bool) pausedToken;\r\n\tuint256 receivedTokensLength;\r\n\tmapping(uint256 => ERC1155ReceiverStorage) receivedTokens;\r\n}\r\n\r\nlibrary LibERC1155Storage {\r\n\tbytes32 internal constant ERC1155_STORAGE_SLOT = keccak256(\"usmart.contracts.erc1155-base.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (ERC1155Storage storage e1155s_) {\r\n\t\tbytes32 position = ERC1155_STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\te1155s_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC1155/customization/LibERC1155Customization.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"../../TokenRestriction/LibTokenRestriction.sol\";\r\nimport \"../../TokenPNL/LibTokenPNL.sol\";\r\n\r\nimport \"../../../ArexaPlatform/Platform/LibArexaPlatform.sol\";\r\n\r\nlibrary LibERC1155Customization {\r\n\t/**\r\n\t * @notice ERC1155 hook, called before all transfers including mint and burn\r\n\t * The same hook is called on both single and batched variants. For single\r\n\t * transfers, the length of the `ids` and `amounts` arrays will be 1.\r\n\t * Calling conditions (for each `id` and `amount` pair):\r\n\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\r\n\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t * - `ids` and `amounts` have the same, non-zero length.\r\n\t *  param_operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t *  param_toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t *  param _data data payload\r\n\t */\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress, //_operator,\r\n\t\taddress _fromAccount,\r\n\t\taddress, //_toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory //_data\r\n\t) internal view {\r\n\t\tif (_fromAccount != address(0)) {\r\n\t\t\tLibTokenRestriction.checkRestrictions(_fromAccount, _tokenIds, _amounts);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice ERC1155 hook, called after all transfers including mint and burn\r\n\t * The same hook is called on both single and batched variants. For single\r\n\t * transfers, the length of the `id` and `amount` arrays will be 1.\r\n\t * Calling conditions (for each `id` and `amount` pair):\r\n\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\r\n\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t * - `ids` and `amounts` have the same, non-zero length.\r\n\t * _operator executor of transfer\r\n\t * @param _fromAccount sender of tokens\r\n\t * @param _toAccount receiver of tokens\r\n\t * @param _tokenIds token IDs\r\n\t * @param _amounts quantities of tokens to transfer\r\n\t * _data data payload\r\n\t */\r\n\tfunction _afterTokenTransfer(\r\n\t\taddress, //_operator\r\n\t\taddress _fromAccount,\r\n\t\taddress _toAccount,\r\n\t\tuint256[] memory _tokenIds,\r\n\t\tuint256[] memory _amounts,\r\n\t\tbytes memory //_data\r\n\t) internal {\r\n\t\tif (_fromAccount != address(0)) {\r\n\t\t\tLibTokenRestriction.recalcRestrictions(_fromAccount, _tokenIds, _amounts, 0);\r\n\t\t}\r\n\r\n\t\tif (_toAccount != address(0)) {\r\n\t\t\tLibTokenRestriction.recalcRestrictions(_toAccount, _tokenIds, _amounts, 1);\r\n\t\t}\r\n\r\n\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\tLibTokenPNL.refreshDivident(address(LibArexaPlatform.getPayingToken()), _tokenIds[i], _fromAccount, _toAccount, _amounts[i]);\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155.\n */\ninterface IERC1155 {\n\t/**\n\t * @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n\t * The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n\t * The `_from` argument MUST be the address of the holder whose balance is decreased.\n\t * The `_to` argument MUST be the address of the recipient whose balance is increased.\n\t * The `_id` argument MUST be the token type being transferred.\n\t * The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n\t * When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n\t * When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n\t */\n\tevent TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n\t/**\n\t * @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n\t * The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n\t * The `_from` argument MUST be the address of the holder whose balance is decreased.\n\t * The `_to` argument MUST be the address of the recipient whose balance is increased.\n\t * The `_ids` argument MUST be the list of tokens being transferred.\n\t * The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n\t * When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n\t * When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n\t */\n\tevent TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n\t/**\n\t * @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\n\t */\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/**\n\t * @dev MUST emit when the URI is updated for a token ID.\n\t * URIs are defined in RFC 3986.\n\t * The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n\t */\n\tevent URI(string _value, uint256 indexed _id);\n\n\t/**\n\t * @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n\t * @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n\t * MUST revert if `_to` is the zero address.\n\t * MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n\t * MUST revert on any other error.\n\t * MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n\t * After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n\t * @param _from Source address\n\t * @param _to Target address\n\t * @param _id ID of the token type\n\t * @param _value Transfer amount\n\t * @param _data Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n\t/**\n\t * @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n\t * @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n\t * MUST revert if `_to` is the zero address.\n\t * MUST revert if length of `_ids` is not the same as length of `_values`.\n\t * MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n\t * MUST revert on any other error.\n\t * MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n\t * Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n\t * After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n\t * @param _from Source address\n\t * @param _to Target address\n\t * @param _ids IDs of each token type (order and length must match _values array)\n\t * @param _values Transfer amounts per token type (order and length must match _ids array)\n\t * @param _data Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n\t */\n\tfunction safeBatchTransferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256[] calldata _ids,\n\t\tuint256[] calldata _values,\n\t\tbytes calldata _data\n\t) external;\n\n\t/**\n\t * @notice Get the balance of an account's tokens.\n\t * @param _owner The address of the token holder\n\t * @param _id ID of the token\n\t * @return The _owner's balance of the token type requested\n\t */\n\tfunction balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n\t/**\n\t * @notice Get the balance of multiple account/token pairs\n\t * @param _owners The addresses of the token holders\n\t * @param _ids ID of the tokens\n\t * @return The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n\t */\n\tfunction balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n\t * @dev MUST emit the ApprovalForAll event on success.\n\t * @param _operator Address to add to the set of authorized operators\n\t * @param _approved True if the operator is approved, false to revoke approval\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/**\n\t * @notice Queries the approval status of an operator for a given owner.\n\t * @param _owner The owner of the tokens\n\t * @param _operator Address of authorized operator\n\t * @return True if the operator is approved, false if not\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "contracts/base/ERC1155/IERC1155Allowance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC1155Allowance {\r\n\tevent Approval(address indexed owner, address indexed operator, uint256 indexed id, uint256 currenctValue, uint256 newValue);\r\n\r\n\t/**\r\n\t * @notice Allow other accounts/contracts to spend tokens on behalf of msg.sender\r\n\t * @dev MUST emit Approval event on success.\r\n\t * To minimize the risk of the approve/transferFrom attack vector (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), this function will throw if the current approved allowance does not equal the expected _currentValue, unless _value is 0.\r\n\t * @param _operator Address to approve, _operator will ba able to send token\r\n\t * @param _id ID of the Token\r\n\t * @param _currentValue Expected current value of approved allowance.\r\n\t * @param _newValue Allowance amount\r\n\t */\r\n\tfunction approve(address _operator, uint256 _id, uint256 _currentValue, uint256 _newValue) external;\r\n\r\n\t/**\r\n\t * @notice Queries the spending limit approved for an account\r\n\t * @param _owner The owner allowing the spending\r\n\t * @param _operator The address allowed to spend.\r\n\t * @param _id ID of the Token\r\n\t * @return The operator's allowed spending balance of the Token requested\r\n\t */\r\n\tfunction allowance(address _owner, address _operator, uint256 _id) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/base/ERC1155/IERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC1155Enumerable {\r\n\t/**\r\n\t * @notice query total minted supply of given token\r\n\t * @param _id token id to query\r\n\t * @return token supply\r\n\t */\r\n\tfunction totalSupply(uint256 _id) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @notice query total number of holders for given token\r\n\t * @param _id token id to query\r\n\t * @return quantity of holders\r\n\t */\r\n\tfunction totalHolders(uint256 _id) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @notice query holders of given token\r\n\t * @param _id token id to query\r\n\t * @return list of holder addresses\r\n\t */\r\n\tfunction accountsByToken(uint256 _id) external view returns (address[] memory);\r\n\r\n\t/**\r\n\t * @notice query tokens held by given address\r\n\t * @param _account address to query\r\n\t * @return list of token ids\r\n\t */\r\n\tfunction tokensByAccount(address _account) external view returns (uint256[] memory);\r\n}\r\n"
    },
    "contracts/base/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * https://eips.ethereum.org/EIPS/eip-1155.\n */\ninterface IERC1155MetadataURI {\n\t/**\n\t * @dev URIs are defined in RFC 3986.\n\t * The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n\t * @return URI string\n\t */\n\tfunction uri(uint256 _id) external view returns (string memory);\n}\n"
    },
    "contracts/base/ERC1155/IERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC1155Pausable {\r\n\t/**\r\n\t * @notice Emitted when the pause is triggered by account.\r\n\t */\r\n\tevent AllTokenPaused(address indexed account);\r\n\r\n\t/**\r\n\t * @notice Emitted when the pause is lifted by account.\r\n\t */\r\n\tevent AllTokenUnpaused(address indexed account);\r\n\r\n\t/**\r\n\t * @notice Emitted when the pause of token is triggered by account.\r\n\t */\r\n\tevent TokenPaused(address indexed account, uint256 indexed tokenId);\r\n\r\n\t/**\r\n\t * @notice Emitted when the pause of token is lifted by account.\r\n\t */\r\n\tevent TokenUnpaused(address indexed account, uint256 indexed tokenId);\r\n\r\n\tfunction pauseAllToken() external;\r\n\r\n\tfunction unpauseAllToken() external;\r\n\r\n\tfunction pauseToken(uint256 tokenId) external;\r\n\r\n\tfunction unpauseToken(uint256 tokenId) external;\r\n}\r\n"
    },
    "contracts/base/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * https://eips.ethereum.org/EIPS/eip-1155.\n */\ninterface IERC1155Receiver {\n\t/**\n\t * @notice Handle the receipt of a single ERC1155 token type.\n\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n\t * This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n\t * This function MUST revert if it rejects the transfer.\n\t * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n\t * @param _operator The address which initiated the transfer (i.e. msg.sender)\n\t * @param _from The address which previously owned the token\n\t * @param _id The ID of the token being transferred\n\t * @param _value The amount of tokens being transferred\n\t * @param _data Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n\t */\n\tfunction onERC1155Received(\n\t\taddress _operator,\n\t\taddress _from,\n\t\tuint256 _id,\n\t\tuint256 _value,\n\t\tbytes calldata _data\n\t) external returns (bytes4);\n\n\t/**\n\t * @notice Handle the receipt of multiple ERC1155 token types.\n\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n\t * This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n\t * This function MUST revert if it rejects the transfer(s).\n\t * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n\t * @param _operator The address which initiated the batch transfer (i.e. msg.sender)\n\t * @param _from The address which previously owned the token\n\t * @param _ids An array containing ids of each token being transferred (order and length must match _values array)\n\t * @param _values An array containing amounts of each token being transferred (order and length must match _ids array)\n\t * @param _data Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n\t */\n\tfunction onERC1155BatchReceived(\n\t\taddress _operator,\n\t\taddress _from,\n\t\tuint256[] calldata _ids,\n\t\tuint256[] calldata _values,\n\t\tbytes calldata _data\n\t) external returns (bytes4);\n}\n"
    },
    "contracts/base/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { IERC20 } from \"../IERC20.sol\";\nimport { LibERC20Base } from \"./LibERC20Base.sol\";\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20 {\n\tmodifier onlyPayloadSize(uint size) {\n\t\trequire(!(msg.data.length < size + 4));\n\t\t_;\n\t}\n\n\t/**\n\t * @notice query the total minted token supply\n\t * @return totalSupply_ token supply\n\t */\n\tfunction totalSupply() external view returns (uint256 totalSupply_) {\n\t\treturn LibERC20Base._totalSupply();\n\t}\n\n\t/**\n\t * @notice query the token balance of given account\n\t * @param account address to query\n\t * @return balance_ token balance\n\t */\n\tfunction balanceOf(address account) external view returns (uint256 balance_) {\n\t\treturn LibERC20Base._balanceOf(account);\n\t}\n\n\t/**\n\t * @notice query the allowance granted from given holder to given spender\n\t * @param holder approver of allowance\n\t * @param spender recipient of allowance\n\t * @return allowance_ token allowance\n\t */\n\tfunction allowance(address holder, address spender) external view returns (uint256 allowance_) {\n\t\treturn _allowance(holder, spender);\n\t}\n\n\tfunction _allowance(address holder, address spender) internal view virtual returns (uint256 allowance_) {\n\t\treturn LibERC20Base._allowance(holder, spender);\n\t}\n\n\t/**\n\t * @notice enable spender to spend tokens on behalf of holder\n\t * @param spender recipient of allowance\n\t * @param amount quantity of tokens approved for spending\n\t * @return status_ success status (always true; otherwise function should revert)\n\t */\n\tfunction approve(address spender, uint256 amount) external virtual onlyPayloadSize(2 * 32) returns (bool status_) {\n\t\treturn _approve(msg.sender, spender, amount);\n\t}\n\n\tfunction _approve(address holder, address spender, uint256 amount) internal virtual returns (bool status_) {\n\t\treturn LibERC20Base._approve(holder, spender, amount);\n\t}\n\n\t/**\n\t * @notice transfer tokens from holder to recipient\n\t * @param recipient beneficiary of transfer\n\t * @param amount quantity of tokens transferred\n\t * @return status_ success status (always true; otherwise function should revert)\n\t */\n\tfunction transfer(address recipient, uint256 amount) external onlyPayloadSize(2 * 32) returns (bool status_) {\n\t\treturn _transfer(msg.sender, recipient, amount);\n\t}\n\n\t/**\n\t * @notice transfer tokens to given recipient on behalf of given holder\n\t * @param holder holder of tokens prior to transfer\n\t * @param recipient beneficiary of token transfer\n\t * @param amount quantity of tokens to transfer\n\t * @return status_ success status (always true; otherwise function should revert)\n\t */\n\tfunction transferFrom(address holder, address recipient, uint256 amount) external onlyPayloadSize(3 * 32) returns (bool status_) {\n\t\treturn _transferFrom(holder, recipient, amount);\n\t}\n\n\t/**\n\t * @notice mint tokens for given account\n\t * @param account recipient of minted tokens\n\t * @param amount quantity of tokens minted\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"MintToZeroAddress\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\t\tLibERC20Base._mint(account, amount);\n\t}\n\n\t/**\n\t * @notice burn tokens held by given account\n\t * @param account holder of burned tokens\n\t * @param amount quantity of tokens burned\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"BurnFromZeroAddress\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\tLibERC20Base._burn(account, amount);\n\t}\n\n\t/**\n\t * @notice transfer tokens from holder to recipient\n\t * @param holder owner of tokens to be transferred\n\t * @param recipient beneficiary of transfer\n\t * @param amount quantity of tokens transferred\n\t * @return status_ success status (always true; otherwise function should revert)\n\t */\n\tfunction _transfer(address holder, address recipient, uint256 amount) internal virtual returns (bool status_) {\n\t\trequire(holder != address(0), \"TransferFromZeroAddress\");\n\t\trequire(recipient != address(0), \"TransferToZeroAddress\");\n\n\t\t_beforeTokenTransfer(holder, recipient, amount);\n\n\t\treturn LibERC20Base._transfer(holder, recipient, amount);\n\t}\n\n\t/**\n\t * @notice transfer tokens to given recipient on behalf of given holder\n\t * @param holder holder of tokens prior to transfer\n\t * @param recipient beneficiary of token transfer\n\t * @param amount quantity of tokens to transfer\n\t * @return success status (always true; otherwise function should revert)\n\t */\n\tfunction _transferFrom(address holder, address recipient, uint256 amount) internal virtual returns (bool) {\n\t\tLibERC20Base._decreaseAllowance(holder, msg.sender, amount);\n\n\t\t_transfer(holder, recipient, amount);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice ERC20 hook, called before all transfers including mint and burn\n\t * @dev function should be overridden and new implementation must call super\n\t * @param from sender of tokens\n\t * @param to receiver of tokens\n\t * @param amount quantity of tokens transferred\n\t */\n\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/base/ERC20/base/LibERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibERC20BaseStorage, ERC20BaseStorage } from \"./LibERC20Storage.sol\";\r\n\r\nlibrary LibERC20Base {\r\n\t//Come from IERC20\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\t//Come from IERC20Base\r\n\t// error ERC20Base__ApproveFromZeroAddress();\r\n\t// error ERC20Base__ApproveToZeroAddress();\r\n\t// error ERC20Base__BurnExceedsBalance();\r\n\t// error ERC20Base__BurnFromZeroAddress();\r\n\t// error ERC20Base__InsufficientAllowance();\r\n\t// error ERC20Base__MintToZeroAddress();\r\n\t// error ERC20Base__TransferExceedsBalance();\r\n\t// error ERC20Base__TransferFromZeroAddress();\r\n\t// error ERC20Base__TransferToZeroAddress();\r\n\r\n\t//\r\n\t/**\r\n\t * @notice query the total minted token supply\r\n\t * @return token supply\r\n\t */\r\n\tfunction _totalSupply() internal view returns (uint256) {\r\n\t\treturn LibERC20BaseStorage.layout().totalSupply;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query the token balance of given account\r\n\t * @param account address to query\r\n\t * @return balanceOf_ token balance\r\n\t */\r\n\tfunction _balanceOf(address account) internal view returns (uint256 balanceOf_) {\r\n\t\treturn LibERC20BaseStorage.layout().balances[account];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice query the allowance granted from given holder to given spender\r\n\t * @param holder approver of allowance\r\n\t * @param spender recipient of allowance\r\n\t * @return allowance_ token allowance\r\n\t */\r\n\tfunction _allowance(address holder, address spender) internal view returns (uint256 allowance_) {\r\n\t\treturn LibERC20BaseStorage.layout().allowances[holder][spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice enable spender to spend tokens on behalf of holder\r\n\t * @param holder address on whose behalf tokens may be spent\r\n\t * @param spender recipient of allowance\r\n\t * @param amount quantity of tokens approved for spending\r\n\t * @return status_ success status (always true; otherwise function should revert)\r\n\t */\r\n\tfunction _approve(address holder, address spender, uint256 amount) internal returns (bool status_) {\r\n\t\trequire(holder != address(0), \"ApproveFromZeroAddress\");\r\n\t\trequire(spender != address(0), \"ApproveToZeroAddress\");\r\n\r\n\t\tLibERC20BaseStorage.layout().allowances[holder][spender] = amount;\r\n\r\n\t\temit Approval(holder, spender, amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice decrease spend amount granted by holder to spender\r\n\t * @param holder address on whose behalf tokens may be spent\r\n\t * @param spender address whose allowance to decrease\r\n\t * @param amount quantity by which to decrease allowance\r\n\t */\r\n\tfunction _decreaseAllowance(address holder, address spender, uint256 amount) internal {\r\n\t\tuint256 allowance = _allowance(holder, spender);\r\n\r\n\t\trequire(amount <= allowance, \"InsufficientAllowance\");\r\n\r\n\t\tunchecked {\r\n\t\t\t_approve(holder, spender, allowance - amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice mint tokens for given account\r\n\t * @param account recipient of minted tokens\r\n\t * @param amount quantity of tokens minted\r\n\t */\r\n\tfunction _mint(address account, uint256 amount) internal {\r\n\t\t//WARNING always check this before calling _mint:\r\n\t\t//if (account == address(0)) revert ERC20Base__MintToZeroAddress();\r\n\r\n\t\tERC20BaseStorage storage e20s = LibERC20BaseStorage.layout();\r\n\t\te20s.totalSupply += amount;\r\n\t\te20s.balances[account] += amount;\r\n\r\n\t\temit Transfer(address(0), account, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice burn tokens held by given account\r\n\t * @param account holder of burned tokens\r\n\t * @param amount quantity of tokens burned\r\n\t */\r\n\tfunction _burn(address account, uint256 amount) internal {\r\n\t\t//WARNING always check this before calling _burn:\r\n\t\t//if (account == address(0)) revert ERC20Base__BurnFromZeroAddress();\r\n\r\n\t\tERC20BaseStorage storage e20s = LibERC20BaseStorage.layout();\r\n\r\n\t\tuint256 balance = e20s.balances[account];\r\n\t\trequire(amount <= balance, \"BurnExceedsBalance\");\r\n\t\tunchecked {\r\n\t\t\te20s.balances[account] = balance - amount;\r\n\t\t}\r\n\t\te20s.totalSupply -= amount;\r\n\r\n\t\temit Transfer(account, address(0), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice transfer tokens from holder to recipient\r\n\t * @param holder owner of tokens to be transferred\r\n\t * @param recipient beneficiary of transfer\r\n\t * @param amount quantity of tokens transferred\r\n\t * @return status_ success status (always true; otherwise function should revert)\r\n\t */\r\n\tfunction _transfer(address holder, address recipient, uint256 amount) internal returns (bool status_) {\r\n\t\tERC20BaseStorage storage e20s = LibERC20BaseStorage.layout();\r\n\r\n\t\tuint256 holderBalance = e20s.balances[holder];\r\n\t\trequire(amount <= holderBalance, \"TransferExceedsBalance\");\r\n\t\tunchecked {\r\n\t\t\te20s.balances[holder] = holderBalance - amount;\r\n\t\t}\r\n\t\te20s.balances[recipient] += amount;\r\n\r\n\t\temit Transfer(holder, recipient, amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20/base/LibERC20Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nstruct ERC20BaseStorage {\r\n\tmapping(address => uint256) balances;\r\n\tmapping(address => mapping(address => uint256)) allowances;\r\n\tuint256 totalSupply;\r\n}\r\n\r\nlibrary LibERC20BaseStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.contracts.erc20-base.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (ERC20BaseStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { IERC20Extended } from \"./IERC20Extended.sol\";\n\nimport { ERC20Base } from \"../base/ERC20Base.sol\";\nimport { LibERC20Base } from \"../base/LibERC20Base.sol\";\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is IERC20Extended, ERC20Base {\n\t/**\n\t * @notice increase spend amount granted to spender\n\t * @param spender address whose allowance to increase\n\t * @param amount quantity by which to increase allowance\n\t * @return success status (always true; otherwise function will revert)\n\t */\n\tfunction increaseAllowance(address spender, uint256 amount) external returns (bool) {\n\t\treturn _increaseAllowance(spender, amount);\n\t}\n\n\tfunction _increaseAllowance(address spender, uint256 amount) internal virtual returns (bool) {\n\t\tuint256 allowance = LibERC20Base._allowance(msg.sender, spender);\n\n\t\tunchecked {\n\t\t\tif (allowance > allowance + amount) revert ERC20Extended__ExcessiveAllowance();\n\n\t\t\treturn LibERC20Base._approve(msg.sender, spender, allowance + amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice decrease spend amount granted to spender\n\t * @param spender address whose allowance to decrease\n\t * @param amount quantity by which to decrease allowance\n\t * @return success status (always true; otherwise function will revert)\n\t */\n\tfunction decreaseAllowance(address spender, uint256 amount) external virtual returns (bool) {\n\t\treturn _decreaseAllowance(msg.sender, spender, amount);\n\t}\n\n\tfunction _decreaseAllowance(address holder, address spender, uint256 amount) internal virtual returns (bool) {\n\t\tLibERC20Base._decreaseAllowance(holder, spender, amount);\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/base/ERC20/extended/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { IERC20ExtendedInternal } from \"./IERC20ExtendedInternal.sol\";\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n\t/**\n\t * @notice increase spend amount granted to spender\n\t * @param spender address whose allowance to increase\n\t * @param amount quantity by which to increase allowance\n\t * @return success status (always true; otherwise function will revert)\n\t */\n\tfunction increaseAllowance(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @notice decrease spend amount granted to spender\n\t * @param spender address whose allowance to decrease\n\t * @param amount quantity by which to decrease allowance\n\t * @return success status (always true; otherwise function will revert)\n\t */\n\tfunction decreaseAllowance(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/base/ERC20/extended/IERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC20ExtendedInternal {\r\n\terror ERC20Extended__ExcessiveAllowance();\r\n\terror ERC20Extended__InsufficientAllowance();\r\n}\r\n"
    },
    "contracts/base/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @notice query the total minted token supply\n\t * @return token supply\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice query the token balance of given account\n\t * @param account address to query\n\t * @return token balance\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @notice query the allowance granted from given holder to given spender\n\t * @param holder approver of allowance\n\t * @param spender recipient of allowance\n\t * @return token allowance\n\t */\n\tfunction allowance(address holder, address spender) external view returns (uint256);\n\n\t/**\n\t * @notice grant approval to spender to spend tokens\n\t * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n\t * @param spender recipient of allowance\n\t * @param amount quantity of tokens approved for spending\n\t * @return success status (always true; otherwise function should revert)\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @notice transfer tokens to given recipient\n\t * @param recipient beneficiary of token transfer\n\t * @param amount quantity of tokens to transfer\n\t * @return success status (always true; otherwise function should revert)\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @notice transfer tokens to given recipient on behalf of given holder\n\t * @param holder holder of tokens prior to transfer\n\t * @param recipient beneficiary of token transfer\n\t * @param amount quantity of tokens to transfer\n\t * @return success status (always true; otherwise function should revert)\n\t */\n\tfunction transferFrom(address holder, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/base/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { IERC20Metadata } from \"./IERC20Metadata.sol\";\nimport { LibERC20Metadata } from \"./LibERC20Metadata.sol\";\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata {\n\t/**\n\t * @inheritdoc IERC20Metadata\n\t */\n\tfunction name() external view returns (string memory) {\n\t\treturn _name();\n\t}\n\n\tfunction _name() internal view virtual returns (string memory) {\n\t\treturn LibERC20Metadata._name();\n\t}\n\n\t/**\n\t * @inheritdoc IERC20Metadata\n\t */\n\tfunction symbol() external view returns (string memory) {\n\t\treturn _symbol();\n\t}\n\n\tfunction _symbol() internal view virtual returns (string memory) {\n\t\treturn LibERC20Metadata._symbol();\n\t}\n\n\t/**\n\t * @inheritdoc IERC20Metadata\n\t */\n\tfunction decimals() external view returns (uint8) {\n\t\treturn _decimals();\n\t}\n\n\tfunction _decimals() internal view returns (uint8) {\n\t\treturn LibERC20Metadata._decimals();\n\t}\n\n\tfunction _setName(string memory __name) internal virtual {\n\t\tLibERC20Metadata._setName(__name);\n\t}\n\n\tfunction _setSymbol(string memory __symbol) internal virtual {\n\t\tLibERC20Metadata._setSymbol(__symbol);\n\t}\n\n\tfunction _setDecimals(uint8 __decimals) internal virtual {\n\t\tLibERC20Metadata._setDecimals(__decimals);\n\t}\n}\n"
    },
    "contracts/base/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata {\n\t/**\n\t * @notice return token name\n\t * @return token name\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @notice return token symbol\n\t * @return token symbol\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @notice return token decimals, generally used only for display purposes\n\t * @return token decimals\n\t */\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/base/ERC20/metadata/LibERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { LibERC20MetadataStorage } from \"./LibERC20MetadataStorage.sol\";\n\n/**\n * @title ERC20Metadata internal functions\n */\nlibrary LibERC20Metadata {\n\t/**\n\t * @notice return token name\n\t * @return token name\n\t */\n\tfunction _name() internal view returns (string memory) {\n\t\treturn LibERC20MetadataStorage.layout().name;\n\t}\n\n\t/**\n\t * @notice return token symbol\n\t * @return token symbol\n\t */\n\tfunction _symbol() internal view returns (string memory) {\n\t\treturn LibERC20MetadataStorage.layout().symbol;\n\t}\n\n\t/**\n\t * @notice return token decimals, generally used only for display purposes\n\t * @return token decimals\n\t */\n\tfunction _decimals() internal view returns (uint8) {\n\t\treturn LibERC20MetadataStorage.layout().decimals;\n\t}\n\n\tfunction _setName(string memory name) internal {\n\t\tLibERC20MetadataStorage.layout().name = name;\n\t}\n\n\tfunction _setSymbol(string memory symbol) internal {\n\t\tLibERC20MetadataStorage.layout().symbol = symbol;\n\t}\n\n\tfunction _setDecimals(uint8 decimals) internal {\n\t\tLibERC20MetadataStorage.layout().decimals = decimals;\n\t}\n}\n"
    },
    "contracts/base/ERC20/metadata/LibERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nstruct ERC20MetadataStorage {\n\tstring name;\n\tstring symbol;\n\tuint8 decimals;\n}\n\nlibrary LibERC20MetadataStorage {\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.erc20-metadata.storage.v1\");\n\n\tfunction layout() internal pure returns (ERC20MetadataStorage storage layout_) {\n\t\tbytes32 position = STORAGE_SLOT;\n\t\tassembly {\n\t\t\tlayout_.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/base/ERC20Diamond/TokenACLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\n//import { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenACLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tbytes32 public constant TOKEN_ADMIN_ROLE = LibTokenConst.TOKEN_ADMIN_ROLE;\r\n\tbytes32 public constant TREASURY_ROLE = LibTokenConst.TREASURY_ROLE;\r\n\tbytes32 public constant AML_ROLE = LibTokenConst.AML_ROLE;\r\n\tbytes32 public constant COMPLIANCE_ROLE = LibTokenConst.COMPLIANCE_ROLE;\r\n\r\n\tconstructor() {}\r\n\r\n\t//ide az accesscontroll kell\r\n\tfunction hasRole(bytes32 role, address account) external view virtual protectedCall returns (bool) {\r\n\t\treturn LibAccessControl._hasRole(role, account);\r\n\t}\r\n\r\n\tfunction grantRole(bytes32 role, address account) external virtual protectedCall onlyRoleAdmin(role) {\r\n\t\t_grantRole(role, account);\r\n\t}\r\n\r\n\tfunction revokeRole(bytes32 role, address account) external virtual protectedCall onlyRoleAdmin(role) {\r\n\t\trequire(!(role == TOKEN_ADMIN_ROLE && account == LibAccessControl._owner()), \"Role cannot revoke from owner!\");\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction renounceRole(bytes32 role) external virtual protectedCall {\r\n\t\t_renounceRole(role);\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) external view virtual protectedCall returns (bytes32) {\r\n\t\treturn LibAccessControl._getRoleAdmin(role);\r\n\t}\r\n\r\n\tfunction setRoleAdmin(bytes32 role, bytes32 adminRole) external virtual protectedCall onlyOwner {\r\n\t\t_setRoleAdmin(role, adminRole);\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual protectedCall {\r\n\t\tLibAccessControl._setRoleAdmin(role, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal virtual protectedCall {\r\n\t\tLibAccessControl._grantRole(role, account);\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal virtual protectedCall {\r\n\t\tLibAccessControl._revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction _renounceRole(bytes32 role) internal virtual protectedCall {\r\n\t\tLibAccessControl._renounceRole(role);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\n//import { LibBlackWhiteList } from \"../base/BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibCustomERC20Extension } from \"../ERC20Token/LibCustomERC20Extension.sol\";\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenAdminFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tfunction getTreasuryAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getTreasuryAddress();\r\n\t}\r\n\r\n\tfunction setTreasuryAddress(\r\n\t\taddress _treasuryAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setTreasuryAddress(_treasuryAddress);\r\n\t}\r\n\r\n\tfunction getURL() external view protectedCall returns (string memory) {\r\n\t\treturn LibCustomERC20Extension._getURL();\r\n\t}\r\n\r\n\tfunction setURL(\r\n\t\tstring calldata _url\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setURL(_url);\r\n\t}\r\n\r\n\tfunction getGeneralFeeAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getGeneralFeeAddress();\r\n\t}\r\n\r\n\tfunction setGeneralFeeAddress(\r\n\t\taddress _generalFeeAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setGeneralFeeAddress(_generalFeeAddress);\r\n\t}\r\n\r\n\tfunction getGeneralFee() external view protectedCall returns (uint16) {\r\n\t\treturn LibCustomERC20Extension._getGeneralFee();\r\n\t}\r\n\r\n\tfunction setGeneralFee(\r\n\t\tuint16 _generalFee\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setGeneralFee(_generalFee);\r\n\t}\r\n\r\n\tfunction getPoolFee() external view protectedCall returns (uint16) {\r\n\t\treturn LibCustomERC20Extension._getPoolFee();\r\n\t}\r\n\r\n\tfunction setPoolFee(uint16 _PoolFee) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setPoolFee(_PoolFee);\r\n\t}\r\n\r\n\tfunction getPoolFeeAddress() external view protectedCall returns (address) {\r\n\t\treturn LibCustomERC20Extension._getPoolFeeAddress();\r\n\t}\r\n\r\n\tfunction setPoolFeeAddress(\r\n\t\taddress _PoolFeeAddress\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibCustomERC20Extension._setPoolFeeAddress(_PoolFeeAddress);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenAMLFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { LibBlackWhiteList } from \"../BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenAMLFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tconstructor() {}\r\n\r\n\tbytes32 public constant SENDER_BLACKLIST = LibTokenConst.SENDER_BL;\r\n\tbytes32 public constant RECIPIENT_BLACKLIST = LibTokenConst.RECIPIENT_BL;\r\n\r\n\tfunction getAccountBlackWhiteList(bytes32 _target, address _account) external view returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(_target, _account);\r\n\t}\r\n\r\n\tfunction setAccountBlackWhiteList(\r\n\t\tbytes32 _target,\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(_target, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction getSourceAccountBL(address _account) external view protectedCall returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(SENDER_BLACKLIST, _account);\r\n\t}\r\n\r\n\tfunction setSourceAccountBL(\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(SENDER_BLACKLIST, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction setBatchSourceAccountBL(\r\n\t\taddress[] calldata _addresses,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\trequire(_addresses.length <= 255, \"Batch: too many addresses\");\r\n\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\r\n\t\t\tLibBlackWhiteList._setAccountBlackWhiteList(SENDER_BLACKLIST, _addresses[i], _lockValue);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getDestinationAccountBL(address _account) external view protectedCall returns (bool) {\r\n\t\treturn LibBlackWhiteList._getAccountBlackWhiteList(RECIPIENT_BLACKLIST, _account);\r\n\t}\r\n\r\n\tfunction setDestinationAccountBL(\r\n\t\taddress _account,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\tLibBlackWhiteList._setAccountBlackWhiteList(RECIPIENT_BLACKLIST, _account, _lockValue);\r\n\t}\r\n\r\n\tfunction setBatchDestinationAccountBL(\r\n\t\taddress[] calldata _addresses,\r\n\t\tbool _lockValue\r\n\t) external protectedCall whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.AML_ROLE) {\r\n\t\trequire(_addresses.length <= 255, \"Batch: too many addresses\");\r\n\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\r\n\t\t\tLibBlackWhiteList._setAccountBlackWhiteList(RECIPIENT_BLACKLIST, _addresses[i], _lockValue);\r\n\t\t}\r\n\t}\r\n\r\n\t//ide az blck lista kezelés, illetve 1404 kezelés kellene\r\n\t//végleg elégetni egy számlát, és tokent kivonni\r\n\tfunction withdrawUserTokenByCompliance(address _account) external protectedCall onlyRole(LibTokenConst.COMPLIANCE_ROLE) {\r\n\t\t//\r\n\t\t//ha számla végleg törölt listában van ÉS blacklistán is van\r\n\t\t//akkor a teljes összeget transferálni kell a treasury számlára???\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { uSmartERC20 } from \"../ERC20Token/ERC20Token.sol\";\r\n\r\nabstract contract TokenFacet is uSmartERC20 {\r\n\tconstructor() uSmartERC20() {}\r\n}\r\n"
    },
    "contracts/base/ERC20Diamond/TokenOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { Ownable } from \"../Ownable/Ownable.sol\";\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\n\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\n\n//import { ModifierRole } from \"../base/AccessControl/ModifierRole.sol\";\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\n\nabstract contract TokenOwnershipFacet is Ownable, CallProtection, ModifierPausable {\n\tfunction transferOwnership(address _newOwner) public override protectedCall whenNotPaused(LibTokenConst.FULL) onlyOwner {\n\t\tsuper.transferOwnership(_newOwner);\n\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TOKEN_ADMIN_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TREASURY_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.AML_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.COMPLIANCE_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\n\t\tLibAccessControl._grantRole(LibTokenConst.TOKEN_ADMIN_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.TREASURY_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.AML_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.COMPLIANCE_ROLE, LibAccessControl._owner());\n\t}\n}\n"
    },
    "contracts/base/ERC20Diamond/TokenPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"../ERC20Token/LibTokenConst.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\nimport { CallProtection } from \"../Shared/ProtectedCall.sol\";\r\n\r\nabstract contract TokenPausableFacet is CallProtection, ModifierRole, ModifierPausable {\r\n\tbytes32 public constant PAUSABLE_FULL = LibTokenConst.FULL; //LibTokenConst LibBlockBenTokenConst\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction paused(bytes32 target) external view returns (bool status_) {\r\n\t\tstatus_ = LibTargetedPausable._paused(target);\r\n\t}\r\n\r\n\tfunction pause(bytes32 target) external whenNotPaused(target) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._pause(target, msg.sender);\r\n\t}\r\n\r\n\tfunction unpause(bytes32 target) external whenPaused(target) onlyRole(LibTokenConst.TOKEN_ADMIN_ROLE) {\r\n\t\tLibTargetedPausable._unpause(target, msg.sender);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { IERC20 } from \"../ERC20/IERC20.sol\";\r\nimport { ERC20Base } from \"../ERC20/base/ERC20Base.sol\";\r\nimport { ERC20Extended } from \"../ERC20/extended/ERC20Extended.sol\";\r\nimport { ERC20Metadata } from \"../ERC20/metadata/ERC20Metadata.sol\";\r\n\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { LibBlackWhiteList } from \"../BlackWhiteList/LibBlackWhiteList.sol\";\r\nimport { LibTargetedPausable } from \"../TargetedPausable/LibTargetedPausable.sol\";\r\n\r\nimport { LibTokenConst } from \"./LibTokenConst.sol\";\r\nimport { LibCustomERC20Extension } from \"./LibCustomERC20Extension.sol\";\r\n\r\nimport { SafeMath } from \"../../utils/SafeMath.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\nimport { ModifierPausable } from \"../TargetedPausable/ModifierPausable.sol\";\r\n\r\n/**\r\n * @title uSmart's ERC20 implementation, including recommended extensions and other usfull stuff\r\n */\r\n//ERC20Permit\r\nabstract contract uSmartERC20 is ERC20Base, ERC20Extended, ERC20Metadata, ModifierRole, ModifierPausable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction _approve(\r\n\t\taddress _holder,\r\n\t\taddress _spender,\r\n\t\tuint256 _value\r\n\t) internal override whenNotPaused(LibTokenConst.FULL) returns (bool) {\r\n\t\trequire((_value == 0) || (_allowance(msg.sender, _spender) == 0), \"Approve: zero first\");\r\n\t\treturn super._approve(_holder, _spender, _value);\r\n\t}\r\n\r\n\tfunction _increaseAllowance(address _spender, uint256 _addedValue) internal override whenNotPaused(LibTokenConst.FULL) returns (bool) {\r\n\t\treturn super._increaseAllowance(_spender, _addedValue);\r\n\t}\r\n\r\n\tfunction _decreaseAllowance(\r\n\t\taddress _holder,\r\n\t\taddress _spender,\r\n\t\tuint256 _subtractValue\r\n\t) internal override whenNotPaused(LibTokenConst.FULL) returns (bool) {\r\n\t\treturn super._decreaseAllowance(_holder, _spender, _subtractValue);\r\n\t}\r\n\r\n\tfunction mint(address account, uint256 amount) external whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TREASURY_ROLE) {\r\n\t\t_mint(account, amount);\r\n\t}\r\n\r\n\tfunction burn(uint256 amount) external whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TREASURY_ROLE) {\r\n\t\t_burn(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction burnFrom(address account, uint256 amount) external whenNotPaused(LibTokenConst.FULL) onlyRole(LibTokenConst.TREASURY_ROLE) {\r\n\t\t_burn(account, amount);\r\n\t}\r\n\r\n\t//function _setName(string memory name) internal virtual override(ERC20Metadata, ERC20PermitInternal) {\r\n\tfunction _setName(string memory name) internal virtual override {\r\n\t\tsuper._setName(name);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer token between accounts, based on BNOX TOS.\r\n\t * - poolFee% of the transferred amount is going to poolAddress\r\n\t * - generalFee% of the transferred amount is going to amountGeneral\r\n\t *\r\n\t * @param _sender The address from where the token sent\r\n\t * @param _recipient Recipient address\r\n\t * @param _amount The amount to be transferred\r\n\t */\r\n\tfunction _transfer(address _sender, address _recipient, uint256 _amount) internal override returns (bool) {\r\n\t\tif (\r\n\t\t\t(LibBlackWhiteList._getAccountBlackWhiteList(LibTokenConst.SENDER_FREE_FEE_WL, _sender)) ||\r\n\t\t\t(LibBlackWhiteList._getAccountBlackWhiteList(LibTokenConst.RECIPIENT_FREE_FEE_WL, _recipient))\r\n\t\t) {\r\n\t\t\treturn super._transfer(_sender, _recipient, _amount);\r\n\t\t} else {\r\n\t\t\t/**\r\n\t\t\t * Three decimal in percent.\r\n\t\t\t * The decimal correction is 100.000, but to avoid rounding errors, first divide by 10.000\r\n\t\t\t * and after that the calculation must add 5 and divide 10 at the end.\r\n\t\t\t */\r\n\t\t\tuint256 decimalCorrection = 10000;\r\n\t\t\tuint256 generalFeePercent256 = LibCustomERC20Extension._getGeneralFee();\r\n\t\t\tuint256 bsoFeePercent256 = LibCustomERC20Extension._getPoolFee();\r\n\t\t\tuint256 totalFeePercent = generalFeePercent256.add(bsoFeePercent256);\r\n\r\n\t\t\tuint256 totalFeeAmount = _amount.mul(totalFeePercent).div(decimalCorrection).add(5).div(10);\r\n\t\t\tuint256 amountBso = _amount.mul(bsoFeePercent256).div(decimalCorrection).add(5).div(10);\r\n\t\t\tuint256 amountGeneral = totalFeeAmount.sub(amountBso);\r\n\r\n\t\t\tuint256 recipientTransferAmount = _amount.sub(totalFeeAmount);\r\n\r\n\t\t\tbool result = super._transfer(_sender, _recipient, recipientTransferAmount);\r\n\t\t\trequire(result, \"Transfer error\");\r\n\r\n\t\t\tif (amountGeneral > 0) {\r\n\t\t\t\tresult = super._transfer(_sender, LibCustomERC20Extension._getGeneralFeeAddress(), amountGeneral);\r\n\t\t\t\trequire(result, \"General fee transfer error\");\r\n\t\t\t}\r\n\r\n\t\t\tif (amountBso > 0) {\r\n\t\t\t\tresult = super._transfer(_sender, LibCustomERC20Extension._getPoolFeeAddress(), amountBso);\r\n\t\t\t\trequire(result, \"Pool fee transfer error\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused(LibTokenConst.FULL) {\r\n\t\trequire(!LibBlackWhiteList._getAccountBlackWhiteList(LibTokenConst.SENDER_BL, from), \"Blacklist: sender\");\r\n\t\trequire(!LibBlackWhiteList._getAccountBlackWhiteList(LibTokenConst.RECIPIENT_BL, to), \"Blacklist: recipient\");\r\n\t\tsuper._beforeTokenTransfer(from, to, amount);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibCustomERC20Extension.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibCustomERC20ExtensionStorage } from \"./LibCustomERC20ExtensionStorage.sol\";\r\n\r\nlibrary LibCustomERC20Extension {\r\n\t///LibBlockBenERC20ExtensionStorage\r\n\t//URL, Fee and other usfull extension will come here\r\n\r\n\tfunction _getTreasuryAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().treasuryAddress;\r\n\t}\r\n\r\n\tfunction _setTreasuryAddress(address _treasuryAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().treasuryAddress = _treasuryAddress;\r\n\t}\r\n\r\n\tfunction _getURL() internal view returns (string memory) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().url;\r\n\t}\r\n\r\n\tfunction _setURL(string calldata _url) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().url = _url;\r\n\t}\r\n\r\n\tfunction _getGeneralFeeAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().generalFeeAddress;\r\n\t}\r\n\r\n\tfunction _setGeneralFeeAddress(address _generalFeeAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().generalFeeAddress = _generalFeeAddress;\r\n\t}\r\n\r\n\tfunction _getGeneralFee() internal view returns (uint16) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().generalFee;\r\n\t}\r\n\r\n\tfunction _setGeneralFee(uint16 _generalFee) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().generalFee = _generalFee;\r\n\t}\r\n\r\n\tfunction _getPoolFee() internal view returns (uint16) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().poolFee;\r\n\t}\r\n\r\n\tfunction _setPoolFee(uint16 _poolFee) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().poolFee = _poolFee;\r\n\t}\r\n\r\n\tfunction _getPoolFeeAddress() internal view returns (address) {\r\n\t\treturn LibCustomERC20ExtensionStorage.layout().poolFeeAddress;\r\n\t}\r\n\r\n\tfunction _setPoolFeeAddress(address _poolFeeAddress) internal {\r\n\t\tLibCustomERC20ExtensionStorage.layout().poolFeeAddress = _poolFeeAddress;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibCustomERC20ExtensionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nstruct CustomERC20ExtensionStorage {\r\n\tstring url;\r\n\taddress treasuryAddress;\r\n\tuint16 generalFee;\r\n\taddress generalFeeAddress;\r\n\tuint16 poolFee;\r\n\taddress poolFeeAddress;\r\n}\r\n\r\nlibrary LibCustomERC20ExtensionStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.constract.custom-erc20-extension.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (CustomERC20ExtensionStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/ERC20Token/LibTokenConst.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nlibrary LibTokenConst {\r\n\t//Pausable\r\n\tbytes32 public constant FULL = 0x00;\r\n\r\n\t//Roles\r\n\tbytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\"TOKEN_ADMIN_ROLE\");\r\n\tbytes32 public constant TREASURY_ROLE = keccak256(\"TREASURY_ROLE\");\r\n\tbytes32 public constant AML_ROLE = keccak256(\"AML_ROLE\");\r\n\tbytes32 public constant COMPLIANCE_ROLE = keccak256(\"COMPLIANCE_ROLE\");\r\n\r\n\t//BlackWhite lists, these accounts could not send/receive token\r\n\tbytes32 public constant SENDER_BL = keccak256(\"SENDER_BLACKLIST\");\r\n\tbytes32 public constant RECIPIENT_BL = keccak256(\"RECIPIENT_BLACKLIST\");\r\n\r\n\t//FreeFee WhiteList, these accounts don't pay fee...\r\n\tbytes32 public constant SENDER_FREE_FEE_WL = keccak256(\"SENDER_FREE_FEE_WHITELIST\");\r\n\tbytes32 public constant RECIPIENT_FREE_FEE_WL = keccak256(\"RECIPIENT_FREE_FEE_WHITELIST\");\r\n}\r\n"
    },
    "contracts/base/Ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { IERC173 } from \"../../interfaces/IERC173.sol\";\r\nimport { LibAccessControl } from \"../AccessControl/LibAccessControl.sol\";\r\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\r\n\r\nimport { ModifierRole } from \"../AccessControl/ModifierRole.sol\";\r\n\r\nabstract contract Ownable is IERC173, ModifierRole {\r\n\tusing AddressUtils for address;\r\n\r\n\t/**\r\n\t * @notice get the ERC173 contract owner\r\n\t * @return contract owner\r\n\t */\r\n\tfunction owner() external view returns (address) {\r\n\t\treturn LibAccessControl._owner();\r\n\t}\r\n\r\n\t/// @notice Set the address of the new owner of the contract\r\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\r\n\t/// @param _newOwner The address of the new owner of the contract\r\n\tfunction transferOwnership(address _newOwner) public virtual onlyOwner {\r\n\t\tLibAccessControl._setOwner(_newOwner);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/Shared/LibReentryProtectionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nstruct ReentryProtectionStorage {\r\n\tuint256 lockCounter;\r\n}\r\n\r\nlibrary LibReentryProtectionStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.reentry-protection.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (ReentryProtectionStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/Shared/ProtectedCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibDiamond } from \"../Diamond/LibDiamond.sol\";\r\n\r\ncontract CallProtection {\r\n\tmodifier protectedCall() {\r\n\t\trequire(address(this) == LibDiamond.getDiamondAddress(), \"NOT_ALLOWED\");\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/Shared/ReentryProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibReentryProtectionStorage.sol\";\r\n\r\ncontract ReentryProtection {\r\n\tmodifier noReentry() {\r\n\t\t// Use counter to only write to storage once\r\n\t\tReentryProtectionStorage storage rps = LibReentryProtectionStorage.layout();\r\n\t\trps.lockCounter++;\r\n\t\tuint256 lockValue = rps.lockCounter;\r\n\t\t_;\r\n\t\trequire(lockValue == rps.lockCounter, \"ReentryProtection: reentry detected!\");\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/LibTargetedPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibTargetedPausableStorage.sol\";\r\n\r\nlibrary LibTargetedPausable {\r\n\terror TargetedPausable__TargetedPaused();\r\n\terror TargetedPausable__NotTargetedPaused();\r\n\r\n\t//target: what was paused\r\n\t//account: the operator who is paused the target\r\n\tevent TargetedPaused(bytes32 indexed target, address indexed account);\r\n\r\n\t//target: what was unpaused\r\n\t//account: the operator who is unpaused the target\r\n\tevent TargetedUnpaused(bytes32 target, address indexed account);\r\n\r\n\tfunction _whenNotPaused(bytes32 _target) internal view {\r\n\t\tif (LibTargetedPausable._paused(_target)) revert TargetedPausable__TargetedPaused();\r\n\t}\r\n\r\n\tfunction _whenPaused(bytes32 _target) internal view {\r\n\t\tif (!LibTargetedPausable._paused(_target)) revert TargetedPausable__NotTargetedPaused();\r\n\t}\r\n\r\n\tfunction _paused(bytes32 _target) internal view returns (bool paused_) {\r\n\t\tpaused_ = LibTargetedPausableStorage.layout().paused[_target];\r\n\t}\r\n\r\n\tfunction _pause(bytes32 _target, address _operator) internal {\r\n\t\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\r\n\t\tif (ps.paused[_target]) revert TargetedPausable__TargetedPaused();\r\n\t\tps.paused[_target] = true;\r\n\t\temit TargetedPaused(_target, _operator);\r\n\t}\r\n\r\n\tfunction _unpause(bytes32 _target, address _operator) internal {\r\n\t\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\r\n\t\tif (!ps.paused[_target]) revert TargetedPausable__NotTargetedPaused();\r\n\t\tps.paused[_target] = false;\r\n\t\tdelete ps.paused[_target];\r\n\t\temit TargetedUnpaused(_target, _operator);\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/LibTargetedPausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct TargetedPausableStorage {\r\n\tmapping(bytes32 => bool) paused;\r\n}\r\n\r\nlibrary LibTargetedPausableStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.targeted-pausable.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (TargetedPausableStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TargetedPausable/ModifierPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibTargetedPausable } from \"./LibTargetedPausable.sol\";\r\n\r\nabstract contract ModifierPausable {\r\n\t//\r\n\tmodifier whenNotPaused(bytes32 target) {\r\n\t\tLibTargetedPausable._whenNotPaused(target);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenPaused(bytes32 target) {\r\n\t\tLibTargetedPausable._whenPaused(target);\r\n\t\t_;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenDynamicPricing/LibTokenDynamicPricing.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./LibTokenDynamicPricingStorage.sol\";\r\n\r\nimport \"../../utils/Math.sol\";\r\n\r\nlibrary LibTokenDynamicPricing {\r\n\tfunction initialize(uint256 _tokenId, uint256 _initialQuantity, uint256 _min, uint256 _max) internal {\r\n\t\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\r\n\t\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\r\n\r\n\t\tpricing.isEnabled = true;\r\n\t\tpricing.quantity = _initialQuantity;\r\n\t\tpricing.k = (_min == 0) ? _initialQuantity * _initialQuantity : _initialQuantity * _initialQuantity * _min;\r\n\t\tpricing.min = _min; //must contain the decimals of the paying token!!!\r\n\t\tpricing.max = (_max == 0 || _max < _min) ? pricing.k : _max; //must contain the decimals of the paying token!!!\r\n\t}\r\n\r\n\tfunction _calcTotalValue(DynamicPricing storage pricing, uint256 _quantity) internal view returns (uint256) {\r\n\t\trequire(pricing.isEnabled, \"Calculation is not enabled for the token!\");\r\n\t\trequire(_quantity <= pricing.quantity, \"Not enought quantity left!\");\r\n\t\tuint256 totalValue = (((10 * _quantity * pricing.k) / (pricing.quantity * (pricing.quantity - _quantity + 1))) + 5) / 10;\r\n\t\treturn Math.min(_quantity * pricing.max, Math.max(_quantity * pricing.min, totalValue));\r\n\t}\r\n\r\n\tfunction calcTotalValue(uint256 _tokenId, uint256 _quantity) internal view returns (uint256) {\r\n\t\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\r\n\t\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\r\n\t\treturn _calcTotalValue(pricing, _quantity);\r\n\t}\r\n\r\n\tfunction buyQuantity(uint256 _tokenId, uint256 _quantity) internal returns (uint256) {\r\n\t\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\r\n\t\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\r\n\t\tuint256 totalValue = _calcTotalValue(pricing, _quantity);\r\n\r\n\t\tpricing.quantity = pricing.quantity - _quantity;\r\n\t\tpricing.totalValue = pricing.totalValue + totalValue;\r\n\r\n\t\tif (pricing.quantity == 0) {\r\n\t\t\tpricing.isEnabled = false;\r\n\t\t}\r\n\r\n\t\treturn totalValue;\r\n\t}\r\n\r\n\tfunction getEnabled(uint256 _tokenId) internal view returns (bool) {\r\n\t\t//\r\n\t\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\r\n\t\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\r\n\t\treturn pricing.isEnabled;\r\n\t}\r\n\r\n\tfunction setPricingEnabled(uint256 _tokenId, bool _enabledValue) internal {\r\n\t\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\r\n\t\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\r\n\t\trequire(\r\n\t\t\t!_enabledValue || (_enabledValue && pricing.quantity > 0),\r\n\t\t\t\"Reenable of token pricing is only availabe is there is som token left to sell!\"\r\n\t\t);\r\n\t\tpricing.isEnabled = _enabledValue;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenDynamicPricing/LibTokenDynamicPricingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct DynamicPricing {\r\n\tbool isEnabled;\r\n\tuint256 quantity;\r\n\tuint256 totalValue;\r\n\tuint256 k;\r\n\tuint256 min;\r\n\tuint256 max;\r\n}\r\n\r\nstruct TokenDynamicPricingStorage {\r\n\t//tokenId => restriction, every token have\r\n\tmapping(uint256 => DynamicPricing) tokenDynamicPricing;\r\n}\r\n\r\nlibrary LibTokenDynamicPricingStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.token-dynamic-pricing.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (TokenDynamicPricingStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenPNL/LibTokenPNL.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\nimport \"./LibTokenPNLStorage.sol\";\r\n\r\nlibrary LibTokenPNL {\r\n\tfunction initTokenPNL(address _contract, uint256 _tokenId) internal {\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tinventory.isEnabled = true;\r\n\t\tinventory.sumQuantity = 0;\r\n\t\tinventory.sumAmount = 0;\r\n\t\tinventory.sumPnl = 0;\r\n\t}\r\n\r\n\tfunction changeTotalValue(address _contract, uint256 _tokenId, int256 _amount) internal {\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tif (!inventory.isEnabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//because every transfer, mint and burn do like ralizing the pnl\r\n\t\t//and after this realizing the user can payout the collected a PNL\r\n\t\t//so decreasing the value can cause money loss in the contract!!!\r\n\t\t//if wanted full inventory feature in a distributed way: ask uSmart ;)\r\n\t\trequire(_amount >= 0, \"Pool can only increase!\");\r\n\r\n\t\tinventory.sumAmount += _amount;\r\n\t\tinventory.sumPnl += _amount; //Here is the MAGIC!\r\n\r\n\t\t// console.log(\"ChangeTotalValue\");\r\n\t\t// console.log(\"_tokenId\", _tokenId);\r\n\t\t// if (inventory.sumAmount >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumAmount\", uint256(inventory.sumAmount));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumAmount -\", uint256(-1 * inventory.sumAmount));\r\n\t\t// }\r\n\r\n\t\t// if (inventory.sumPnl >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumPnl\", uint256(inventory.sumPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumPnl -\", uint256(-1 * inventory.sumPnl));\r\n\t\t// }\r\n\t}\r\n\r\n\tfunction getInventory(\r\n\t\taddress _contract,\r\n\t\tuint256 _tokenId\r\n\t) internal view returns (bool isEnabled, int256 sumQuantity, int256 sumAmount, int256 sumPnl) {\r\n\t\t//\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\treturn (inventory.isEnabled, inventory.sumQuantity, inventory.sumAmount, inventory.sumPnl);\r\n\t}\r\n\r\n\tfunction getInventoryItem(\r\n\t\taddress _contract,\r\n\t\tuint256 _tokenId,\r\n\t\taddress _account\r\n\t) internal view returns (InventoryItem memory inventoryItem) {\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tinventoryItem = inventory.divident[_account];\r\n\t}\r\n\r\n\tfunction _refreshDividentInternal(Inventory storage inventory, address _account, int256 _quantity) internal {\r\n\t\tInventoryItem storage inventoryItem = inventory.divident[_account];\r\n\r\n\t\trequire(inventory.sumQuantity + _quantity >= 0, \"Pool token quanity can't be less then zero!\");\r\n\t\trequire(inventoryItem.quantity + _quantity >= 0, \"User token quanity can't be less then zero!\");\r\n\r\n\t\t// console.log(\"_refreshDividentInternal\");\r\n\t\t// console.log(\"account\", _account);\r\n\r\n\t\t// if (inventory.sumQuantity >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumQuantity\", uint256(inventory.sumQuantity));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumQuantity -\", uint256(-1 * inventory.sumQuantity));\r\n\t\t// }\r\n\t\t// if (inventory.sumPnl >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumPnl\", uint256(inventory.sumPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumPnl -\", uint256(-1 * inventory.sumPnl));\r\n\t\t// }\r\n\r\n\t\tint256 addressPnlDelta = 0;\r\n\t\tif (inventory.sumQuantity != 0) {\r\n\t\t\taddressPnlDelta = (inventory.sumPnl * _quantity) / inventory.sumQuantity;\r\n\t\t}\r\n\t\t// if (addressPnlDelta >= 0) {\r\n\t\t// \tconsole.log(\"addressPnlDelta\", uint256(addressPnlDelta));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"addressPnlDelta -\", uint256(-1 * addressPnlDelta));\r\n\t\t// }\r\n\r\n\t\tinventory.sumQuantity = inventory.sumQuantity + _quantity;\r\n\t\tinventory.sumPnl = inventory.sumPnl + addressPnlDelta;\r\n\t\tinventoryItem.quantity = inventoryItem.quantity + _quantity;\r\n\t\tinventoryItem.deltaPnl = inventoryItem.deltaPnl - addressPnlDelta;\r\n\r\n\t\t// if (inventory.sumQuantity >= 0) {\r\n\t\t// \tconsole.log(\"NEW inventory.sumQuantity\", uint256(inventory.sumQuantity));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"NEW inventory.sumQuantity -\", uint256(-1 * inventory.sumQuantity));\r\n\t\t// }\r\n\t\t// if (inventory.sumPnl >= 0) {\r\n\t\t// \tconsole.log(\"NEW inventory.sumPnl\", uint256(inventory.sumPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"NEW inventory.sumPnl -\", uint256(-1 * inventory.sumPnl));\r\n\t\t// }\r\n\t\t// if (inventoryItem.quantity >= 0) {\r\n\t\t// \tconsole.log(\"NEW inventoryItem.quantity\", uint256(inventoryItem.quantity));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"NEW inventoryItem.quantity -\", uint256(-1 * inventoryItem.quantity));\r\n\t\t// }\r\n\t\t// if (inventoryItem.deltaPnl >= 0) {\r\n\t\t// \tconsole.log(\"NEW inventoryItem.deltaPnl\", uint256(inventoryItem.deltaPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"NEW inventoryItem.deltaPnl -\", uint256(-1 * inventoryItem.deltaPnl));\r\n\t\t// }\r\n\t}\r\n\r\n\tfunction refreshDivident(address _contract, uint256 _tokenId, address _fromAccount, address _toAccount, uint256 _quantity) internal {\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tif (!inventory.isEnabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (_fromAccount != address(0)) {\r\n\t\t\t_refreshDividentInternal(inventory, _fromAccount, -1 * int256(_quantity));\r\n\t\t}\r\n\r\n\t\tif (_toAccount != address(0)) {\r\n\t\t\t_refreshDividentInternal(inventory, _toAccount, int256(_quantity));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calcDivident(address _contract, uint256 _tokenId, address _account) internal view returns (int256) {\r\n\t\tif (_account == address(0)) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tif (!inventory.isEnabled) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tInventoryItem storage inventoryItem = inventory.divident[_account];\r\n\t\t//calculate actual value of the token\r\n\t\tint256 actValue = 0;\r\n\t\tif (inventory.sumQuantity != 0) {\r\n\t\t\tactValue = (inventory.sumPnl * inventoryItem.quantity) / inventory.sumQuantity;\r\n\t\t}\r\n\t\t//the divident is equal with the actual value minus the summa pnlDelta\r\n\t\t//note: the pnlDelta already have the negative sign!!!\r\n\t\tint256 actDivident = actValue + inventoryItem.deltaPnl - inventoryItem.payedPnl;\r\n\r\n\t\t// console.log(\"calcDivident\");\r\n\t\t// if (inventory.sumPnl >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumPnl\", uint256(inventory.sumPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumPnl -\", uint256(-1 * inventory.sumPnl));\r\n\t\t// }\r\n\t\t// if (inventoryItem.quantity >= 0) {\r\n\t\t// \tconsole.log(\"inventoryItem.quantity\", uint256(inventoryItem.quantity));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventoryItem.quantity -\", uint256(-1 * inventoryItem.quantity));\r\n\t\t// }\r\n\t\t// if (inventory.sumQuantity >= 0) {\r\n\t\t// \tconsole.log(\"inventory.sumQuantity\", uint256(inventory.sumQuantity));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventory.sumQuantity -\", uint256(-1 * inventory.sumQuantity));\r\n\t\t// }\r\n\t\t// if (inventoryItem.deltaPnl >= 0) {\r\n\t\t// \tconsole.log(\"inventoryItem.deltaPnl\", uint256(inventoryItem.deltaPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventoryItem.deltaPnl -\", uint256(-1 * inventoryItem.deltaPnl));\r\n\t\t// }\r\n\t\t// if (inventoryItem.payedPnl >= 0) {\r\n\t\t// \tconsole.log(\"inventoryItem.payedPnl\", uint256(inventoryItem.payedPnl));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"inventoryItem.payedPnl -\", uint256(-1 * inventoryItem.payedPnl));\r\n\t\t// }\r\n\t\t// if (actDivident >= 0) {\r\n\t\t// \tconsole.log(\"actDivident\", uint256(actDivident));\r\n\t\t// } else {\r\n\t\t// \tconsole.log(\"actDivident -\", uint256(-1 * actDivident));\r\n\t\t// }\r\n\r\n\t\treturn actDivident;\r\n\t}\r\n\r\n\tfunction refreshPayoutDivident(address _contract, uint256 _tokenId, address _account, int256 _amount) internal {\r\n\t\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\r\n\t\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\r\n\t\tif (!inventory.isEnabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trequire(_amount >= 0, \"Only positive amount can be payed out!\");\r\n\r\n\t\tint256 payableDivident = calcDivident(_contract, _tokenId, _account);\r\n\r\n\t\trequire(_amount <= payableDivident, \"The amount is bigger then tha payable divident!\");\r\n\r\n\t\tInventoryItem storage inventoryItem = inventory.divident[_account];\r\n\t\tinventoryItem.payedPnl = inventoryItem.payedPnl + _amount;\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenPNL/LibTokenPNLStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\nimport { IERC20 } from \"../../base/ERC20/IERC20.sol\";\r\n\r\nstruct InventoryItem {\r\n\tint256 quantity;\r\n\tint256 deltaPnl; //After calculating the act Pnl based on the quantity this is a Pnl modification factor!\r\n\tint256 payedPnl;\r\n}\r\n\r\nstruct Inventory {\r\n\tbool isEnabled;\r\n\tint256 sumQuantity;\r\n\tint256 sumAmount;\r\n\tint256 sumPnl;\r\n\t//Account - pool divident calculation\r\n\tmapping(address => InventoryItem) divident;\r\n}\r\n\r\nstruct TokenPNLStorage {\r\n\t//contract => tokenId => inventory map\r\n\t//Eg: IERC20 => 0 => inventory\r\n\t//Eg: IERC1155 => tokenId => Inventory\r\n\tmapping(address => mapping(uint256 => Inventory)) inventory;\r\n}\r\n\r\nlibrary LibTokenPNLStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.token-pnl.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (TokenPNLStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenRestriction/LibTokenRestriction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\nimport \"./LibTokenRestrictionStorage.sol\";\r\nimport \"../../base/ERC1155/base/LibERC1155.sol\";\r\nimport \"../../utils/Math.sol\";\r\n\r\nimport { IERC20 } from \"../../base/ERC20/IERC20.sol\";\r\n\r\nlibrary LibTokenRestriction {\r\n\tfunction initTokenRestriction(uint256 _tokenId, uint256 _endOfRestriction, uint256 _endOfRestrictionCalc, uint256 _timeDelta) internal {\r\n\t\t// require(block.number + 12 * _timeDelta < _endOfRestriction);\r\n\t\t// require(_endOfRestriction + 12 * _timeDelta < _endOfRestrictionCalc);\r\n\r\n\t\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\r\n\t\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\r\n\t\tif ((restriction.endOfRestrictionCalc == 0) || (restriction.endOfRestriction + 1 == restriction.endOfRestrictionCalc)) {\r\n\t\t\trestriction.endOfRestriction = _endOfRestriction;\r\n\t\t\trestriction.endOfRestrictionCalc = _endOfRestrictionCalc;\r\n\t\t\trestriction.timeDelta = _timeDelta;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calcUnrestrictedAmount(address _account, uint256 _tokenId, uint256 _amount) internal view returns (uint256) {\r\n\t\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\r\n\t\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\r\n\r\n\t\tif (restriction.endOfRestrictionCalc < block.number) {\r\n\t\t\treturn _amount;\r\n\t\t}\r\n\r\n\t\t// if (restriction.endOfRestriction < block.number) {\r\n\t\t// \treturn _amount;\r\n\t\t// }\r\n\r\n\t\tRestrictionCalc storage accRestr = restriction.restriction[_account];\r\n\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((K8-I8)/L8)*(E8-M8)/12)\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumulated)/12)\r\n\t\t// console.log(\"calcUnrestrictedAmount\");\r\n\t\t// console.log(\"account\", _account);\r\n\t\t// console.log(\"blocknumber\", block.number);\r\n\t\t// console.log(\"accRestr.time\", accRestr.time);\r\n\t\t// console.log(\"restriction.timeDelta\", restriction.timeDelta);\r\n\t\t// console.log(\"accRestr.bought\", accRestr.bought);\r\n\t\t// console.log(\"accRestr.accumulated\", accRestr.accumulated);\r\n\t\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\r\n\t\t// console.log(\"helper\", helper);\r\n\r\n\t\t//=MIN(M10+Q10;E10)-G10\r\n\t\t//=MIN(accumulated+helper;bought)-sold\r\n\t\tuint256 canSell = Math.min(accRestr.accumulated + helper, accRestr.bought) - accRestr.sold;\r\n\t\t// console.log(\"canSell\", canSell);\r\n\r\n\t\treturn canSell;\r\n\t}\r\n\r\n\tfunction checkRestriction(address _account, uint256 _tokenId, uint256 _amount) internal view {\r\n\t\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\r\n\t\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\r\n\r\n\t\tif (restriction.endOfRestrictionCalc <= block.number) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if (restriction.endOfRestriction < block.number) {\r\n\t\t// \treturn;\r\n\t\t// }\r\n\r\n\t\tRestrictionCalc storage accRestr = restriction.restriction[_account];\r\n\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((K8-I8)/L8)*(E8-M8)/12)\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumulated)/12)\r\n\t\t// console.log(\"CheckRestriction\");\r\n\t\t// console.log(\"account\", _account);\r\n\t\t// console.log(\"blocknumber\", block.number);\r\n\t\t// console.log(\"accRestr.time\", accRestr.time);\r\n\t\t// console.log(\"restriction.timeDelta\", restriction.timeDelta);\r\n\t\t// console.log(\"accRestr.bought\", accRestr.bought);\r\n\t\t// console.log(\"accRestr.accumulated\", accRestr.accumulated);\r\n\t\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\r\n\t\t// console.log(\"helper\", helper);\r\n\r\n\t\t//=MIN(M10+Q10;E10)-G10\r\n\t\t//=MIN(accumulated+helper;bought)-sold\r\n\t\tuint256 canSell = Math.min(accRestr.accumulated + helper, accRestr.bought) - accRestr.sold;\r\n\t\t// console.log(\"canSell\", canSell);\r\n\r\n\t\trequire(_amount <= canSell, \"The amount is grater then the accumlated ('sellable') amount!\");\r\n\t}\r\n\r\n\tfunction checkRestrictions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts) internal view {\r\n\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\tcheckRestriction(_account, _tokenIds[i], _amounts[i]);\r\n\t\t\tunchecked {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction recalcRestriction(address _account, uint256 _tokenId, uint256 _amount, uint8 _direction) internal {\r\n\t\t//eladható mennyiség kalkulációhoz\r\n\t\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\r\n\t\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\r\n\r\n\t\tif (restriction.endOfRestrictionCalc <= block.number) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tRestrictionCalc storage accRestr = restriction.restriction[_account];\r\n\r\n\t\tif (restriction.endOfRestriction <= block.number) {\r\n\t\t\t//valami mást kell csinálni\r\n\t\t\tif (_direction == 1) {\r\n\t\t\t\taccRestr.bought += _amount;\r\n\t\t\t\taccRestr.accumulated += _amount;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//frissíteni üzemszerűen.\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((J12-I12)/L12)*(E12-M12)/12)\r\n\t\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumlated)/12)\r\n\t\t// console.log(\"RecalcRestriction\");\r\n\t\t// console.log(\"account\", _account);\r\n\t\t// console.log(\"blocknumber\", block.number);\r\n\t\t// console.log(\"accRestr.time\", accRestr.time);\r\n\t\t// console.log(\"restriction.timeDelta\", restriction.timeDelta);\r\n\t\t// console.log(\"accRestr.bought\", accRestr.bought);\r\n\t\t// console.log(\"accRestr.accumulated\", accRestr.accumulated);\r\n\t\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\r\n\t\t// console.log(\"helper\", helper);\r\n\r\n\t\t//=MIN(M12+N12; E12)\r\n\t\t//=MIN(accumulated+helper; bought)\r\n\t\taccRestr.accumulated = Math.min(accRestr.accumulated + helper, accRestr.bought);\r\n\t\t// console.log(\"NEW accRestr.accumulated\", accRestr.accumulated);\r\n\r\n\t\t//vesz, elad\r\n\t\tif (_direction == 1) {\r\n\t\t\taccRestr.bought += _amount;\r\n\t\t} else {\r\n\t\t\taccRestr.sold += _amount;\r\n\t\t}\r\n\r\n\t\taccRestr.time = block.number;\r\n\r\n\t\t// console.log(\"NEW accRestr.bought\", accRestr.bought);\r\n\t\t// console.log(\"NEW accRestr.sold\", accRestr.sold);\r\n\t\t// console.log(\"NEW accRestr.time\", accRestr.time);\r\n\t}\r\n\r\n\tfunction recalcRestrictions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts, uint8 _direction) internal {\r\n\t\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\r\n\r\n\t\tfor (uint256 i; i < _tokenIds.length; ) {\r\n\t\t\trecalcRestriction(_account, _tokenIds[i], _amounts[i], _direction);\r\n\t\t\tunchecked {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/base/TokenRestriction/LibTokenRestrictionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { EnumerableSet } from \"../../utils/EnumerableSet.sol\";\r\n\r\nstruct RestrictionCalc {\r\n\tuint256 bought;\r\n\tuint256 sold;\r\n\tuint256 time; //blockheight * 1 000 000 000\r\n\tuint256 accumulated;\r\n}\r\n\r\nstruct Restriction {\r\n\tuint256 endOfRestriction; //if act-time is lower then endOfRestriction then only calculating the a previous data, new tokens do not restircted\r\n\tuint256 endOfRestrictionCalc; //if act-time is lower then endOfRestrictionCalc then now calculation at all\r\n\tuint256 timeDelta; //if time is blockHeight based then delta should be calculated like that. If second based then...\r\n\t//Account - restriction calculation params\r\n\tmapping(address => RestrictionCalc) restriction;\r\n}\r\n\r\nstruct TokenRestrictionStorage {\r\n\t//tokenId => restriction, every token have\r\n\tmapping(uint256 => Restriction) tokenRestriction;\r\n}\r\n\r\nlibrary LibTokenRestrictionStorage {\r\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"usmart.common.token-restriction.storage.v1\");\r\n\r\n\tfunction layout() internal pure returns (TokenRestrictionStorage storage layout_) {\r\n\t\tbytes32 position = STORAGE_SLOT;\r\n\t\tassembly {\r\n\t\t\tlayout_.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"./base/Diamond/LibDiamondStorage.sol\";\nimport { LibDiamond } from \"./base/Diamond/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n\tconstructor(address _contractOwner, address _diamondCutFacet) payable {\n\t\tLibDiamond.setDiamondAddress(address(this));\n\t\tLibDiamond.setContractOwner(_contractOwner);\n\n\t\t// Add the diamondCut external function from the diamondCutFacet\n\t\tIDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n\t\tbytes4[] memory functionSelectors = new bytes4[](1);\n\t\tfunctionSelectors[0] = IDiamondCut.diamondCut.selector;\n\t\tcut[0] = IDiamondCut.FacetCut({\n\t\t\tfacetAddress: _diamondCutFacet,\n\t\t\taction: IDiamondCut.FacetCutAction.Add,\n\t\t\tfunctionSelectors: functionSelectors\n\t\t});\n\t\tLibDiamond.diamondCut(cut, address(0), \"\");\n\t}\n\n\t// Find facet for function that is called and execute the\n\t// function if a facet is found and return any value.\n\tfallback() external payable {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\t// get facet from function selector\n\t\taddress facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\t\trequire(facet != address(0), \"Diamond: Function does not exist\");\n\t\t// Execute external function from facet using delegatecall and return any value.\n\t\tassembly {\n\t\t\t// copy function selector and any arguments\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\t// execute function call using the facet\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\t// get any return value\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\t// return any return value or error back to the caller\n\t\t\tswitch result\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\treceive() external payable {}\n}\n"
    },
    "contracts/DiamondFacets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external override {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tLibDiamond.diamondCut(_diamondCut, _init, _calldata);\n\t}\n}\n"
    },
    "contracts/DiamondFacets/DiamondEtherscanFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\r\nimport { LibDiamondEtherscan } from \"../base/Diamond/LibDiamondEtherscan.sol\";\r\n\r\ncontract DiamondEtherscanFacet {\r\n\tfunction setDummyImplementation(address _implementation) external {\r\n\t\tLibDiamond.enforceIsContractOwner();\r\n\t\tLibDiamondEtherscan._setDummyImplementation(_implementation);\r\n\t}\r\n\r\n\tfunction implementation() external view returns (address) {\r\n\t\treturn LibDiamondEtherscan._dummyImplementation();\r\n\t}\r\n}\r\n"
    },
    "contracts/DiamondFacets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../base/Diamond/LibDiamondStorage.sol\";\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n\t// Diamond Loupe Functions\n\t////////////////////////////////////////////////////////////////////\n\t/// These functions are expected to be called frequently by tools.\n\t//\n\t// struct Facet {\n\t//     address facetAddress;\n\t//     bytes4[] functionSelectors;\n\t// }\n\n\t/// @notice Gets all facets and their selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view override returns (Facet[] memory facets_) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tuint256 numFacets = ds.facetAddresses.length;\n\t\tfacets_ = new Facet[](numFacets);\n\t\tfor (uint256 i; i < numFacets; i++) {\n\t\t\taddress facetAddress_ = ds.facetAddresses[i];\n\t\t\tfacets_[i].facetAddress = facetAddress_;\n\t\t\tfacets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n\t\t}\n\t}\n\n\t/// @notice Gets all the function selectors provided by a facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tfacetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n\t}\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tfacetAddresses_ = ds.facetAddresses;\n\t}\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tfacetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n\t}\n\n\t// This implements ERC-165.\n\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\treturn ds.supportedInterfaces[_interfaceId];\n\t}\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n\tenum FacetCutAction {\n\t\tAdd,\n\t\tReplace,\n\t\tRemove\n\t}\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IDiamondEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\ninterface IDiamondEvents {\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\r\n\r\n\terror AccessDenied(bytes32 role, address account);\r\n\r\n\terror TargetedPausable__TargetedPaused();\r\n\terror TargetedPausable__NotTargetedPaused();\r\n\r\n\tevent TargetedPaused(bytes32 indexed target, address indexed account);\r\n\tevent TargetedUnpaused(bytes32 indexed target, address indexed account);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n\t/// These functions are expected to be called frequently\n\t/// by tools.\n\n\tstruct Facet {\n\t\taddress facetAddress;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Gets all facet addresses and their four byte function selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view returns (Facet[] memory facets_);\n\n\t/// @notice Gets all the function selectors supported by a specific facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view returns (address[] memory facetAddresses_);\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\ninterface IERC165 {\n\t/// @notice Query if a contract implements an interface\n\t/// @param interfaceId The interface identifier, as specified in ERC-165\n\t/// @dev Interface identification is specified in ERC-165. This function\n\t///  uses less than 30,000 gas.\n\t/// @return `true` if the contract implements `interfaceID` and\n\t///  `interfaceID` is not 0xffffffff, `false` otherwise\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\ninterface IERC173 {\r\n\t/// @dev This emits when ownership of a contract changes.\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/// @notice Get the address of the owner\r\n\t/// @return owner_ The address of the owner.\r\n\tfunction owner() external view returns (address owner_);\r\n\r\n\t/// @notice Set the address of the new owner of the contract\r\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\r\n\t/// @param _newOwner The address of the new owner of the contract\r\n\tfunction transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "contracts/upgradeInitializers/ArexaPlatformDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\nimport \"../base/Diamond/LibDiamondStorage.sol\";\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\nimport { IERC20 } from \"../base/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"../base/ERC1155/IERC1155.sol\";\nimport { IERC1155Allowance } from \"../base/ERC1155/IERC1155Allowance.sol\";\nimport { IERC1155Enumerable } from \"../base/ERC1155/IERC1155Enumerable.sol\";\nimport { IERC1155MetadataURI } from \"../base/ERC1155/IERC1155MetadataURI.sol\";\nimport { IERC1155Pausable } from \"../base/ERC1155/IERC1155Pausable.sol\";\nimport { IERC1155Receiver } from \"../base/ERC1155/IERC1155Receiver.sol\";\n\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\n\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\n\nimport { LibArexaConst } from \"../ArexaPlatform/LibArexaConst.sol\";\nimport { LibArexaPlatform } from \"../ArexaPlatform/Platform/LibArexaPlatform.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract ArexaPlatformDiamondInit is CallProtection {\n\t// You can add parameters to this function in order to pass in\n\t// data to set your own state variables\n\tfunction init(IERC20 payingToken, IERC20 arexaERC20Token, uint64 restrictionTimeDelta) external protectedCall {\n\t\tLibAccessControl._enforceIsOwner();\n\n\t\trequire(restrictionTimeDelta > 0, \"INVALID_PARAMS\");\n\n\t\t// adding ERC165 data\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n\t\tds.supportedInterfaces[type(IERC1155).interfaceId] = false;\n\t\tds.supportedInterfaces[type(IERC1155Allowance).interfaceId] = false;\n\t\tds.supportedInterfaces[type(IERC1155Enumerable).interfaceId] = false;\n\t\tds.supportedInterfaces[type(IERC1155MetadataURI).interfaceId] = false;\n\t\tds.supportedInterfaces[type(IERC1155Pausable).interfaceId] = false;\n\t\tds.supportedInterfaces[type(IERC1155Receiver).interfaceId] = false;\n\n\t\t//AccessControl\n\t\tLibAccessControl._setRoleAdmin(LibArexaConst.AREXA_ADMIN_ROLE, LibArexaConst.AREXA_ADMIN_ROLE);\n\t\tLibAccessControl._grantRole(LibArexaConst.AREXA_ADMIN_ROLE, LibAccessControl._owner());\n\n\t\tLibArexaPlatform.initialize(msg.sender, payingToken, arexaERC20Token, restrictionTimeDelta);\n\n\t\t// add your own state variables\n\t\t// EIP-2535 specifies that the `diamondCut` function takes two optional\n\t\t// arguments: address _init and bytes calldata _calldata\n\t\t// These arguments are used to execute an arbitrary function using delegatecall\n\t\t// in order to set state variables in the diamond during deployment or an upgrade\n\t\t// More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\n\t}\n}\n"
    },
    "contracts/upgradeInitializers/ArexaTokenDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { LibDiamond } from \"../base/Diamond/LibDiamond.sol\";\nimport \"../base/Diamond/LibDiamondStorage.sol\";\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\nimport { IERC20 } from \"../base/ERC20/IERC20.sol\";\n\nimport { CallProtection } from \"../base/Shared/ProtectedCall.sol\";\n\nimport { LibAccessControl } from \"../base/AccessControl/LibAccessControl.sol\";\nimport { LibERC20Base } from \"../base/ERC20/base/LibERC20Base.sol\";\nimport { LibERC20Metadata } from \"../base/ERC20/metadata/LibERC20Metadata.sol\";\nimport { LibTokenConst } from \"../base/ERC20Token/LibTokenConst.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract ArexaTokenDiamondInit is CallProtection {\n\t// You can add parameters to this function in order to pass in\n\t// data to set your own state variables\n\tfunction init(string calldata name, string calldata symbol, uint8 decimals, uint256 initialSupply) external protectedCall {\n\t\tLibAccessControl._enforceIsOwner();\n\t\trequire(bytes(LibERC20Metadata._name()).length == 0 && bytes(LibERC20Metadata._symbol()).length == 0, \"ALREADY_INITIALIZED\");\n\t\trequire(bytes(name).length != 0 && bytes(symbol).length != 0, \"INVALID_PARAMS\");\n\n\t\t// adding ERC165 data\n\t\tDiamondStorage storage ds = LibDiamondStorage.layout();\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC20).interfaceId] = false;\n\n\t\tLibERC20Metadata._setName(name);\n\t\tLibERC20Metadata._setSymbol(symbol);\n\t\tLibERC20Metadata._setDecimals(decimals);\n\n\t\t//LibAccessControl._owner();\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TOKEN_ADMIN_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.TREASURY_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.AML_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\t\tLibAccessControl._setRoleAdmin(LibTokenConst.COMPLIANCE_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\n\n\t\tLibAccessControl._grantRole(LibTokenConst.TOKEN_ADMIN_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.TREASURY_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.AML_ROLE, LibAccessControl._owner());\n\t\tLibAccessControl._grantRole(LibTokenConst.COMPLIANCE_ROLE, LibAccessControl._owner());\n\n\t\tif (initialSupply > 0) {\n\t\t\tLibERC20Base._mint(msg.sender, initialSupply);\n\t\t}\n\n\t\t// add your own state variables\n\t\t// EIP-2535 specifies that the `diamondCut` function takes two optional\n\t\t// arguments: address _init and bytes calldata _calldata\n\t\t// These arguments are used to execute an arbitrary function using delegatecall\n\t\t// in order to set state variables in the diamond during deployment or an upgrade\n\t\t// More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\n\t}\n}\n"
    },
    "contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nimport { UintUtils } from \"./UintUtils.sol\";\n\nlibrary AddressUtils {\n\tusing UintUtils for uint256;\n\n\terror AddressUtils__InsufficientBalance();\n\terror AddressUtils__NotContract();\n\terror AddressUtils__SendValueFailed();\n\n\tfunction toString(address account) internal pure returns (string memory) {\n\t\treturn uint256(uint160(account)).toHexString(20);\n\t}\n\n\tfunction isContract(address account) internal view returns (bool) {\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(account)\n\t\t}\n\t\treturn size > 0;\n\t}\n\n\tfunction sendValue(address payable account, uint256 amount) internal {\n\t\t(bool success, ) = account.call{ value: amount }(\"\");\n\t\tif (!success) revert AddressUtils__SendValueFailed();\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"AddressUtils: failed low-level call\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data, string memory error) internal returns (bytes memory) {\n\t\treturn _functionCallWithValue(target, data, 0, error);\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"AddressUtils: failed low-level call with value\");\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) internal returns (bytes memory) {\n\t\tif (value > address(this).balance) revert AddressUtils__InsufficientBalance();\n\t\treturn _functionCallWithValue(target, data, value, error);\n\t}\n\n\t/**\n\t * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n\t * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n\t * @param target recipient of call\n\t * @param gasAmount gas allowance for call\n\t * @param value native token value to include in call\n\t * @param maxCopy maximum number of bytes to copy from return data\n\t * @param data encoded call data\n\t * @return success whether call is successful\n\t * @return returnData copied return data\n\t */\n\tfunction excessivelySafeCall(\n\t\taddress target,\n\t\tuint256 gasAmount,\n\t\tuint256 value,\n\t\tuint16 maxCopy,\n\t\tbytes memory data\n\t) internal returns (bool success, bytes memory returnData) {\n\t\treturnData = new bytes(maxCopy);\n\n\t\tassembly {\n\t\t\t// execute external call via assembly to avoid automatic copying of return data\n\t\t\tsuccess := call(gasAmount, target, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\t// determine whether to limit amount of data to copy\n\t\t\tlet toCopy := returndatasize()\n\n\t\t\tif gt(toCopy, maxCopy) {\n\t\t\t\ttoCopy := maxCopy\n\t\t\t}\n\n\t\t\t// store the length of the copied bytes\n\t\t\tmstore(returnData, toCopy)\n\n\t\t\t// copy the bytes from returndata[0:toCopy]\n\t\t\treturndatacopy(add(returnData, 0x20), 0, toCopy)\n\t\t}\n\t}\n\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) private returns (bytes memory) {\n\t\tif (!isContract(target)) revert AddressUtils__NotContract();\n\n\t\t(bool success, bytes memory returnData) = target.call{ value: value }(data);\n\n\t\tif (success) {\n\t\t\treturn returnData;\n\t\t} else if (returnData.length > 0) {\n\t\t\tassembly {\n\t\t\t\tlet returnData_size := mload(returnData)\n\t\t\t\trevert(add(32, returnData), returnData_size)\n\t\t\t}\n\t\t} else {\n\t\t\trevert(error);\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\r\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\r\n */\r\nlibrary ECDSA {\r\n\terror ECDSA__InvalidS();\r\n\terror ECDSA__InvalidSignature();\r\n\terror ECDSA__InvalidSignatureLength();\r\n\terror ECDSA__InvalidV();\r\n\r\n\t/**\r\n\t * @notice recover signer of hashed message from signature\r\n\t * @param hash hashed data payload\r\n\t * @param signature signed data payload\r\n\t * @return recovered message signer\r\n\t */\r\n\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n\t\tif (signature.length != 65) revert ECDSA__InvalidSignatureLength();\r\n\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8 v;\r\n\r\n\t\tassembly {\r\n\t\t\tr := mload(add(signature, 0x20))\r\n\t\t\ts := mload(add(signature, 0x40))\r\n\t\t\tv := byte(0, mload(add(signature, 0x60)))\r\n\t\t}\r\n\r\n\t\treturn recover(hash, v, r, s);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice recover signer of hashed message from signature v, r, and s values\r\n\t * @param hash hashed data payload\r\n\t * @param v signature \"v\" value\r\n\t * @param r signature \"r\" value\r\n\t * @param s signature \"s\" value\r\n\t * @return recovered message signer\r\n\t */\r\n\tfunction recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n\t\t//\r\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n\t\t// these malleable signatures as well.\r\n\t\tif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert ECDSA__InvalidS();\r\n\t\tif (v != 27 && v != 28) revert ECDSA__InvalidV();\r\n\r\n\t\t// If the signature is valid (and not malleable), return the signer address\r\n\t\taddress signer = ecrecover(hash, v, r, s);\r\n\t\tif (signer == address(0)) revert ECDSA__InvalidSignature();\r\n\r\n\t\treturn signer;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice generate an \"Ethereum Signed Message\" in the format returned by the eth_sign JSON-RPC method\r\n\t * @param dataHash hashed data payload\r\n\t * @return signed message hash\r\n\t */\r\n\tfunction toEthSignedMessageHash(bytes32 dataHash) internal pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\r\n\t}\r\n\r\n\t/**\r\n\t * @notice generate an \"Ethereum Signed Message\" in the format returned by the eth_sign JSON-RPC method\r\n\t * @param domainSeparator EIP712 domain separator\r\n\t * @param dataHash hashed data payload\r\n\t * @return signed message hash\r\n\t */\r\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 dataHash) internal pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, dataHash));\r\n\t}\r\n}\r\n"
    },
    "contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n\terror EnumerableSet__IndexOutOfBounds();\n\n\tstruct Set {\n\t\tbytes32[] _values;\n\t\t// 1-indexed to allow 0 to signify nonexistence\n\t\tmapping(bytes32 => uint256) _indexes;\n\t}\n\n\tstruct Bytes32Set {\n\t\tSet _inner;\n\t}\n\n\tstruct AddressSet {\n\t\tSet _inner;\n\t}\n\n\tstruct UintSet {\n\t\tSet _inner;\n\t}\n\n\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n\t\treturn _at(set._inner, index);\n\t}\n\n\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\n\t}\n\n\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\t\treturn uint256(_at(set._inner, index));\n\t}\n\n\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, value);\n\t}\n\n\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(value));\n\t}\n\n\tfunction indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, value);\n\t}\n\n\tfunction indexOf(AddressSet storage set, address value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction indexOf(UintSet storage set, uint256 value) internal view returns (uint256) {\n\t\treturn _indexOf(set._inner, bytes32(value));\n\t}\n\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction length(UintSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _add(set._inner, value);\n\t}\n\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(value));\n\t}\n\n\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _remove(set._inner, value);\n\t}\n\n\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(value));\n\t}\n\n\tfunction toArray(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n\t\treturn set._inner._values;\n\t}\n\n\tfunction toArray(AddressSet storage set) internal view returns (address[] memory) {\n\t\tbytes32[] storage values = set._inner._values;\n\t\taddress[] storage array;\n\n\t\tassembly {\n\t\t\tarray.slot := values.slot\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tfunction toArray(UintSet storage set) internal view returns (uint256[] memory) {\n\t\tbytes32[] storage values = set._inner._values;\n\t\tuint256[] storage array;\n\n\t\tassembly {\n\t\t\tarray.slot := values.slot\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n\t\tif (index >= set._values.length) revert EnumerableSet__IndexOutOfBounds();\n\t\treturn set._values[index];\n\t}\n\n\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n\t\treturn set._indexes[value] != 0;\n\t}\n\n\tfunction _indexOf(Set storage set, bytes32 value) private view returns (uint256) {\n\t\tunchecked {\n\t\t\treturn set._indexes[value] - 1;\n\t\t}\n\t}\n\n\tfunction _length(Set storage set) private view returns (uint256) {\n\t\treturn set._values.length;\n\t}\n\n\tfunction _add(Set storage set, bytes32 value) private returns (bool status) {\n\t\tif (!_contains(set, value)) {\n\t\t\tset._values.push(value);\n\t\t\tset._indexes[value] = set._values.length;\n\t\t\tstatus = true;\n\t\t}\n\t}\n\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool status) {\n\t\tuint256 valueIndex = set._indexes[value];\n\n\t\tif (valueIndex != 0) {\n\t\t\tunchecked {\n\t\t\t\tbytes32 last = set._values[set._values.length - 1];\n\n\t\t\t\t// move last value to now-vacant index\n\n\t\t\t\tset._values[valueIndex - 1] = last;\n\t\t\t\tset._indexes[last] = valueIndex;\n\t\t\t}\n\t\t\t// clear last index\n\n\t\t\tset._values.pop();\n\t\t\tdelete set._indexes[value];\n\n\t\t\tstatus = true;\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\nlibrary Math {\n\t/**\n\t * @notice calculate the absolute value of a number\n\t * @param a number whose absoluve value to calculate\n\t * @return absolute value\n\t */\n\tfunction abs(int256 a) internal pure returns (uint256) {\n\t\treturn uint256(a < 0 ? -a : a);\n\t}\n\n\t/**\n\t * @notice select the greater of two numbers\n\t * @param a first number\n\t * @param b second number\n\t * @return greater number\n\t */\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a > b ? a : b;\n\t}\n\n\t/**\n\t * @notice select the lesser of two numbers\n\t * @param a first number\n\t * @param b second number\n\t * @return lesser number\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a > b ? b : a;\n\t}\n\n\t/**\n\t * @notice calculate the average of two numbers, rounded down\n\t * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n\t * @param a first number\n\t * @param b second number\n\t * @return mean value\n\t */\n\tfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\treturn (a & b) + ((a ^ b) >> 1);\n\t\t}\n\t}\n\n\t/**\n\t * @notice estimate square root of number\n\t * @dev uses Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n\t * @param x input number\n\t * @return y square root\n\t */\n\tfunction sqrt(uint256 x) internal pure returns (uint256 y) {\n\t\tuint256 z = (x + 1) >> 1;\n\t\ty = x;\n\t\twhile (z < y) {\n\t\t\ty = z;\n\t\t\tz = (x / z + z) >> 1;\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n * Copyright (C) 2024 uSmart\r\n */\r\npragma solidity ^0.8.9;\r\n\r\nimport \"../base/ERC20/IERC20.sol\";\r\nimport { AddressUtils } from \"./AddressUtils.sol\";\r\n\r\nlibrary SafeERC20 {\r\n\terror SafeERC20FailedOperation(address token);\r\n\tusing AddressUtils for address;\r\n\r\n\tfunction safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n\t\tbytes memory returndata = address(token).functionCall(abi.encodeCall(token.transferFrom, (from, to, value)));\r\n\t\tif (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n\t\t\trevert SafeERC20FailedOperation(address(token));\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/utils/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 c = a + b;\r\n\t\t\tif (c < a) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b > a) return (false, 0);\r\n\t\t\treturn (true, a - b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t\t// benefit is lost if 'b' is also tested.\r\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\t\tif (a == 0) return (true, 0);\r\n\t\t\tuint256 c = a * b;\r\n\t\t\tif (c / a != b) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a / b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a % b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a * b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {trySub}.\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b <= a, errorMessage);\r\n\t\t\treturn a - b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting with custom message when dividing by zero.\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a % b;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * Copyright (C) 2024 uSmart\n */\npragma solidity ^0.8.9;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n\terror UintUtils__InsufficientHexLength();\n\n\tbytes16 private constant HEX_SYMBOLS = \"0123456789abcdef\";\n\n\tfunction add(uint256 a, int256 b) internal pure returns (uint256) {\n\t\treturn b < 0 ? sub(a, -b) : a + uint256(b);\n\t}\n\n\tfunction sub(uint256 a, int256 b) internal pure returns (uint256) {\n\t\treturn b < 0 ? add(a, -b) : a - uint256(b);\n\t}\n\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\n\t\tbytes memory buffer = new bytes(digits);\n\n\t\twhile (value != 0) {\n\t\t\tdigits -= 1;\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\t\t\tvalue /= 10;\n\t\t}\n\n\t\treturn string(buffer);\n\t}\n\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0x00\";\n\t\t}\n\n\t\tuint256 length = 0;\n\n\t\tfor (uint256 temp = value; temp != 0; temp >>= 8) {\n\t\t\tunchecked {\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\n\t\treturn toHexString(value, length);\n\t}\n\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n\t\tbytes memory buffer = new bytes(2 * length + 2);\n\t\tbuffer[0] = \"0\";\n\t\tbuffer[1] = \"x\";\n\n\t\tunchecked {\n\t\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\n\t\t\t\tbuffer[i] = HEX_SYMBOLS[value & 0xf];\n\t\t\t\tvalue >>= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (value != 0) revert UintUtils__InsufficientHexLength();\n\n\t\treturn string(buffer);\n\t}\n}\n"
    }
  },
  "settings": {
    "viaIR": false,
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}