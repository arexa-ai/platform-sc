{
  "address": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Ownable__NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TargetedPausable__TargetedPaused",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6d72b3cb8adb0f7acd9055f74fcc6696fe027f885d30a3ffaab040779db9dc65",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
    "transactionIndex": 0,
    "gasUsed": "704934",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc3e3851d41ad3839202deb37b835b495362bc16c27d42c073a4b2b970a445fd2",
    "transactionHash": "0x6d72b3cb8adb0f7acd9055f74fcc6696fe027f885d30a3ffaab040779db9dc65",
    "logs": [],
    "blockNumber": 6,
    "cumulativeGasUsed": "704934",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "29368373a120d2797ab4b44183bb832e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TargetedPausable__TargetedPaused\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"returns\":{\"_0\":\"contract owner\"}},\"transferOwnership(address)\":{\"details\":\"Set _newOwner to address(0) to renounce any ownership.\",\"params\":{\"_newOwner\":\"The address of the new owner of the contract\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"get the ERC173 contract owner\"},\"transferOwnership(address)\":{\"notice\":\"Set the address of the new owner of the contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ArexaToken/ArexaTokenOwnershipFacet.sol\":\"ArexaTokenOwnershipFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ArexaToken/ArexaTokenOwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\n/**\\n * Copyright (C) 2023 uSmart (Andras Szabolcsi)\\n */\\npragma solidity ^0.8.9;\\n\\nimport { TokenOwnershipFacet } from \\\"../base/ERC20Diamond/TokenOwnershipFacet.sol\\\";\\n\\ncontract ArexaTokenOwnershipFacet is TokenOwnershipFacet {\\n\\tconstructor() TokenOwnershipFacet() {}\\n}\\n\",\"keccak256\":\"0xca11f854730bb7d0ef9d5565ab6d75b4adefef392d05bc8ff40328c558749ec3\",\"license\":\"UNLICENCED\"},\"contracts/base/AccessControl/LibAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibAccessControlStorage.sol\\\";\\r\\n\\r\\nimport { IERC173 } from \\\"../../interfaces/IERC173.sol\\\";\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport { UintUtils } from \\\"../../utils/UintUtils.sol\\\";\\r\\nimport { AddressUtils } from \\\"../../utils/AddressUtils.sol\\\";\\r\\n\\r\\nlibrary LibAccessControl {\\r\\n\\tusing EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\tusing UintUtils for uint256;\\r\\n\\tusing AddressUtils for address;\\r\\n\\r\\n\\terror Ownable__NotOwner();\\r\\n\\terror Ownable__NotTransitiveOwner();\\r\\n\\r\\n\\terror AccessDenied(bytes32 role, address account);\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\r\\n\\tbytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n\\tfunction _setOwner(address _newOwner) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\taddress previousOwner = acls.owner;\\r\\n\\t\\tacls.owner = _newOwner;\\r\\n\\r\\n\\t\\t//Init DEFAULT_ADMIN_ROLE to _newOwner\\r\\n\\t\\tLibAccessControl._grantRole(LibAccessControl.DEFAULT_ADMIN_ROLE, _newOwner);\\r\\n\\r\\n\\t\\temit OwnershipTransferred(previousOwner, _newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _owner() internal view returns (address owner_) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\towner_ = acls.owner;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transitiveOwner() internal view returns (address owner_) {\\r\\n\\t\\towner_ = LibAccessControl._owner();\\r\\n\\r\\n\\t\\twhile (owner_.isContract()) {\\r\\n\\t\\t\\ttry IERC173(owner_).owner() returns (address transitiveOwner) {\\r\\n\\t\\t\\t\\towner_ = transitiveOwner;\\r\\n\\t\\t\\t} catch {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _owner(), \\\"Not owner!\\\");\\r\\n\\t\\tif (msg.sender != _owner()) {\\r\\n\\t\\t\\trevert Ownable__NotOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsTransitiveOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _transitiveOwner(), \\\"Not transitive owner!\\\");\\r\\n\\t\\tif (msg.sender != _transitiveOwner()) {\\r\\n\\t\\t\\trevert Ownable__NotTransitiveOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice assign role to given account\\r\\n\\t * @param _role role to assign\\r\\n\\t * @param _account recipient of role assignment\\r\\n\\t */\\r\\n\\tfunction _grantRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\tacls.roles[acls.owner][_role].members.add(_account);\\r\\n\\t\\t\\temit RoleGranted(acls.owner, _role, _account, msg.sender);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice unassign role from given account\\r\\n\\t * @param _role role to unassign\\r\\n\\t * @param _account account to revokeAccessControlStorage\\r\\n\\t */\\r\\n\\tfunction _revokeRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\t// require(_role != LibAccessControl.DEFAULT_ADMIN_ROLE && _account != acls.owner);\\r\\n\\t\\tacls.roles[acls.owner][_role].members.remove(_account);\\r\\n\\t\\temit RoleRevoked(acls.owner, _role, _account, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice relinquish role\\r\\n\\t * @param _role role to relinquish\\r\\n\\t */\\r\\n\\tfunction _renounceRole(bytes32 _role) internal {\\r\\n\\t\\t_revokeRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query one of the accounts that have role of the project\\r\\n\\t * @dev WARNING: When using _getProjectRoleMember and _getProjectRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _index index of role member\\r\\n\\t */\\r\\n\\tfunction _getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.at(_index);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query the number of accounts that have role.\\r\\n\\t * @dev WARNING: When using _getRoleMember and _getRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _getRoleMemberCount(address, bytes32 _role) internal view returns (uint256) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.length();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query whether role is assigned to account\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account account to query\\r\\n\\t * @return bool whether role is assigned to account\\r\\n\\t */\\r\\n\\tfunction _hasRole(bytes32 _role, address _account) internal view returns (bool) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.contains(_account);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if sender does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role) internal view {\\r\\n\\t\\t_checkRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if given account does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role, address _account) internal view {\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\trevert AccessDenied({ role: _role, account: _account });\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query admin role for given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @return admin role\\r\\n\\t */\\r\\n\\tfunction _getRoleAdmin(bytes32 _role) internal view returns (bytes32) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].adminRole;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set role as admin role\\r\\n\\t * @param _role role to set\\r\\n\\t * @param _adminRole admin role to set\\r\\n\\t */\\r\\n\\tfunction _setRoleAdmin(bytes32 _role, bytes32 _adminRole) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tbytes32 previousAdminRole = _getRoleAdmin(_role);\\r\\n\\t\\tacls.roles[acls.owner][_role].adminRole = _adminRole;\\r\\n\\t\\temit RoleAdminChanged(acls.owner, _role, previousAdminRole, _adminRole);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x2c0da263bd49a5c7a6d1a9d8866bbe5936b43f3ee39bf2c9dc4600d7045b49e9\",\"license\":\"MIT\"},\"contracts/base/AccessControl/LibAccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport \\\"./RoleData.sol\\\";\\r\\n\\r\\nstruct AccessControllStorage {\\r\\n\\t//owner => role => adminRole, members mapping\\r\\n\\taddress owner;\\r\\n\\tmapping(address => mapping(bytes32 => RoleData)) roles;\\r\\n}\\r\\n\\r\\nlibrary LibAccessControlStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.access-control.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (AccessControllStorage storage acls_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tacls_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9ae5597ade94391b4f367368b5e6f5b4d15dce1e430e217ee5e549a652c8eb8b\",\"license\":\"MIT\"},\"contracts/base/AccessControl/ModifierRole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibAccessControl } from \\\"./LibAccessControl.sol\\\";\\r\\n\\r\\nabstract contract ModifierRole {\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyTransitiveOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsTransitiveOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRole(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(role);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRoleAdmin(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(LibAccessControl._getRoleAdmin(role));\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9a5f770772e3b447a47bbcacd0afe131c78c98bc87219da9e3dfe10a261ad64e\",\"license\":\"MIT\"},\"contracts/base/AccessControl/RoleData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct RoleData {\\r\\n\\tbytes32 adminRole;\\r\\n\\tEnumerableSet.AddressSet members;\\r\\n}\\r\\n\",\"keccak256\":\"0xf9d7eaf459b09f21c482e9b9df5b5c99572095e79174de3621f5ec9e32413ac7\",\"license\":\"MIT\"},\"contracts/base/Diamond/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport \\\"./LibDiamondStorage.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\nimport { LibAccessControl } from \\\"../AccessControl/LibAccessControl.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n\\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n\\tfunction setDiamondAddress(address _diamondAddress) internal {\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(ds.diamondAddress == address(0), \\\"Already initialized!\\\");\\n\\t\\tds.diamondAddress = _diamondAddress;\\n\\t}\\n\\n\\tfunction getDiamondAddress() internal view returns (address) {\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\treturn ds.diamondAddress;\\n\\t}\\n\\n\\tfunction setContractOwner(address _newOwner) internal {\\n\\t\\tLibAccessControl._setOwner(_newOwner);\\n\\t}\\n\\n\\tfunction enforceIsContractOwner() internal view {\\n\\t\\tLibAccessControl._enforceIsOwner();\\n\\t}\\n\\n\\t// Internal function version of diamondCut\\n\\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n\\t\\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n\\t\\t\\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n\\t\\t\\tif (action == IDiamondCut.FacetCutAction.Add) {\\n\\t\\t\\t\\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\\n\\t\\t\\t\\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\\n\\t\\t\\t\\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit DiamondCut(_diamondCut, _init, _calldata);\\n\\t\\tinitializeDiamondCut(_init, _calldata);\\n\\t}\\n\\n\\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n\\t\\t// add new facet address if it does not exist\\n\\t\\tif (selectorPosition == 0) {\\n\\t\\t\\taddFacet(ds, _facetAddress);\\n\\t\\t}\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\trequire(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\n\\t\\t\\tselectorPosition++;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n\\t\\t// add new facet address if it does not exist\\n\\t\\tif (selectorPosition == 0) {\\n\\t\\t\\taddFacet(ds, _facetAddress);\\n\\t\\t}\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\trequire(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\n\\t\\t\\tselectorPosition++;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\t// if function does not exist then do nothing and return\\n\\t\\trequire(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n\\t\\tenforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n\\t\\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n\\t\\tds.facetAddresses.push(_facetAddress);\\n\\t}\\n\\n\\tfunction addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n\\t\\tds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n\\t\\tds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n\\t}\\n\\n\\tfunction removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n\\t\\t// an immutable function is a function defined directly in a diamond\\n\\t\\trequire(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n\\t\\t// replace selector with last selector, then delete last selector\\n\\t\\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n\\t\\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n\\t\\t// if not the same then replace _selector with lastSelector\\n\\t\\tif (selectorPosition != lastSelectorPosition) {\\n\\t\\t\\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n\\t\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n\\t\\t\\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n\\t\\t}\\n\\t\\t// delete the last selector\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n\\t\\tdelete ds.selectorToFacetAndPosition[_selector];\\n\\n\\t\\t// if no more selectors for facet address then delete the facet address\\n\\t\\tif (lastSelectorPosition == 0) {\\n\\t\\t\\t// replace facet address with last facet address and delete last facet address\\n\\t\\t\\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n\\t\\t\\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n\\t\\t\\tif (facetAddressPosition != lastFacetAddressPosition) {\\n\\t\\t\\t\\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n\\t\\t\\t\\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n\\t\\t\\t\\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n\\t\\t\\t}\\n\\t\\t\\tds.facetAddresses.pop();\\n\\t\\t\\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n\\t\\tif (_init == address(0)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tenforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\t\\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\\n\\t\\tif (!success) {\\n\\t\\t\\tif (error.length > 0) {\\n\\t\\t\\t\\t// bubble up error\\n\\t\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(error)\\n\\t\\t\\t\\t\\trevert(add(32, error), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert InitializationFunctionReverted(_init, _calldata);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n\\t\\tuint256 contractSize;\\n\\t\\tassembly {\\n\\t\\t\\tcontractSize := extcodesize(_contract)\\n\\t\\t}\\n\\t\\trequire(contractSize > 0, _errorMessage);\\n\\t}\\n}\\n\",\"keccak256\":\"0x5f15f134edd02ce19fb55ce2c33ef634b5766bef24fee8dcc69f53d04bfe5219\",\"license\":\"MIT\"},\"contracts/base/Diamond/LibDiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct FacetAddressAndPosition {\\r\\n\\taddress facetAddress;\\r\\n\\tuint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\r\\n}\\r\\n\\r\\nstruct FacetFunctionSelectors {\\r\\n\\tbytes4[] functionSelectors;\\r\\n\\tuint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\r\\n}\\r\\n\\r\\nstruct DiamondStorage {\\r\\n\\taddress diamondAddress;\\r\\n\\t// maps function selector to the facet address and\\r\\n\\t// the position of the selector in the facetFunctionSelectors.selectors array\\r\\n\\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\r\\n\\t// maps facet addresses to function selectors\\r\\n\\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\r\\n\\t// facet addresses\\r\\n\\taddress[] facetAddresses;\\r\\n\\t// Used to query if a contract implements an interface.\\r\\n\\t// Used to implement ERC-165.\\r\\n\\tmapping(bytes4 => bool) supportedInterfaces;\\r\\n\\t//the whole diamond is paused or not\\r\\n\\tbool paused;\\r\\n}\\r\\n\\r\\nlibrary LibDiamondStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.contracts.diamond.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (DiamondStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x13a60db83059255e32f692e0508aaa9af49568a363e3aae233ae80aab0c75098\",\"license\":\"MIT\"},\"contracts/base/ERC20Diamond/TokenOwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\nimport { Ownable } from \\\"../Ownable/Ownable.sol\\\";\\nimport { LibAccessControl } from \\\"../AccessControl/LibAccessControl.sol\\\";\\n\\nimport { LibTokenConst } from \\\"../ERC20Token/LibTokenConst.sol\\\";\\n\\n//import { ModifierRole } from \\\"../base/AccessControl/ModifierRole.sol\\\";\\nimport { ModifierPausable } from \\\"../TargetedPausable/ModifierPausable.sol\\\";\\nimport { CallProtection } from \\\"../Shared/ProtectedCall.sol\\\";\\n\\nabstract contract TokenOwnershipFacet is Ownable, CallProtection, ModifierPausable {\\n\\tfunction transferOwnership(address _newOwner) public override protectedCall whenNotPaused(LibTokenConst.FULL) onlyOwner {\\n\\t\\tsuper.transferOwnership(_newOwner);\\n\\n\\t\\tLibAccessControl._setRoleAdmin(LibTokenConst.TOKEN_ADMIN_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\\n\\t\\tLibAccessControl._setRoleAdmin(LibTokenConst.TREASURY_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\\n\\t\\tLibAccessControl._setRoleAdmin(LibTokenConst.AML_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\\n\\t\\tLibAccessControl._setRoleAdmin(LibTokenConst.COMPLIANCE_ROLE, LibTokenConst.TOKEN_ADMIN_ROLE);\\n\\n\\t\\tLibAccessControl._grantRole(LibTokenConst.TOKEN_ADMIN_ROLE, LibAccessControl._owner());\\n\\t\\tLibAccessControl._grantRole(LibTokenConst.TREASURY_ROLE, LibAccessControl._owner());\\n\\t\\tLibAccessControl._grantRole(LibTokenConst.AML_ROLE, LibAccessControl._owner());\\n\\t\\tLibAccessControl._grantRole(LibTokenConst.COMPLIANCE_ROLE, LibAccessControl._owner());\\n\\t}\\n}\\n\",\"keccak256\":\"0x99022ec902d2432a4f604ced0d32bb7a8149bbca5db6809792af8fda5446ce9f\",\"license\":\"MIT\"},\"contracts/base/ERC20Token/LibTokenConst.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibTokenConst {\\r\\n\\t//Pausable\\r\\n\\tbytes32 public constant FULL = 0x00;\\r\\n\\r\\n\\t//Roles\\r\\n\\tbytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\\\"TOKEN_ADMIN_ROLE\\\");\\r\\n\\tbytes32 public constant TREASURY_ROLE = keccak256(\\\"TREASURY_ROLE\\\");\\r\\n\\tbytes32 public constant AML_ROLE = keccak256(\\\"AML_ROLE\\\");\\r\\n\\tbytes32 public constant COMPLIANCE_ROLE = keccak256(\\\"COMPLIANCE_ROLE\\\");\\r\\n\\r\\n\\t//BlackWhite lists, these accounts could not send/receive token\\r\\n\\tbytes32 public constant SENDER_BL = keccak256(\\\"SENDER_BLACKLIST\\\");\\r\\n\\tbytes32 public constant RECIPIENT_BL = keccak256(\\\"RECIPIENT_BLACKLIST\\\");\\r\\n\\r\\n\\t//FreeFee WhiteList, these accounts don't pay fee...\\r\\n\\tbytes32 public constant SENDER_FREE_FEE_WL = keccak256(\\\"SENDER_FREE_FEE_WHITELIST\\\");\\r\\n\\tbytes32 public constant RECIPIENT_FREE_FEE_WL = keccak256(\\\"RECIPIENT_FREE_FEE_WHITELIST\\\");\\r\\n}\\r\\n\",\"keccak256\":\"0x8a47f5923aab3b5eb5608f4ae833920797fae1b776e5c7a1ea97e4cb362d746c\",\"license\":\"MIT\"},\"contracts/base/Ownable/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { IERC173 } from \\\"../../interfaces/IERC173.sol\\\";\\r\\nimport { LibAccessControl } from \\\"../AccessControl/LibAccessControl.sol\\\";\\r\\nimport { AddressUtils } from \\\"../../utils/AddressUtils.sol\\\";\\r\\n\\r\\nimport { ModifierRole } from \\\"../AccessControl/ModifierRole.sol\\\";\\r\\n\\r\\nabstract contract Ownable is IERC173, ModifierRole {\\r\\n\\tusing AddressUtils for address;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice get the ERC173 contract owner\\r\\n\\t * @return contract owner\\r\\n\\t */\\r\\n\\tfunction owner() external view returns (address) {\\r\\n\\t\\treturn LibAccessControl._owner();\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Set the address of the new owner of the contract\\r\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n\\t/// @param _newOwner The address of the new owner of the contract\\r\\n\\tfunction transferOwnership(address _newOwner) public virtual onlyOwner {\\r\\n\\t\\tLibAccessControl._setOwner(_newOwner);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x6add209aea3bc33550d1ee3e26eb133b7b45c29b2dbdd89355383813d68a2d31\",\"license\":\"MIT\"},\"contracts/base/Shared/ProtectedCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibDiamond } from \\\"../Diamond/LibDiamond.sol\\\";\\r\\n\\r\\ncontract CallProtection {\\r\\n\\tmodifier protectedCall() {\\r\\n\\t\\trequire(address(this) == LibDiamond.getDiamondAddress(), \\\"NOT_ALLOWED\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xc15612f2411ec779b6036b14a4495f5b402178ebb0864d727cb5cc01f917b798\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/LibTargetedPausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibTargetedPausableStorage.sol\\\";\\r\\n\\r\\nlibrary LibTargetedPausable {\\r\\n\\terror TargetedPausable__TargetedPaused();\\r\\n\\terror TargetedPausable__NotTargetedPaused();\\r\\n\\r\\n\\t//target: what was paused\\r\\n\\t//account: the operator who is paused the target\\r\\n\\tevent TargetedPaused(bytes32 indexed target, address indexed account);\\r\\n\\r\\n\\t//target: what was unpaused\\r\\n\\t//account: the operator who is unpaused the target\\r\\n\\tevent TargetedUnpaused(bytes32 target, address indexed account);\\r\\n\\r\\n\\tfunction _whenNotPaused(bytes32 _target) internal view {\\r\\n\\t\\tif (LibTargetedPausable._paused(_target)) revert TargetedPausable__TargetedPaused();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _whenPaused(bytes32 _target) internal view {\\r\\n\\t\\tif (!LibTargetedPausable._paused(_target)) revert TargetedPausable__NotTargetedPaused();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _paused(bytes32 _target) internal view returns (bool paused_) {\\r\\n\\t\\tpaused_ = LibTargetedPausableStorage.layout().paused[_target];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _pause(bytes32 _target, address _operator) internal {\\r\\n\\t\\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\\r\\n\\t\\tif (ps.paused[_target]) revert TargetedPausable__TargetedPaused();\\r\\n\\t\\tps.paused[_target] = true;\\r\\n\\t\\temit TargetedPaused(_target, _operator);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _unpause(bytes32 _target, address _operator) internal {\\r\\n\\t\\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\\r\\n\\t\\tif (!ps.paused[_target]) revert TargetedPausable__NotTargetedPaused();\\r\\n\\t\\tps.paused[_target] = false;\\r\\n\\t\\tdelete ps.paused[_target];\\r\\n\\t\\temit TargetedUnpaused(_target, _operator);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x29bcbce5b5f8cc5c33029d568ffb11b1bc807cfb0ad22acd6c69b79acf2b3d8b\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/LibTargetedPausableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct TargetedPausableStorage {\\r\\n\\tmapping(bytes32 => bool) paused;\\r\\n}\\r\\n\\r\\nlibrary LibTargetedPausableStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.targeted-pausable.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (TargetedPausableStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x3a8d48db3da71fb9df91fe855d32fb0dd634556499739c6c277842021c92438d\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/ModifierPausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibTargetedPausable } from \\\"./LibTargetedPausable.sol\\\";\\r\\n\\r\\nabstract contract ModifierPausable {\\r\\n\\t//\\r\\n\\tmodifier whenNotPaused(bytes32 target) {\\r\\n\\t\\tLibTargetedPausable._whenNotPaused(target);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier whenPaused(bytes32 target) {\\r\\n\\t\\tLibTargetedPausable._whenPaused(target);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x5a08a624e6849e716dc267f8e1d6f171594ab1560bd0097b11d2f9950276a9a9\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n\\tenum FacetCutAction {\\n\\t\\tAdd,\\n\\t\\tReplace,\\n\\t\\tRemove\\n\\t}\\n\\t// Add=0, Replace=1, Remove=2\\n\\n\\tstruct FacetCut {\\n\\t\\taddress facetAddress;\\n\\t\\tFacetCutAction action;\\n\\t\\tbytes4[] functionSelectors;\\n\\t}\\n\\n\\t/// @notice Add/replace/remove any number of functions and optionally execute\\n\\t///         a function with delegatecall\\n\\t/// @param _diamondCut Contains the facet addresses and function selectors\\n\\t/// @param _init The address of the contract or facet to execute _calldata\\n\\t/// @param _calldata A function call, including function selector and arguments\\n\\t///                  _calldata is executed with delegatecall on _init\\n\\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n\\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x38a0a1b25fb31d2205f5aaedb20f1788a38bc4147a4a20ee030335b7cdbaa0c4\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\ninterface IERC173 {\\r\\n\\t/// @dev This emits when ownership of a contract changes.\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/// @notice Get the address of the owner\\r\\n\\t/// @return owner_ The address of the owner.\\r\\n\\tfunction owner() external view returns (address owner_);\\r\\n\\r\\n\\t/// @notice Set the address of the new owner of the contract\\r\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n\\t/// @param _newOwner The address of the new owner of the contract\\r\\n\\tfunction transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x92d3f89d7077a9b49b41fd69091ce8f8c1b20c5695dafbbb4b13e7b6f0d6e6ef\",\"license\":\"MIT\"},\"contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\nimport { UintUtils } from \\\"./UintUtils.sol\\\";\\n\\nlibrary AddressUtils {\\n\\tusing UintUtils for uint256;\\n\\n\\terror AddressUtils__InsufficientBalance();\\n\\terror AddressUtils__NotContract();\\n\\terror AddressUtils__SendValueFailed();\\n\\n\\tfunction toString(address account) internal pure returns (string memory) {\\n\\t\\treturn uint256(uint160(account)).toHexString(20);\\n\\t}\\n\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size > 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable account, uint256 amount) internal {\\n\\t\\t(bool success, ) = account.call{ value: amount }(\\\"\\\");\\n\\t\\tif (!success) revert AddressUtils__SendValueFailed();\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"AddressUtils: failed low-level call\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data, string memory error) internal returns (bytes memory) {\\n\\t\\treturn _functionCallWithValue(target, data, 0, error);\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"AddressUtils: failed low-level call with value\\\");\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) internal returns (bytes memory) {\\n\\t\\tif (value > address(this).balance) revert AddressUtils__InsufficientBalance();\\n\\t\\treturn _functionCallWithValue(target, data, value, error);\\n\\t}\\n\\n\\t/**\\n\\t * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n\\t * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n\\t * @param target recipient of call\\n\\t * @param gasAmount gas allowance for call\\n\\t * @param value native token value to include in call\\n\\t * @param maxCopy maximum number of bytes to copy from return data\\n\\t * @param data encoded call data\\n\\t * @return success whether call is successful\\n\\t * @return returnData copied return data\\n\\t */\\n\\tfunction excessivelySafeCall(\\n\\t\\taddress target,\\n\\t\\tuint256 gasAmount,\\n\\t\\tuint256 value,\\n\\t\\tuint16 maxCopy,\\n\\t\\tbytes memory data\\n\\t) internal returns (bool success, bytes memory returnData) {\\n\\t\\treturnData = new bytes(maxCopy);\\n\\n\\t\\tassembly {\\n\\t\\t\\t// execute external call via assembly to avoid automatic copying of return data\\n\\t\\t\\tsuccess := call(gasAmount, target, value, add(data, 0x20), mload(data), 0, 0)\\n\\n\\t\\t\\t// determine whether to limit amount of data to copy\\n\\t\\t\\tlet toCopy := returndatasize()\\n\\n\\t\\t\\tif gt(toCopy, maxCopy) {\\n\\t\\t\\t\\ttoCopy := maxCopy\\n\\t\\t\\t}\\n\\n\\t\\t\\t// store the length of the copied bytes\\n\\t\\t\\tmstore(returnData, toCopy)\\n\\n\\t\\t\\t// copy the bytes from returndata[0:toCopy]\\n\\t\\t\\treturndatacopy(add(returnData, 0x20), 0, toCopy)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) private returns (bytes memory) {\\n\\t\\tif (!isContract(target)) revert AddressUtils__NotContract();\\n\\n\\t\\t(bool success, bytes memory returnData) = target.call{ value: value }(data);\\n\\n\\t\\tif (success) {\\n\\t\\t\\treturn returnData;\\n\\t\\t} else if (returnData.length > 0) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet returnData_size := mload(returnData)\\n\\t\\t\\t\\trevert(add(32, returnData), returnData_size)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\trevert(error);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0xe7dec1466e1e606394a35fa837156a011f761ac6a6e9097b89a348fad1f2f692\",\"license\":\"MIT\"},\"contracts/utils/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n\\terror EnumerableSet__IndexOutOfBounds();\\n\\n\\tstruct Set {\\n\\t\\tbytes32[] _values;\\n\\t\\t// 1-indexed to allow 0 to signify nonexistence\\n\\t\\tmapping(bytes32 => uint256) _indexes;\\n\\t}\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index);\\n\\t}\\n\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index))));\\n\\t}\\n\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index));\\n\\t}\\n\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, value);\\n\\t}\\n\\n\\tfunction indexOf(AddressSet storage set, address value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction indexOf(UintSet storage set, uint256 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction toArray(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n\\t\\treturn set._inner._values;\\n\\t}\\n\\n\\tfunction toArray(AddressSet storage set) internal view returns (address[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\taddress[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction toArray(UintSet storage set) internal view returns (uint256[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\tuint256[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\tif (index >= set._values.length) revert EnumerableSet__IndexOutOfBounds();\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\tfunction _indexOf(Set storage set, bytes32 value) private view returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn set._indexes[value] - 1;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\tset._indexes[value] = set._values.length;\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\n\\t\\tif (valueIndex != 0) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tbytes32 last = set._values[set._values.length - 1];\\n\\n\\t\\t\\t\\t// move last value to now-vacant index\\n\\n\\t\\t\\t\\tset._values[valueIndex - 1] = last;\\n\\t\\t\\t\\tset._indexes[last] = valueIndex;\\n\\t\\t\\t}\\n\\t\\t\\t// clear last index\\n\\n\\t\\t\\tset._values.pop();\\n\\t\\t\\tdelete set._indexes[value];\\n\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x442e9fd507b659095a1fec47f8cb6e540442165217af05db1afa2703a993e038\",\"license\":\"MIT\"},\"contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n\\terror UintUtils__InsufficientHexLength();\\n\\n\\tbytes16 private constant HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n\\tfunction add(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? sub(a, -b) : a + uint256(b);\\n\\t}\\n\\n\\tfunction sub(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? add(a, -b) : a - uint256(b);\\n\\t}\\n\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0x00\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 length = 0;\\n\\n\\t\\tfor (uint256 temp = value; temp != 0; temp >>= 8) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tlength++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn toHexString(value, length);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n\\t\\tbytes memory buffer = new bytes(2 * length + 2);\\n\\t\\tbuffer[0] = \\\"0\\\";\\n\\t\\tbuffer[1] = \\\"x\\\";\\n\\n\\t\\tunchecked {\\n\\t\\t\\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\\n\\t\\t\\t\\tbuffer[i] = HEX_SYMBOLS[value & 0xf];\\n\\t\\t\\t\\tvalue >>= 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\",\"keccak256\":\"0xec4d89ef08ad402e0c8b30b8e4e135991009384aa72f0cb7c6165721ec5050e2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610bd2806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638da5cb5b1461003b578063f2fde38b14610059575b600080fd5b610043610075565b6040516100509190610a72565b60405180910390f35b610073600480360381019061006e9190610abe565b610084565b005b600061007f6102e7565b905090565b61008c61031f565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146100f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100f090610b48565b60405180910390fd5b6000801b61010681610357565b61010e61039a565b61011782610408565b6101417f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd68061041c565b61018b7fe1dcbdb91df27212a29bc27177c840cf2f819ecf2187432e1fac86c2dd5dfca97f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b6101d57f17a5b61e4b0039a783f3595ae6d0f558a99530d7aec98ec66e68de70cfe985397f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b61021f7f442a94f1a1fac79af32856af2a64f63648cfa2ef3b98610a5bb7cbec4cee69857f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b6102507f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661024b6102e7565b61052d565b6102817fe1dcbdb91df27212a29bc27177c840cf2f819ecf2187432e1fac86c2dd5dfca961027c6102e7565b61052d565b6102b27f17a5b61e4b0039a783f3595ae6d0f558a99530d7aec98ec66e68de70cfe985396102ad6102e7565b61052d565b6102e37f442a94f1a1fac79af32856af2a64f63648cfa2ef3b98610a5bb7cbec4cee69856102de6102e7565b61052d565b5050565b6000806102f2610679565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60008061032a6106a6565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b610360816106d3565b15610397576040517f2d0a436a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b6103a26102e7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610406576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b61041061039a565b61041981610706565b50565b6000610426610679565b90506000610433846107ea565b9050828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008681526020019081526020016000206000018190555082818360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f723017596f662d5bad698223ec9b9d90c19cd1ebc637a2ad7ef27b3d9f85f79c8760405161051f9190610b81565b60405180910390a450505050565b6000610537610679565b90506105438383610879565b610674576105d2828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600086815260200190815260200160002060010161091a90919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff168260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fc1ddb807f72f9e732ef6f32805c68a3b77ca377c0e141fe3bcaf19fe667f35348660405161066b9190610b81565b60405180910390a45b505050565b6000807f746c6723185dc95a8925081faed89cbd4670299390e2ebfb0b9c3e755e204ef490508091505090565b6000807ff72346055b4d7224c7ec19860d22963ca622fbb313761bfba507c1a3aeedf37290508091505090565b60006106dd61094a565b600001600083815260200190815260200160002060009054906101000a900460ff169050919050565b6000610710610679565b905060008160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050828260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061078b6000801b8461052d565b8273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b6000806107f5610679565b90508060010160008260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600084815260200190815260200160002060000154915050919050565b600080610884610679565b9050610911838260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002060010161097790919063ffffffff16565b91505092915050565b6000610942836000018373ffffffffffffffffffffffffffffffffffffffff1660001b6109a7565b905092915050565b6000807fe8ceb94393aac3e803a9d4b376f7c5ffd7e8b6caab697212a5360c34a283caa190508091505090565b600061099f836000018373ffffffffffffffffffffffffffffffffffffffff1660001b610a0e565b905092915050565b60006109b38383610a0e565b610a085782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b600080836001016000848152602001908152602001600020541415905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610a5c82610a31565b9050919050565b610a6c81610a51565b82525050565b6000602082019050610a876000830184610a63565b92915050565b600080fd5b610a9b81610a51565b8114610aa657600080fd5b50565b600081359050610ab881610a92565b92915050565b600060208284031215610ad457610ad3610a8d565b5b6000610ae284828501610aa9565b91505092915050565b600082825260208201905092915050565b7f4e4f545f414c4c4f574544000000000000000000000000000000000000000000600082015250565b6000610b32600b83610aeb565b9150610b3d82610afc565b602082019050919050565b60006020820190508181036000830152610b6181610b25565b9050919050565b6000819050919050565b610b7b81610b68565b82525050565b6000602082019050610b966000830184610b72565b9291505056fea2646970667358221220ab49fc2e7216715b030940ca13a18119c38da30b00d894a4e7850d59f04de50764736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80638da5cb5b1461003b578063f2fde38b14610059575b600080fd5b610043610075565b6040516100509190610a72565b60405180910390f35b610073600480360381019061006e9190610abe565b610084565b005b600061007f6102e7565b905090565b61008c61031f565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146100f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100f090610b48565b60405180910390fd5b6000801b61010681610357565b61010e61039a565b61011782610408565b6101417f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd68061041c565b61018b7fe1dcbdb91df27212a29bc27177c840cf2f819ecf2187432e1fac86c2dd5dfca97f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b6101d57f17a5b61e4b0039a783f3595ae6d0f558a99530d7aec98ec66e68de70cfe985397f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b61021f7f442a94f1a1fac79af32856af2a64f63648cfa2ef3b98610a5bb7cbec4cee69857f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661041c565b6102507f9e262e26e9d5bf97da5c389e15529a31bb2b13d89967a4f6eab01792567d5fd661024b6102e7565b61052d565b6102817fe1dcbdb91df27212a29bc27177c840cf2f819ecf2187432e1fac86c2dd5dfca961027c6102e7565b61052d565b6102b27f17a5b61e4b0039a783f3595ae6d0f558a99530d7aec98ec66e68de70cfe985396102ad6102e7565b61052d565b6102e37f442a94f1a1fac79af32856af2a64f63648cfa2ef3b98610a5bb7cbec4cee69856102de6102e7565b61052d565b5050565b6000806102f2610679565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60008061032a6106a6565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b610360816106d3565b15610397576040517f2d0a436a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b6103a26102e7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610406576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b61041061039a565b61041981610706565b50565b6000610426610679565b90506000610433846107ea565b9050828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008681526020019081526020016000206000018190555082818360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f723017596f662d5bad698223ec9b9d90c19cd1ebc637a2ad7ef27b3d9f85f79c8760405161051f9190610b81565b60405180910390a450505050565b6000610537610679565b90506105438383610879565b610674576105d2828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600086815260200190815260200160002060010161091a90919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff168260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fc1ddb807f72f9e732ef6f32805c68a3b77ca377c0e141fe3bcaf19fe667f35348660405161066b9190610b81565b60405180910390a45b505050565b6000807f746c6723185dc95a8925081faed89cbd4670299390e2ebfb0b9c3e755e204ef490508091505090565b6000807ff72346055b4d7224c7ec19860d22963ca622fbb313761bfba507c1a3aeedf37290508091505090565b60006106dd61094a565b600001600083815260200190815260200160002060009054906101000a900460ff169050919050565b6000610710610679565b905060008160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050828260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061078b6000801b8461052d565b8273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b6000806107f5610679565b90508060010160008260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600084815260200190815260200160002060000154915050919050565b600080610884610679565b9050610911838260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002060010161097790919063ffffffff16565b91505092915050565b6000610942836000018373ffffffffffffffffffffffffffffffffffffffff1660001b6109a7565b905092915050565b6000807fe8ceb94393aac3e803a9d4b376f7c5ffd7e8b6caab697212a5360c34a283caa190508091505090565b600061099f836000018373ffffffffffffffffffffffffffffffffffffffff1660001b610a0e565b905092915050565b60006109b38383610a0e565b610a085782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b600080836001016000848152602001908152602001600020541415905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610a5c82610a31565b9050919050565b610a6c81610a51565b82525050565b6000602082019050610a876000830184610a63565b92915050565b600080fd5b610a9b81610a51565b8114610aa657600080fd5b50565b600081359050610ab881610a92565b92915050565b600060208284031215610ad457610ad3610a8d565b5b6000610ae284828501610aa9565b91505092915050565b600082825260208201905092915050565b7f4e4f545f414c4c4f574544000000000000000000000000000000000000000000600082015250565b6000610b32600b83610aeb565b9150610b3d82610afc565b602082019050919050565b60006020820190508181036000830152610b6181610b25565b9050919050565b6000819050919050565b610b7b81610b68565b82525050565b6000602082019050610b966000830184610b72565b9291505056fea2646970667358221220ab49fc2e7216715b030940ca13a18119c38da30b00d894a4e7850d59f04de50764736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "returns": {
          "_0": "contract owner"
        }
      },
      "transferOwnership(address)": {
        "details": "Set _newOwner to address(0) to renounce any ownership.",
        "params": {
          "_newOwner": "The address of the new owner of the contract"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "owner()": {
        "notice": "get the ERC173 contract owner"
      },
      "transferOwnership(address)": {
        "notice": "Set the address of the new owner of the contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}