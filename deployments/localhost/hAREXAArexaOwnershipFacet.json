{
  "address": "0x67d269191c92Caf3cD7723F116c85e6E9bf55933",
  "abi": [
    {
      "inputs": [],
      "name": "Ownable__NotOwner",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x711f1b70fcc9c52415e3f07db118172db396b441fa37884b314b76f0f9386370",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x67d269191c92Caf3cD7723F116c85e6E9bf55933",
    "transactionIndex": 0,
    "gasUsed": "513837",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7902e7dcdb597234455f725ac07c6364adee34023bad7eb01d320619ab759612",
    "transactionHash": "0x711f1b70fcc9c52415e3f07db118172db396b441fa37884b314b76f0f9386370",
    "logs": [],
    "blockNumber": 36,
    "cumulativeGasUsed": "513837",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "29368373a120d2797ab4b44183bb832e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"returns\":{\"_0\":\"contract owner\"}},\"transferOwnership(address)\":{\"details\":\"Set _newOwner to address(0) to renounce any ownership.\",\"params\":{\"_newOwner\":\"The address of the new owner of the contract\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"get the ERC173 contract owner\"},\"transferOwnership(address)\":{\"notice\":\"Set the address of the new owner of the contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ArexaPlatform/ArexaOwnershipFacet.sol\":\"ArexaOwnershipFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ArexaPlatform/ArexaOwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 AREXA\\n */\\npragma solidity ^0.8.9;\\n\\nimport { Ownable } from \\\"../base/Ownable/Ownable.sol\\\";\\nimport { LibAccessControl } from \\\"../base/AccessControl/LibAccessControl.sol\\\";\\n\\nimport { LibArexaConst } from \\\"./LibArexaConst.sol\\\";\\n\\ncontract ArexaOwnershipFacet is Ownable {\\n\\tfunction transferOwnership(address _newOwner) public override onlyOwner {\\n\\t\\tsuper.transferOwnership(_newOwner);\\n\\n\\t\\tLibAccessControl._setRoleAdmin(LibArexaConst.AREXA_ADMIN_ROLE, LibArexaConst.AREXA_ADMIN_ROLE);\\n\\n\\t\\tLibAccessControl._grantRole(LibArexaConst.AREXA_ADMIN_ROLE, LibAccessControl._owner());\\n\\t\\t//LibAccessControl._grantRole(LibArexaConst.AREXA_ADMIN_ROLE, LibAccessControl._owner());\\n\\t}\\n}\\n\",\"keccak256\":\"0xc7532fda81f68a7f0cc7e67fd41aec9985c4062b37927c48174e2ec55fa422dd\",\"license\":\"MIT\"},\"contracts/ArexaPlatform/LibArexaConst.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\r\\n/**\\r\\n * Copyright (C) 2023 AREXA\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibArexaConst {\\r\\n\\t//\\r\\n\\t//Pausable\\r\\n\\tbytes32 public constant FULL = 0x00;\\r\\n\\tbytes32 public constant SUBSCR1_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.SUBSCR1_TOKEN_TYPE));\\r\\n\\tbytes32 public constant SUBSCR2_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.SUBSCR2_TOKEN_TYPE));\\r\\n\\tbytes32 public constant TRADER_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.TRADER_TOKEN_ID));\\r\\n\\tbytes32 public constant AREXA_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.AREXA_TOKEN_ID));\\r\\n\\tbytes32 public constant MAGIC_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.MAGIC_TOKEN_ID));\\r\\n\\r\\n\\t//Roles\\r\\n\\tbytes32 public constant AREXA_ADMIN_ROLE = keccak256(\\\"AREXA_ADMIN_ROLE\\\");\\r\\n\\t//bytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\\\"AREXA_TOKEN_ADMIN_ROLE\\\");\\r\\n\\t//bytes32 public constant TREASURY_ROLE = keccak256(\\\"AREXA_TREASURY_ROLE\\\");\\r\\n\\r\\n\\t//BlackWhite lists\\r\\n\\tbytes32 public constant MAGIC100_FIRST_BUYER = keccak256(\\\"MAGIC100_FIRST_BUYER\\\"); //WhiteList\\r\\n\\r\\n\\t//TokenIDs:\\r\\n\\tuint256 public constant SUBSCR1_TOKEN_TYPE = 100000000; //Tier 1, every month\\r\\n\\tuint256 public constant SUBSCR2_TOKEN_TYPE = 200000000; //Tier 2, every month\\r\\n\\tuint256 public constant TRADER_TOKEN_ID = 300000000; //Tier 3, unlimited, always mint\\r\\n\\tuint256 public constant AREXA_TOKEN_ID = 400000000; //Tier 4, 100000000 piece\\r\\n\\tuint256 public constant MAGIC_TOKEN_ID = 500000000; //Tier 5, 100 piece\\r\\n\\r\\n\\t//AREXA TOKEN POOL TYPES:\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_INVESTOR = 1; //35M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_AREXAINC = 2; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_MARKETING = 3; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_DEVELOPMENT = 4; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_RESERVED = 5; //50M\\r\\n}\\r\\n\",\"keccak256\":\"0xeedce13c6edc52af9ce86c36b4801a16333d56ea490e6d264c4b02a8d6aa3341\",\"license\":\"UNLICENCED\"},\"contracts/base/AccessControl/LibAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibAccessControlStorage.sol\\\";\\r\\n\\r\\nimport { IERC173 } from \\\"../../interfaces/IERC173.sol\\\";\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport { UintUtils } from \\\"../../utils/UintUtils.sol\\\";\\r\\nimport { AddressUtils } from \\\"../../utils/AddressUtils.sol\\\";\\r\\n\\r\\nlibrary LibAccessControl {\\r\\n\\tusing EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\tusing UintUtils for uint256;\\r\\n\\tusing AddressUtils for address;\\r\\n\\r\\n\\terror Ownable__NotOwner();\\r\\n\\terror Ownable__NotTransitiveOwner();\\r\\n\\r\\n\\terror AccessDenied(bytes32 role, address account);\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\r\\n\\tbytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n\\tfunction _setOwner(address _newOwner) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\taddress previousOwner = acls.owner;\\r\\n\\t\\tacls.owner = _newOwner;\\r\\n\\r\\n\\t\\t//Init DEFAULT_ADMIN_ROLE to _newOwner\\r\\n\\t\\tLibAccessControl._grantRole(LibAccessControl.DEFAULT_ADMIN_ROLE, _newOwner);\\r\\n\\r\\n\\t\\temit OwnershipTransferred(previousOwner, _newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _owner() internal view returns (address owner_) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\towner_ = acls.owner;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transitiveOwner() internal view returns (address owner_) {\\r\\n\\t\\towner_ = LibAccessControl._owner();\\r\\n\\r\\n\\t\\twhile (owner_.isContract()) {\\r\\n\\t\\t\\ttry IERC173(owner_).owner() returns (address transitiveOwner) {\\r\\n\\t\\t\\t\\towner_ = transitiveOwner;\\r\\n\\t\\t\\t} catch {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _owner(), \\\"Not owner!\\\");\\r\\n\\t\\tif (msg.sender != _owner()) {\\r\\n\\t\\t\\trevert Ownable__NotOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsTransitiveOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _transitiveOwner(), \\\"Not transitive owner!\\\");\\r\\n\\t\\tif (msg.sender != _transitiveOwner()) {\\r\\n\\t\\t\\trevert Ownable__NotTransitiveOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice assign role to given account\\r\\n\\t * @param _role role to assign\\r\\n\\t * @param _account recipient of role assignment\\r\\n\\t */\\r\\n\\tfunction _grantRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\tacls.roles[acls.owner][_role].members.add(_account);\\r\\n\\t\\t\\temit RoleGranted(acls.owner, _role, _account, msg.sender);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice unassign role from given account\\r\\n\\t * @param _role role to unassign\\r\\n\\t * @param _account account to revokeAccessControlStorage\\r\\n\\t */\\r\\n\\tfunction _revokeRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\t// require(_role != LibAccessControl.DEFAULT_ADMIN_ROLE && _account != acls.owner);\\r\\n\\t\\tacls.roles[acls.owner][_role].members.remove(_account);\\r\\n\\t\\temit RoleRevoked(acls.owner, _role, _account, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice relinquish role\\r\\n\\t * @param _role role to relinquish\\r\\n\\t */\\r\\n\\tfunction _renounceRole(bytes32 _role) internal {\\r\\n\\t\\t_revokeRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query one of the accounts that have role of the project\\r\\n\\t * @dev WARNING: When using _getProjectRoleMember and _getProjectRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _index index of role member\\r\\n\\t */\\r\\n\\tfunction _getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.at(_index);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query the number of accounts that have role.\\r\\n\\t * @dev WARNING: When using _getRoleMember and _getRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _getRoleMemberCount(address, bytes32 _role) internal view returns (uint256) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.length();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query whether role is assigned to account\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account account to query\\r\\n\\t * @return bool whether role is assigned to account\\r\\n\\t */\\r\\n\\tfunction _hasRole(bytes32 _role, address _account) internal view returns (bool) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.contains(_account);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if sender does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role) internal view {\\r\\n\\t\\t_checkRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if given account does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role, address _account) internal view {\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\trevert AccessDenied({ role: _role, account: _account });\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query admin role for given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @return admin role\\r\\n\\t */\\r\\n\\tfunction _getRoleAdmin(bytes32 _role) internal view returns (bytes32) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].adminRole;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set role as admin role\\r\\n\\t * @param _role role to set\\r\\n\\t * @param _adminRole admin role to set\\r\\n\\t */\\r\\n\\tfunction _setRoleAdmin(bytes32 _role, bytes32 _adminRole) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tbytes32 previousAdminRole = _getRoleAdmin(_role);\\r\\n\\t\\tacls.roles[acls.owner][_role].adminRole = _adminRole;\\r\\n\\t\\temit RoleAdminChanged(acls.owner, _role, previousAdminRole, _adminRole);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x2c0da263bd49a5c7a6d1a9d8866bbe5936b43f3ee39bf2c9dc4600d7045b49e9\",\"license\":\"MIT\"},\"contracts/base/AccessControl/LibAccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport \\\"./RoleData.sol\\\";\\r\\n\\r\\nstruct AccessControllStorage {\\r\\n\\t//owner => role => adminRole, members mapping\\r\\n\\taddress owner;\\r\\n\\tmapping(address => mapping(bytes32 => RoleData)) roles;\\r\\n}\\r\\n\\r\\nlibrary LibAccessControlStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.access-control.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (AccessControllStorage storage acls_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tacls_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9ae5597ade94391b4f367368b5e6f5b4d15dce1e430e217ee5e549a652c8eb8b\",\"license\":\"MIT\"},\"contracts/base/AccessControl/ModifierRole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibAccessControl } from \\\"./LibAccessControl.sol\\\";\\r\\n\\r\\nabstract contract ModifierRole {\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyTransitiveOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsTransitiveOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRole(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(role);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRoleAdmin(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(LibAccessControl._getRoleAdmin(role));\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9a5f770772e3b447a47bbcacd0afe131c78c98bc87219da9e3dfe10a261ad64e\",\"license\":\"MIT\"},\"contracts/base/AccessControl/RoleData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct RoleData {\\r\\n\\tbytes32 adminRole;\\r\\n\\tEnumerableSet.AddressSet members;\\r\\n}\\r\\n\",\"keccak256\":\"0xf9d7eaf459b09f21c482e9b9df5b5c99572095e79174de3621f5ec9e32413ac7\",\"license\":\"MIT\"},\"contracts/base/Ownable/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { IERC173 } from \\\"../../interfaces/IERC173.sol\\\";\\r\\nimport { LibAccessControl } from \\\"../AccessControl/LibAccessControl.sol\\\";\\r\\nimport { AddressUtils } from \\\"../../utils/AddressUtils.sol\\\";\\r\\n\\r\\nimport { ModifierRole } from \\\"../AccessControl/ModifierRole.sol\\\";\\r\\n\\r\\nabstract contract Ownable is IERC173, ModifierRole {\\r\\n\\tusing AddressUtils for address;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice get the ERC173 contract owner\\r\\n\\t * @return contract owner\\r\\n\\t */\\r\\n\\tfunction owner() external view returns (address) {\\r\\n\\t\\treturn LibAccessControl._owner();\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Set the address of the new owner of the contract\\r\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n\\t/// @param _newOwner The address of the new owner of the contract\\r\\n\\tfunction transferOwnership(address _newOwner) public virtual onlyOwner {\\r\\n\\t\\tLibAccessControl._setOwner(_newOwner);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x6add209aea3bc33550d1ee3e26eb133b7b45c29b2dbdd89355383813d68a2d31\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\ninterface IERC173 {\\r\\n\\t/// @dev This emits when ownership of a contract changes.\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/// @notice Get the address of the owner\\r\\n\\t/// @return owner_ The address of the owner.\\r\\n\\tfunction owner() external view returns (address owner_);\\r\\n\\r\\n\\t/// @notice Set the address of the new owner of the contract\\r\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n\\t/// @param _newOwner The address of the new owner of the contract\\r\\n\\tfunction transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x92d3f89d7077a9b49b41fd69091ce8f8c1b20c5695dafbbb4b13e7b6f0d6e6ef\",\"license\":\"MIT\"},\"contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\nimport { UintUtils } from \\\"./UintUtils.sol\\\";\\n\\nlibrary AddressUtils {\\n\\tusing UintUtils for uint256;\\n\\n\\terror AddressUtils__InsufficientBalance();\\n\\terror AddressUtils__NotContract();\\n\\terror AddressUtils__SendValueFailed();\\n\\n\\tfunction toString(address account) internal pure returns (string memory) {\\n\\t\\treturn uint256(uint160(account)).toHexString(20);\\n\\t}\\n\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size > 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable account, uint256 amount) internal {\\n\\t\\t(bool success, ) = account.call{ value: amount }(\\\"\\\");\\n\\t\\tif (!success) revert AddressUtils__SendValueFailed();\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"AddressUtils: failed low-level call\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data, string memory error) internal returns (bytes memory) {\\n\\t\\treturn _functionCallWithValue(target, data, 0, error);\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"AddressUtils: failed low-level call with value\\\");\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) internal returns (bytes memory) {\\n\\t\\tif (value > address(this).balance) revert AddressUtils__InsufficientBalance();\\n\\t\\treturn _functionCallWithValue(target, data, value, error);\\n\\t}\\n\\n\\t/**\\n\\t * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n\\t * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n\\t * @param target recipient of call\\n\\t * @param gasAmount gas allowance for call\\n\\t * @param value native token value to include in call\\n\\t * @param maxCopy maximum number of bytes to copy from return data\\n\\t * @param data encoded call data\\n\\t * @return success whether call is successful\\n\\t * @return returnData copied return data\\n\\t */\\n\\tfunction excessivelySafeCall(\\n\\t\\taddress target,\\n\\t\\tuint256 gasAmount,\\n\\t\\tuint256 value,\\n\\t\\tuint16 maxCopy,\\n\\t\\tbytes memory data\\n\\t) internal returns (bool success, bytes memory returnData) {\\n\\t\\treturnData = new bytes(maxCopy);\\n\\n\\t\\tassembly {\\n\\t\\t\\t// execute external call via assembly to avoid automatic copying of return data\\n\\t\\t\\tsuccess := call(gasAmount, target, value, add(data, 0x20), mload(data), 0, 0)\\n\\n\\t\\t\\t// determine whether to limit amount of data to copy\\n\\t\\t\\tlet toCopy := returndatasize()\\n\\n\\t\\t\\tif gt(toCopy, maxCopy) {\\n\\t\\t\\t\\ttoCopy := maxCopy\\n\\t\\t\\t}\\n\\n\\t\\t\\t// store the length of the copied bytes\\n\\t\\t\\tmstore(returnData, toCopy)\\n\\n\\t\\t\\t// copy the bytes from returndata[0:toCopy]\\n\\t\\t\\treturndatacopy(add(returnData, 0x20), 0, toCopy)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) private returns (bytes memory) {\\n\\t\\tif (!isContract(target)) revert AddressUtils__NotContract();\\n\\n\\t\\t(bool success, bytes memory returnData) = target.call{ value: value }(data);\\n\\n\\t\\tif (success) {\\n\\t\\t\\treturn returnData;\\n\\t\\t} else if (returnData.length > 0) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet returnData_size := mload(returnData)\\n\\t\\t\\t\\trevert(add(32, returnData), returnData_size)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\trevert(error);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0xe7dec1466e1e606394a35fa837156a011f761ac6a6e9097b89a348fad1f2f692\",\"license\":\"MIT\"},\"contracts/utils/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n\\terror EnumerableSet__IndexOutOfBounds();\\n\\n\\tstruct Set {\\n\\t\\tbytes32[] _values;\\n\\t\\t// 1-indexed to allow 0 to signify nonexistence\\n\\t\\tmapping(bytes32 => uint256) _indexes;\\n\\t}\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index);\\n\\t}\\n\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index))));\\n\\t}\\n\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index));\\n\\t}\\n\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, value);\\n\\t}\\n\\n\\tfunction indexOf(AddressSet storage set, address value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction indexOf(UintSet storage set, uint256 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction toArray(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n\\t\\treturn set._inner._values;\\n\\t}\\n\\n\\tfunction toArray(AddressSet storage set) internal view returns (address[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\taddress[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction toArray(UintSet storage set) internal view returns (uint256[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\tuint256[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\tif (index >= set._values.length) revert EnumerableSet__IndexOutOfBounds();\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\tfunction _indexOf(Set storage set, bytes32 value) private view returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn set._indexes[value] - 1;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\tset._indexes[value] = set._values.length;\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\n\\t\\tif (valueIndex != 0) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tbytes32 last = set._values[set._values.length - 1];\\n\\n\\t\\t\\t\\t// move last value to now-vacant index\\n\\n\\t\\t\\t\\tset._values[valueIndex - 1] = last;\\n\\t\\t\\t\\tset._indexes[last] = valueIndex;\\n\\t\\t\\t}\\n\\t\\t\\t// clear last index\\n\\n\\t\\t\\tset._values.pop();\\n\\t\\t\\tdelete set._indexes[value];\\n\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x442e9fd507b659095a1fec47f8cb6e540442165217af05db1afa2703a993e038\",\"license\":\"MIT\"},\"contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n\\terror UintUtils__InsufficientHexLength();\\n\\n\\tbytes16 private constant HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n\\tfunction add(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? sub(a, -b) : a + uint256(b);\\n\\t}\\n\\n\\tfunction sub(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? add(a, -b) : a - uint256(b);\\n\\t}\\n\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0x00\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 length = 0;\\n\\n\\t\\tfor (uint256 temp = value; temp != 0; temp >>= 8) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tlength++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn toHexString(value, length);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n\\t\\tbytes memory buffer = new bytes(2 * length + 2);\\n\\t\\tbuffer[0] = \\\"0\\\";\\n\\t\\tbuffer[1] = \\\"x\\\";\\n\\n\\t\\tunchecked {\\n\\t\\t\\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\\n\\t\\t\\t\\tbuffer[i] = HEX_SYMBOLS[value & 0xf];\\n\\t\\t\\t\\tvalue >>= 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\",\"keccak256\":\"0xec4d89ef08ad402e0c8b30b8e4e135991009384aa72f0cb7c6165721ec5050e2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610859806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638da5cb5b1461003b578063f2fde38b14610059575b600080fd5b610043610075565b6040516100509190610776565b60405180910390f35b610073600480360381019061006e91906107c2565b610084565b005b600061007f6100f3565b905090565b61008c61012b565b61009581610199565b6100bf7f72a415ccbbed7752b009b01c3fad0a1694ff64e2a51c65a309c0517cd732d2d1806101ad565b6100f07f72a415ccbbed7752b009b01c3fad0a1694ff64e2a51c65a309c0517cd732d2d16100eb6100f3565b6102be565b50565b6000806100fe61040a565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6101336100f3565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610197576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6101a161012b565b6101aa81610437565b50565b60006101b761040a565b905060006101c48461051b565b9050828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008681526020019081526020016000206000018190555082818360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f723017596f662d5bad698223ec9b9d90c19cd1ebc637a2ad7ef27b3d9f85f79c876040516102b09190610808565b60405180910390a450505050565b60006102c861040a565b90506102d483836105aa565b61040557610363828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600086815260200190815260200160002060010161064b90919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff168260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fc1ddb807f72f9e732ef6f32805c68a3b77ca377c0e141fe3bcaf19fe667f3534866040516103fc9190610808565b60405180910390a45b505050565b6000807f746c6723185dc95a8925081faed89cbd4670299390e2ebfb0b9c3e755e204ef490508091505090565b600061044161040a565b905060008160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050828260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506104bc6000801b846102be565b8273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b60008061052661040a565b90508060010160008260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600084815260200190815260200160002060000154915050919050565b6000806105b561040a565b9050610642838260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002060010161067b90919063ffffffff16565b91505092915050565b6000610673836000018373ffffffffffffffffffffffffffffffffffffffff1660001b6106ab565b905092915050565b60006106a3836000018373ffffffffffffffffffffffffffffffffffffffff1660001b610712565b905092915050565b60006106b78383610712565b61070c5782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b600080836001016000848152602001908152602001600020541415905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061076082610735565b9050919050565b61077081610755565b82525050565b600060208201905061078b6000830184610767565b92915050565b600080fd5b61079f81610755565b81146107aa57600080fd5b50565b6000813590506107bc81610796565b92915050565b6000602082840312156107d8576107d7610791565b5b60006107e6848285016107ad565b91505092915050565b6000819050919050565b610802816107ef565b82525050565b600060208201905061081d60008301846107f9565b9291505056fea2646970667358221220920e2432b1e41e8542f9ef60582688931ab402228e5020e718a1e97736d4b25964736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80638da5cb5b1461003b578063f2fde38b14610059575b600080fd5b610043610075565b6040516100509190610776565b60405180910390f35b610073600480360381019061006e91906107c2565b610084565b005b600061007f6100f3565b905090565b61008c61012b565b61009581610199565b6100bf7f72a415ccbbed7752b009b01c3fad0a1694ff64e2a51c65a309c0517cd732d2d1806101ad565b6100f07f72a415ccbbed7752b009b01c3fad0a1694ff64e2a51c65a309c0517cd732d2d16100eb6100f3565b6102be565b50565b6000806100fe61040a565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6101336100f3565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610197576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6101a161012b565b6101aa81610437565b50565b60006101b761040a565b905060006101c48461051b565b9050828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008681526020019081526020016000206000018190555082818360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f723017596f662d5bad698223ec9b9d90c19cd1ebc637a2ad7ef27b3d9f85f79c876040516102b09190610808565b60405180910390a450505050565b60006102c861040a565b90506102d483836105aa565b61040557610363828260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600086815260200190815260200160002060010161064b90919063ffffffff16565b503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff168260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167fc1ddb807f72f9e732ef6f32805c68a3b77ca377c0e141fe3bcaf19fe667f3534866040516103fc9190610808565b60405180910390a45b505050565b6000807f746c6723185dc95a8925081faed89cbd4670299390e2ebfb0b9c3e755e204ef490508091505090565b600061044161040a565b905060008160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050828260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506104bc6000801b846102be565b8273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b60008061052661040a565b90508060010160008260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600084815260200190815260200160002060000154915050919050565b6000806105b561040a565b9050610642838260010160008460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002060010161067b90919063ffffffff16565b91505092915050565b6000610673836000018373ffffffffffffffffffffffffffffffffffffffff1660001b6106ab565b905092915050565b60006106a3836000018373ffffffffffffffffffffffffffffffffffffffff1660001b610712565b905092915050565b60006106b78383610712565b61070c5782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b600080836001016000848152602001908152602001600020541415905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061076082610735565b9050919050565b61077081610755565b82525050565b600060208201905061078b6000830184610767565b92915050565b600080fd5b61079f81610755565b81146107aa57600080fd5b50565b6000813590506107bc81610796565b92915050565b6000602082840312156107d8576107d7610791565b5b60006107e6848285016107ad565b91505092915050565b6000819050919050565b610802816107ef565b82525050565b600060208201905061081d60008301846107f9565b9291505056fea2646970667358221220920e2432b1e41e8542f9ef60582688931ab402228e5020e718a1e97736d4b25964736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "returns": {
          "_0": "contract owner"
        }
      },
      "transferOwnership(address)": {
        "details": "Set _newOwner to address(0) to renounce any ownership.",
        "params": {
          "_newOwner": "The address of the new owner of the contract"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "owner()": {
        "notice": "get the ERC173 contract owner"
      },
      "transferOwnership(address)": {
        "notice": "Set the address of the new owner of the contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}