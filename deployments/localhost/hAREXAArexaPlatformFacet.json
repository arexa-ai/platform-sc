{
  "address": "0xa82fF9aFd8f496c3d6ac40E2a0F282E47488CFc9",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "LibERC1155__ArrayLengthMismatch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__BalanceQueryZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__ERC1155ReceiverNotImplemented",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__ERC1155ReceiverRejected",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__MintToZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__NotOwnerOrApproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__NotOwnerOrApprovedLimit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__TransferExceedsBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LibERC1155__TransferToZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TargetedPausable__TargetedPaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AMOUNT_VALUE_TYPE",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_POOL_AREXAINC",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_POOL_DEVELOPMENT",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_POOL_INVESTOR",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_POOL_MARKETING",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "AREXA_TOKEN_POOL_RESERVED",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAGIC_TOKEN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "QUANTITY_VALUE_TYPE",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SUBSCR1_TOKEN_TYPE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SUBSCR2_TOKEN_TYPE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TRADER_TOKEN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "value",
          "type": "uint128"
        },
        {
          "internalType": "uint8",
          "name": "valueType",
          "type": "uint8"
        }
      ],
      "name": "buyArexaToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        }
      ],
      "name": "buyEdgeSubscription",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "buyMagic100Token",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        }
      ],
      "name": "buyOracleSubscription",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        }
      ],
      "name": "buySubscription",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "value",
          "type": "uint128"
        },
        {
          "internalType": "uint8",
          "name": "valueType",
          "type": "uint8"
        }
      ],
      "name": "buyTraderToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        }
      ],
      "name": "calcSubscriptionPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenType",
          "type": "uint256"
        }
      ],
      "name": "getCurrentSubscriptionTokenId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb636a6e9fc3e17e11e3c0217e6c569a242d1d7adb5e7a6d4043f2fabee47598d",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xa82fF9aFd8f496c3d6ac40E2a0F282E47488CFc9",
    "transactionIndex": 0,
    "gasUsed": "4076501",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4219c2aa77f9aa531a81f144ca9d0534f4d47fbf0aca5b3550454c5f2a41c7ce",
    "transactionHash": "0xb636a6e9fc3e17e11e3c0217e6c569a242d1d7adb5e7a6d4043f2fabee47598d",
    "logs": [],
    "blockNumber": 41,
    "cumulativeGasUsed": "4076501",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b12d345c59f84dda28723c3187bf3edc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LibERC1155__ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__BalanceQueryZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__ERC1155ReceiverNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__ERC1155ReceiverRejected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__NotOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__NotOwnerOrApprovedLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__TransferExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LibERC1155__TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TargetedPausable__TargetedPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AMOUNT_VALUE_TYPE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_POOL_AREXAINC\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_POOL_DEVELOPMENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_POOL_INVESTOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_POOL_MARKETING\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AREXA_TOKEN_POOL_RESERVED\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAGIC_TOKEN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUANTITY_VALUE_TYPE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBSCR1_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBSCR2_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADER_TOKEN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"valueType\",\"type\":\"uint8\"}],\"name\":\"buyArexaToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"}],\"name\":\"buyEdgeSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMagic100Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"}],\"name\":\"buyOracleSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"}],\"name\":\"buySubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"valueType\",\"type\":\"uint8\"}],\"name\":\"buyTraderToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"}],\"name\":\"calcSubscriptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getCurrentSubscriptionTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ArexaPlatform/ArexaPlatformFacet.sol\":\"ArexaPlatformFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ArexaPlatform/ArexaPlatformFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\r\\n/**\\r\\n * Copyright (C) 2023 AREXA\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibBlackWhiteList } from \\\"../base/BlackWhiteList/LibBlackWhiteList.sol\\\";\\r\\n\\r\\nimport { LibArexaPlatform } from \\\"./Platform/LibArexaPlatform.sol\\\";\\r\\nimport { LibERC1155 } from \\\"../base/ERC1155/base/LibERC1155.sol\\\";\\r\\n\\r\\nimport { CallProtection } from \\\"../base/Shared/ProtectedCall.sol\\\";\\r\\nimport { ModifierRole } from \\\"../base/AccessControl/ModifierRole.sol\\\";\\r\\nimport { ModifierPausable } from \\\"../base/TargetedPausable/ModifierPausable.sol\\\";\\r\\nimport { LibArexaConst } from \\\"./LibArexaConst.sol\\\";\\r\\n\\r\\ncontract ArexaPlatformFacet is CallProtection, ModifierRole, ModifierPausable {\\r\\n\\tconstructor() {}\\r\\n\\r\\n\\tuint256 public constant SUBSCR1_TOKEN_TYPE = LibArexaConst.SUBSCR1_TOKEN_TYPE; //Tier 1, every month\\r\\n\\tuint256 public constant SUBSCR2_TOKEN_TYPE = LibArexaConst.SUBSCR2_TOKEN_TYPE; //Tier 2, every month\\r\\n\\tuint256 public constant TRADER_TOKEN_ID = LibArexaConst.TRADER_TOKEN_ID; //Tier 3, unlimited, always mint\\r\\n\\tuint256 public constant AREXA_TOKEN_ID = LibArexaConst.AREXA_TOKEN_ID; //Tier 4, 100000000 piece\\r\\n\\tuint256 public constant MAGIC_TOKEN_ID = LibArexaConst.MAGIC_TOKEN_ID; //Tier 5, 100 piece\\r\\n\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_INVESTOR = LibArexaConst.AREXA_TOKEN_POOL_INVESTOR;\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_AREXAINC = LibArexaConst.AREXA_TOKEN_POOL_AREXAINC;\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_MARKETING = LibArexaConst.AREXA_TOKEN_POOL_MARKETING;\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_DEVELOPMENT = LibArexaConst.AREXA_TOKEN_POOL_DEVELOPMENT;\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_RESERVED = LibArexaConst.AREXA_TOKEN_POOL_RESERVED;\\r\\n\\r\\n\\tuint8 public constant AMOUNT_VALUE_TYPE = LibArexaPlatform.AMOUNT_VALUE_TYPE;\\r\\n\\tuint8 public constant QUANTITY_VALUE_TYPE = LibArexaPlatform.QUANTITY_VALUE_TYPE;\\r\\n\\r\\n\\tfunction getCurrentSubscriptionTokenId(uint256 tokenType) external view protectedCall returns (uint256) {\\r\\n\\t\\treturn LibArexaPlatform.getCurrentSubscriptionTokenId(tokenType);\\r\\n\\t}\\r\\n\\r\\n\\tfunction calcSubscriptionPrice(uint256 tokenId, uint32 quantity) external view protectedCall returns (uint256) {\\r\\n\\t\\treturn LibArexaPlatform.calcSubscriptionPrice(tokenId, quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buySubscription(uint256 tokenId, uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier1 Oracle or Tier2 Edge\\r\\n\\t\\t//Price: variable USDT/piece, based on algorithm\\r\\n\\t\\t//Quantity: 1 per account\\r\\n\\t\\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\\r\\n\\t\\t// require(balance == 0, \\\"Only 1 token can be bought per account!\\\");\\r\\n\\t\\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyOracleSubscription(uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier1 Oracle\\r\\n\\t\\t//SUBSCR1_TOKEN_TYPE\\r\\n\\t\\t//Price: variable USDT/piece, based on algorithm\\r\\n\\t\\t//Quantity: 1 per account\\r\\n\\t\\tuint256 tokenId = LibArexaPlatform.getCurrentSubscriptionTokenId(SUBSCR1_TOKEN_TYPE);\\r\\n\\t\\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\\r\\n\\t\\t// require(balance == 0, \\\"Only 1 token can be bought per account!\\\");\\r\\n\\t\\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyEdgeSubscription(uint32 quantity) external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier2 Edge\\r\\n\\t\\t//SUBSCR2_TOKEN_TYPE\\r\\n\\t\\t//Price: variable USDT/piece, based on algorithm\\r\\n\\t\\t//Quantity: 1 per account\\r\\n\\t\\tuint256 tokenId = LibArexaPlatform.getCurrentSubscriptionTokenId(SUBSCR2_TOKEN_TYPE);\\r\\n\\t\\t// uint256 balance = LibERC1155.balanceOf(msg.sender, tokenId);\\r\\n\\t\\t// require(balance == 1, \\\"Only 1 token can be bought per account!\\\");\\r\\n\\t\\tLibArexaPlatform.buySubscription(tokenId, msg.sender, quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyTraderToken(uint128 value, uint8 valueType) external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier3 Singularity\\r\\n\\t\\t//TRADER_TOKEN\\r\\n\\t\\t//Price: 1.0 USDT/piece\\r\\n\\t\\t//Quantity: No limit to buy\\r\\n\\t\\t//valueType: 0 is amount, 1 is quantity\\r\\n\\t\\tLibArexaPlatform.buyTraderToken(msg.sender, msg.sender, value, valueType);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyArexaToken(uint128 value, uint8 valueType) external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier4\\r\\n\\t\\t//AREXA_TOKEN\\r\\n\\t\\t//Price: 0.1 USDT/piece\\r\\n\\t\\t//Quantity: No limit to buy\\r\\n\\t\\t//valueType: 0 is amount, 1 is quantity\\r\\n\\t\\tLibArexaPlatform.buyArexaToken(msg.sender, value, valueType);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyMagic100Token() external protectedCall whenNotPaused(LibArexaConst.FULL) {\\r\\n\\t\\t//Tier5\\r\\n\\t\\t//MAGIC_TOKEN_ID\\r\\n\\t\\t//Price: 100.0 USDT/piece\\r\\n\\t\\t//Quantity: 1\\r\\n\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tLibBlackWhiteList._getAccountBlackWhiteList(LibArexaConst.MAGIC100_FIRST_BUYER, msg.sender),\\r\\n\\t\\t\\t\\\"Only an approved account can buy the Magic token\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tLibBlackWhiteList._setAccountBlackWhiteList(LibArexaConst.MAGIC100_FIRST_BUYER, msg.sender, false);\\r\\n\\r\\n\\t\\tuint256 balance = LibERC1155.balanceOf(msg.sender, LibArexaConst.MAGIC_TOKEN_ID);\\r\\n\\t\\trequire(balance == 0, \\\"Only 1 Magic token can be bought now!\\\");\\r\\n\\r\\n\\t\\tLibArexaPlatform.buyMagic100Token(msg.sender);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xc9574570e94208bca20ffde63450bc67033b2ab95febb496c34b01eff2ccb912\",\"license\":\"UNLICENCED\"},\"contracts/ArexaPlatform/LibArexaConst.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\r\\n/**\\r\\n * Copyright (C) 2023 AREXA\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibArexaConst {\\r\\n\\t//\\r\\n\\t//Pausable\\r\\n\\tbytes32 public constant FULL = 0x00;\\r\\n\\tbytes32 public constant SUBSCR1_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.SUBSCR1_TOKEN_TYPE));\\r\\n\\tbytes32 public constant SUBSCR2_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.SUBSCR2_TOKEN_TYPE));\\r\\n\\tbytes32 public constant TRADER_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.TRADER_TOKEN_ID));\\r\\n\\tbytes32 public constant AREXA_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.AREXA_TOKEN_ID));\\r\\n\\tbytes32 public constant MAGIC_TOKEN = keccak256(abi.encode(\\\"TOKEN\\\", LibArexaConst.MAGIC_TOKEN_ID));\\r\\n\\r\\n\\t//Roles\\r\\n\\tbytes32 public constant AREXA_ADMIN_ROLE = keccak256(\\\"AREXA_ADMIN_ROLE\\\");\\r\\n\\t//bytes32 public constant TOKEN_ADMIN_ROLE = keccak256(\\\"AREXA_TOKEN_ADMIN_ROLE\\\");\\r\\n\\t//bytes32 public constant TREASURY_ROLE = keccak256(\\\"AREXA_TREASURY_ROLE\\\");\\r\\n\\r\\n\\t//BlackWhite lists\\r\\n\\tbytes32 public constant MAGIC100_FIRST_BUYER = keccak256(\\\"MAGIC100_FIRST_BUYER\\\"); //WhiteList\\r\\n\\r\\n\\t//TokenIDs:\\r\\n\\tuint256 public constant SUBSCR1_TOKEN_TYPE = 100000000; //Tier 1, every month\\r\\n\\tuint256 public constant SUBSCR2_TOKEN_TYPE = 200000000; //Tier 2, every month\\r\\n\\tuint256 public constant TRADER_TOKEN_ID = 300000000; //Tier 3, unlimited, always mint\\r\\n\\tuint256 public constant AREXA_TOKEN_ID = 400000000; //Tier 4, 100000000 piece\\r\\n\\tuint256 public constant MAGIC_TOKEN_ID = 500000000; //Tier 5, 100 piece\\r\\n\\r\\n\\t//AREXA TOKEN POOL TYPES:\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_INVESTOR = 1; //35M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_AREXAINC = 2; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_MARKETING = 3; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_DEVELOPMENT = 4; //5M\\r\\n\\tuint8 public constant AREXA_TOKEN_POOL_RESERVED = 5; //50M\\r\\n}\\r\\n\",\"keccak256\":\"0xeedce13c6edc52af9ce86c36b4801a16333d56ea490e6d264c4b02a8d6aa3341\",\"license\":\"UNLICENCED\"},\"contracts/ArexaPlatform/Platform/LibArexaPlatform.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 AREXA\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\nimport \\\"./LibArexaPlatformStorage.sol\\\";\\r\\nimport \\\"../../utils/Math.sol\\\";\\r\\n\\r\\nimport \\\"../../base/Diamond/LibDiamond.sol\\\";\\r\\nimport \\\"../../base/ERC1155/base/LibERC1155.sol\\\";\\r\\nimport \\\"../../base/TokenRestriction/LibTokenRestriction.sol\\\";\\r\\nimport \\\"../../base/TokenPNL/LibTokenPNL.sol\\\";\\r\\nimport \\\"../../base/TokenDynamicPricing/LibTokenDynamicPricing.sol\\\";\\r\\n\\r\\nimport \\\"../LibArexaConst.sol\\\";\\r\\n\\r\\nimport { IERC20 } from \\\"../../base/ERC20/IERC20.sol\\\";\\r\\nimport { IERC20Metadata } from \\\"../../base/ERC20/metadata/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../base/BridgeCentralized/IBridgeableToken.sol\\\";\\r\\n\\r\\nlibrary LibArexaPlatform {\\r\\n\\tuint8 public constant AMOUNT_VALUE_TYPE = 0;\\r\\n\\tuint8 public constant QUANTITY_VALUE_TYPE = 1;\\r\\n\\r\\n\\tfunction _initArexaTokenPool(uint8 _tokenType, address _operator, address _tokenOwner, uint256 _amount) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\trequire(arexa.arexaTokenPool[_tokenType].total == 0, \\\"Arexa token pool is already initialized with the give type!\\\");\\r\\n\\t\\tarexa.arexaTokenPool[_tokenType].total = _amount;\\r\\n\\t\\tLibERC1155.mint(_operator, _tokenOwner, LibArexaConst.AREXA_TOKEN_ID, _amount, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction initialize(address _operator, IERC20 payingToken, IERC20 arexaERC20Token, uint64 restrictionTimeDelta) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tarexa.payingERC20Token = payingToken;\\r\\n\\t\\tarexa.arexaERC20Token = arexaERC20Token;\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Tier I: LibArexaConst.SUBSCR_TOKEN_TYPE_1\\r\\n\\t\\t */\\r\\n\\t\\tsetArexaIncomeParameter(LibArexaConst.SUBSCR1_TOKEN_TYPE, 90, 10);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Tier II: LibArexaConst.SUBSCR_TOKEN_TYPE_2\\r\\n\\t\\t */\\r\\n\\t\\tsetArexaIncomeParameter(LibArexaConst.SUBSCR2_TOKEN_TYPE, 95, 5);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Tier III: LibArexaConst.TRADER_TOKEN_ID\\r\\n\\t\\t */\\r\\n\\t\\tsetArexaIncomeParameter(LibArexaConst.TRADER_TOKEN_ID, 995, 5);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Tier IV: LibArexaConst.AREXA_TOKEN_ID\\r\\n\\t\\t */\\r\\n\\t\\tsetArexaIncomeParameter(LibArexaConst.AREXA_TOKEN_ID, 90, 10);\\r\\n\\r\\n\\t\\t//Enged\\u00e9lyezz\\u00fck a tokenre a PNL sz\\u00e1mol\\u00e1st, \\u00edgy inicializ\\u00e1l\\u00f3dik teljes darabsz\\u00e1m is a PNLn\\u00e9l.\\r\\n\\t\\tLibTokenPNL.initTokenPNL(address(payingToken), LibArexaConst.AREXA_TOKEN_ID);\\r\\n\\r\\n\\t\\t//Ez \\u00e1ltal olyan mintha m\\u00e1r nem k\\u00e9ne restriction-t kezelni, \\u00e9s a teljes \\u00f6sszeg megy a kifizethet\\u0151be\\r\\n\\t\\tLibTokenRestriction.initTokenRestriction(LibArexaConst.AREXA_TOKEN_ID, block.number, block.number + 1, restrictionTimeDelta);\\r\\n\\r\\n\\t\\t//kibocs\\u00e1jtjuk a poolba a tokeneket, de azonnal eladhat\\u00f3ak lesznek, a reserved tokeneket csak restriction \\u00e9les\\u00edt\\u00e9s ut\\u00e1n\\r\\n\\t\\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_INVESTOR, _operator, contractAddress, 35000000);\\r\\n\\t\\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_AREXAINC, _operator, contractAddress, 5000000);\\r\\n\\t\\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_MARKETING, _operator, contractAddress, 5000000);\\r\\n\\t\\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_DEVELOPMENT, _operator, contractAddress, 5000000);\\r\\n\\r\\n\\t\\t//V\\u00e9gleges\\u00edtj\\u00fck a restriction param\\u00e9tereket\\r\\n\\t\\tLibTokenRestriction.initTokenRestriction(\\r\\n\\t\\t\\tLibArexaConst.AREXA_TOKEN_ID,\\r\\n\\t\\t\\tblock.number + 12 * restrictionTimeDelta + 1,\\r\\n\\t\\t\\tblock.number + 12 * restrictionTimeDelta + 1 + 12 * restrictionTimeDelta + 1,\\r\\n\\t\\t\\trestrictionTimeDelta\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t//A reserved poolba most hozzuk l\\u00e9tre, \\u00edgy a restriction \\u00e9rv\\u00e9nyes lesz r\\u00e1\\r\\n\\t\\t_initArexaTokenPool(LibArexaConst.AREXA_TOKEN_POOL_RESERVED, _operator, contractAddress, 50000000);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t * Tier V: LibArexaConst.MAGIC_TOKEN_ID\\r\\n\\t\\t */\\r\\n\\t\\tsetArexaIncomeParameter(LibArexaConst.MAGIC_TOKEN_ID, 0, 100);\\r\\n\\t\\tLibERC1155.mint(_operator, contractAddress, LibArexaConst.MAGIC_TOKEN_ID, 100, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t//TODO do the other functions...\\r\\n\\tfunction getArexaTokenPool(uint8 _tokenType) internal view returns (ArexaTokenPool memory) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\treturn arexa.arexaTokenPool[_tokenType];\\r\\n\\t}\\r\\n\\r\\n\\tfunction setArexaIncomeParameter(uint256 _tokenId, uint32 _pool, uint32 _arexa) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\tarexa.arexaIncomeParameter[_tokenId].pool = _pool;\\r\\n\\t\\tarexa.arexaIncomeParameter[_tokenId].arexa = _arexa;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getArexaIncomeParameter(uint256 _tokenId) internal view returns (uint32 pool_, uint32 arexa_) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\tpool_ = arexa.arexaIncomeParameter[_tokenId].pool;\\r\\n\\t\\tarexa_ = arexa.arexaIncomeParameter[_tokenId].arexa;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getPayingToken() internal view returns (IERC20) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\treturn arexa.payingERC20Token;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setPayingToken(IERC20 _token) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\tarexa.payingERC20Token = _token;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getArexaERC20Token() internal view returns (IERC20) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\treturn arexa.arexaERC20Token;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _divideAmountPoolAndArexa(uint256 _tokenId, uint256 _value) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tuint256 poolAmount = (_value * arexa.arexaIncomeParameter[_tokenId].pool) /\\r\\n\\t\\t\\t(arexa.arexaIncomeParameter[_tokenId].pool + arexa.arexaIncomeParameter[_tokenId].arexa);\\r\\n\\t\\tuint256 arexaAmount = _value - poolAmount;\\r\\n\\r\\n\\t\\tLibTokenPNL.changeTotalValue(address(arexa.payingERC20Token), LibArexaConst.AREXA_TOKEN_ID, int256(poolAmount));\\r\\n\\t\\tarexa.poolBalance += poolAmount;\\r\\n\\t\\tarexa.arexaBalance += arexaAmount;\\r\\n\\t}\\r\\n\\r\\n\\tfunction createSubscriptions(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\tuint256 _tokenType,\\r\\n\\t\\tuint16 _year,\\r\\n\\t\\tuint8 _month,\\r\\n\\t\\tuint256 _quantity,\\r\\n\\t\\tuint256 _min,\\r\\n\\t\\tuint256 _max\\r\\n\\t) internal returns (uint256 tokenId) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\t//100 000 000 10**8\\r\\n\\t\\t// 20 240 000\\r\\n\\t\\tuint256 monthlyTokenType = _tokenType + uint256(_year) * 10 ** 4 + uint256(_month) * 10 ** 2;\\r\\n\\r\\n\\t\\trequire(int256(arexa.lastSubscriptionTokenIds[_tokenType]) - int256(monthlyTokenType) < 99, \\\"Can't create for old months\\\");\\r\\n\\r\\n\\t\\tif (arexa.lastSubscriptionTokenIds[_tokenType] < monthlyTokenType) {\\r\\n\\t\\t\\tarexa.lastSubscriptionTokenIds[_tokenType] = monthlyTokenType;\\r\\n\\t\\t}\\r\\n\\t\\tarexa.lastSubscriptionTokenIds[_tokenType]++;\\r\\n\\t\\ttokenId = arexa.lastSubscriptionTokenIds[_tokenType];\\r\\n\\t\\tLibTokenDynamicPricing.initialize(tokenId, _quantity, _min, _max);\\r\\n\\t\\tLibERC1155.mint(_operator, LibDiamond.getDiamondAddress(), tokenId, _quantity, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction getCurrentSubscriptionTokenId(uint256 _tokenType) internal view returns (uint256) {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\treturn arexa.lastSubscriptionTokenIds[_tokenType];\\r\\n\\t}\\r\\n\\r\\n\\tfunction calcSubscriptionPrice(uint256 _tokenId, uint32 _quantity) internal view returns (uint256) {\\r\\n\\t\\treturn LibTokenDynamicPricing.calcTotalValue(_tokenId, _quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buySubscription(uint256 _tokenId, address _account, uint32 _quantity) internal {\\r\\n\\t\\t//Tier3\\r\\n\\t\\t//AREXA_TOKEN\\r\\n\\t\\t//Price: d USDT/piece\\r\\n\\t\\t//Quantity: No limit to buy\\r\\n\\t\\t//_valueType: 0 is amount, 1 is quantity\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tuint256 amount = LibTokenDynamicPricing.buyQuantity(_tokenId, _quantity);\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\r\\n\\t\\t//divide the amount to pool and arexa\\r\\n\\t\\t//SUBSCR1_TOKEN_TYPE OR SUBSCR2_TOKEN_TYPE lesz a v\\u00e9ge\\r\\n\\t\\tuint256 tokenType = (_tokenId / 100000000) * 100000000;\\r\\n\\t\\t_divideAmountPoolAndArexa(tokenType, amount);\\r\\n\\r\\n\\t\\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, _tokenId, _quantity, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyTraderToken(address _operator, address _account, uint128 _value, uint8 _valueType) internal {\\r\\n\\t\\t//Tier3\\r\\n\\t\\t//AREXA_TOKEN\\r\\n\\t\\t//Price: 1.0 USDT/piece\\r\\n\\t\\t//Quantity: No limit to buy\\r\\n\\t\\t//_valueType: 0 is amount, 1 is quantity\\r\\n\\t\\trequire(_valueType == 0 || _valueType == 1, \\\"valueType can be 0 or 1 only!\\\");\\r\\n\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\\r\\n\\t\\tuint256 priceFactor = 10;\\r\\n\\t\\tuint256 price = decimal * priceFactor * 1;\\r\\n\\r\\n\\t\\tuint256 amount = 0;\\r\\n\\t\\tuint256 quantity = 0;\\r\\n\\t\\tif (_valueType == 1) {\\r\\n\\t\\t\\tamount = ((_value * 10 * price) / priceFactor + 5) / 10; //add 5 and div 10: rounding to the nearest\\r\\n\\t\\t\\tquantity = (amount * priceFactor) / price;\\r\\n\\t\\t\\trequire(amount > 0 && quantity > 0, \\\"The input quantity is too small for paying token!\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tquantity = (_value * priceFactor) / price;\\r\\n\\t\\t\\tamount = (quantity * price) / priceFactor;\\r\\n\\t\\t\\trequire(amount > 0 && quantity > 0, \\\"The input amount is too small for buying a token!\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\r\\n\\t\\t//divide the amount to pool and arexa, fontos a sorrend, miel\\u0151tt megkapta a tokent \\u00e9s adminisztr\\u00e1ltuk a PNL v\\u00e1ltoz\\u00e1st, el\\u0151tte n\\u00f6velj\\u00fck a pool \\u00e9rt\\u00e9ket\\r\\n\\t\\t//az\\u00e9rt mert \\u00edgy a deltaPNLben nem napja meg maga ut\\u00e1n j\\u00e1r\\u00f3 r\\u00e9szt.\\r\\n\\t\\t_divideAmountPoolAndArexa(LibArexaConst.TRADER_TOKEN_ID, amount);\\r\\n\\r\\n\\t\\tLibERC1155.mint(_operator, _account, LibArexaConst.TRADER_TOKEN_ID, quantity, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyArexaToken(address _account, uint128 _value, uint8 _valueType) internal {\\r\\n\\t\\t//Tier4\\r\\n\\t\\t//AREXA_TOKEN\\r\\n\\t\\t//Price: 0.1 USDT/piece\\r\\n\\t\\t//Quantity: No limit to buy\\r\\n\\t\\t//_valueType: 0 is amount, 1 is quantity\\r\\n\\r\\n\\t\\trequire(_valueType == 0 || _valueType == 1, \\\"valueType can be 0 or 1 only!\\\");\\r\\n\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\\r\\n\\t\\tuint256 priceFactor = 10;\\r\\n\\t\\tuint256 price = ((decimal * priceFactor) * 1) / 10;\\r\\n\\r\\n\\t\\tuint256 amount = 0;\\r\\n\\t\\tuint256 quantity = 0;\\r\\n\\t\\tif (_valueType == 1) {\\r\\n\\t\\t\\tamount = ((_value * 10 * price) / priceFactor + 5) / 10; //add 5 and div 10: rounding to the nearest\\r\\n\\t\\t\\tquantity = (amount * priceFactor) / price;\\r\\n\\t\\t\\trequire(amount > 0 && quantity > 0, \\\"The input quantity is too small for paying token\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tquantity = (_value * priceFactor) / price;\\r\\n\\t\\t\\tamount = (quantity * price) / priceFactor;\\r\\n\\t\\t\\trequire(amount > 0 && quantity > 0, \\\"The input amount is too small for buying a token\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tArexaTokenPool storage tokenPool = arexa.arexaTokenPool[LibArexaConst.AREXA_TOKEN_POOL_INVESTOR];\\r\\n\\t\\trequire(tokenPool.sold + quantity <= tokenPool.total, \\\"Not enough token to sell\\\");\\r\\n\\t\\ttokenPool.sold = tokenPool.sold + quantity;\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\r\\n\\t\\t//divide the amount to pool and arexa, fontos a sorrend, miel\\u0151tt megkapta a tokent \\u00e9s adminisztr\\u00e1ltuk a PNL v\\u00e1ltoz\\u00e1st, el\\u0151tte n\\u00f6velj\\u00fck a pool \\u00e9rt\\u00e9ket\\r\\n\\t\\t//az\\u00e9rt mert \\u00edgy a deltaPNLben nem napja meg maga ut\\u00e1n j\\u00e1r\\u00f3 r\\u00e9szt.\\r\\n\\t\\t_divideAmountPoolAndArexa(LibArexaConst.AREXA_TOKEN_ID, amount);\\r\\n\\r\\n\\t\\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.AREXA_TOKEN_ID, quantity, \\\"\\\");\\r\\n\\t\\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + quantity;\\r\\n\\t}\\r\\n\\r\\n\\tfunction payByArexaToken(uint8 _poolType, address _account, uint32 _quantity) internal {\\r\\n\\t\\t//Tier4\\r\\n\\t\\t//AREXA_TOKEN GIFT\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tArexaTokenPool storage tokenPool = arexa.arexaTokenPool[_poolType];\\r\\n\\t\\trequire(tokenPool.sold + _quantity <= tokenPool.total, \\\"Not enoguh token to gift\\\");\\r\\n\\t\\ttokenPool.sold = tokenPool.sold + _quantity;\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.AREXA_TOKEN_ID, _quantity, \\\"\\\");\\r\\n\\t\\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + _quantity;\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyMagic100Token(address _account) internal {\\r\\n\\t\\t//Tier5\\r\\n\\t\\t//MAGIC_TOKEN_ID\\r\\n\\t\\t//Price: 100.0 USDT/piece\\r\\n\\t\\t//Quantity: 1\\r\\n\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.payingERC20Token)).decimals();\\r\\n\\t\\tuint256 amount = 100 * decimal;\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(_account, contractAddress, amount);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\r\\n\\t\\tLibERC1155.safeTransfer(contractAddress, contractAddress, _account, LibArexaConst.MAGIC_TOKEN_ID, 1, \\\"\\\");\\r\\n\\r\\n\\t\\t//divide the amount to pool and arexa, fontos a sorrend, miut\\u00e1n megkapta a tokent \\u00e9s adminisztr\\u00e1ltuk a PNL v\\u00e1ltoz\\u00e1st, ut\\u00e1na n\\u00f6velj\\u00fck a pool \\u00e9rt\\u00e9ket csak!\\r\\n\\t\\t_divideAmountPoolAndArexa(LibArexaConst.MAGIC_TOKEN_ID, amount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction payoutArexaIncome(address _account, uint256 _value) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\t\\trequire(_value <= arexa.arexaBalance, \\\"Not enough amount to pay out!\\\");\\r\\n\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _account, _value);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _account, _value);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction payoutPoolDivident(address _collectingAccount, address _toAccount, uint256 _amount) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\tLibTokenPNL.refreshPayoutDivident(\\r\\n\\t\\t\\taddress(LibArexaPlatform.getPayingToken()),\\r\\n\\t\\t\\tLibArexaConst.AREXA_TOKEN_ID,\\r\\n\\t\\t\\t_collectingAccount,\\r\\n\\t\\t\\tint256(_amount)\\r\\n\\t\\t);\\r\\n\\t\\tarexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _toAccount, _amount);\\r\\n\\t\\t// bool result = arexa.payingERC20Token.transferFrom(LibDiamond.getDiamondAddress(), _toAccount, _amount);\\r\\n\\t\\t// require(result, \\\"Something wrong with the payment!\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction stakeArexaToken(address _fromAccount, address _toAccount, uint256 _quantity) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\t//Caclulate each token quantity from input. Input is an arexa20Quantity, but can have decimals fractions, so have to \\\"round floor\\\"\\r\\n\\t\\t//arexa11555Quantity have only whole number\\r\\n\\t\\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.arexaERC20Token)).decimals();\\r\\n\\t\\tuint256 arexa11555Quantity = _quantity / decimal;\\r\\n\\t\\tuint256 arexa20Quantity = arexa11555Quantity * decimal;\\r\\n\\r\\n\\t\\trequire(arexa11555Quantity > 0 && arexa20Quantity > 0, \\\"The input amount is too small for staking (AREXA AI token)\\\");\\r\\n\\r\\n\\t\\t//Burn the Arexa AI ERC20 from user\\r\\n\\t\\tIBridgeableToken(address(arexa.arexaERC20Token)).burnFrom(_fromAccount, arexa20Quantity);\\r\\n\\r\\n\\t\\taddress contractAddress = LibDiamond.getDiamondAddress();\\r\\n\\r\\n\\t\\t//Transfer Arexa AI Token from contract to user\\r\\n\\t\\tLibERC1155.safeTransfer(contractAddress, contractAddress, _toAccount, LibArexaConst.AREXA_TOKEN_ID, arexa11555Quantity, \\\"\\\");\\r\\n\\t\\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity + arexa11555Quantity;\\r\\n\\t}\\r\\n\\r\\n\\tfunction withdrawArexaToken(address _operator, address _fromAccount, address _toAccount, uint256 _quantity) internal {\\r\\n\\t\\tArexaPlatformStorage storage arexa = LibArexaPlatformStorage.layout();\\r\\n\\r\\n\\t\\t//Caclulate each token quantity from input. Input is an arexa11555Quantity\\r\\n\\t\\t//arexa11555Quantity have only whole number\\r\\n\\t\\tuint256 decimal = 10 ** IERC20Metadata(address(arexa.arexaERC20Token)).decimals();\\r\\n\\t\\tuint256 arexa20Quantity = _quantity * decimal;\\r\\n\\r\\n\\t\\t//Transfer Arexa AI Token from user to contract\\r\\n\\t\\tLibERC1155.safeTransfer(_operator, _fromAccount, LibDiamond.getDiamondAddress(), LibArexaConst.AREXA_TOKEN_ID, _quantity, \\\"\\\");\\r\\n\\r\\n\\t\\t//Mint the Arexa AI ERC20 to user\\r\\n\\t\\tIBridgeableToken(address(arexa.arexaERC20Token)).mint(_toAccount, arexa20Quantity);\\r\\n\\r\\n\\t\\tarexa.stakedArexaERC20TokenQuantity = arexa.stakedArexaERC20TokenQuantity - _quantity;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xaf7640f318c5e4af5152105901f4a4026e5fa1dbd12ee71ebd1d1bec7dcea880\",\"license\":\"MIT\"},\"contracts/ArexaPlatform/Platform/LibArexaPlatformStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 AREXA\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport { IERC20 } from \\\"../../base/ERC20/IERC20.sol\\\";\\r\\n\\r\\nstruct ArexaTokenPool {\\r\\n\\tuint256 total;\\r\\n\\tuint256 sold;\\r\\n}\\r\\n\\r\\nstruct ArexaIncomeParameter {\\r\\n\\tuint32 pool;\\r\\n\\tuint32 arexa;\\r\\n}\\r\\n\\r\\nstruct ArexaPlatformStorage {\\r\\n\\tmapping(uint8 => ArexaTokenPool) arexaTokenPool;\\r\\n\\tmapping(uint256 => ArexaIncomeParameter) arexaIncomeParameter;\\r\\n\\tIERC20 payingERC20Token; //USDT\\r\\n\\tuint256 poolBalance; //The \\\"pool\\\" part of the sum income\\r\\n\\tuint256 arexaBalance; //The \\\"owner\\\" part of the sum income\\r\\n\\t//tokenType => lastSubscriptionTokenId\\r\\n\\tmapping(uint256 => uint256) lastSubscriptionTokenIds;\\r\\n\\tIERC20 arexaERC20Token; //AREXA\\r\\n\\tuint256 stakedArexaERC20TokenQuantity;\\r\\n}\\r\\n\\r\\nlibrary LibArexaPlatformStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.contracts.arexa-platform.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (ArexaPlatformStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xcd187eeb2701d161421c76855831e8cc5022c710210652344228a762b7ddee0a\",\"license\":\"MIT\"},\"contracts/base/AccessControl/LibAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibAccessControlStorage.sol\\\";\\r\\n\\r\\nimport { IERC173 } from \\\"../../interfaces/IERC173.sol\\\";\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport { UintUtils } from \\\"../../utils/UintUtils.sol\\\";\\r\\nimport { AddressUtils } from \\\"../../utils/AddressUtils.sol\\\";\\r\\n\\r\\nlibrary LibAccessControl {\\r\\n\\tusing EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\tusing UintUtils for uint256;\\r\\n\\tusing AddressUtils for address;\\r\\n\\r\\n\\terror Ownable__NotOwner();\\r\\n\\terror Ownable__NotTransitiveOwner();\\r\\n\\r\\n\\terror AccessDenied(bytes32 role, address account);\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\tevent RoleAdminChanged(address indexed owner, bytes32 role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\tevent RoleGranted(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\tevent RoleRevoked(address indexed owner, bytes32 role, address indexed account, address indexed sender);\\r\\n\\r\\n\\tbytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n\\tfunction _setOwner(address _newOwner) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\taddress previousOwner = acls.owner;\\r\\n\\t\\tacls.owner = _newOwner;\\r\\n\\r\\n\\t\\t//Init DEFAULT_ADMIN_ROLE to _newOwner\\r\\n\\t\\tLibAccessControl._grantRole(LibAccessControl.DEFAULT_ADMIN_ROLE, _newOwner);\\r\\n\\r\\n\\t\\temit OwnershipTransferred(previousOwner, _newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _owner() internal view returns (address owner_) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\towner_ = acls.owner;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transitiveOwner() internal view returns (address owner_) {\\r\\n\\t\\towner_ = LibAccessControl._owner();\\r\\n\\r\\n\\t\\twhile (owner_.isContract()) {\\r\\n\\t\\t\\ttry IERC173(owner_).owner() returns (address transitiveOwner) {\\r\\n\\t\\t\\t\\towner_ = transitiveOwner;\\r\\n\\t\\t\\t} catch {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _owner(), \\\"Not owner!\\\");\\r\\n\\t\\tif (msg.sender != _owner()) {\\r\\n\\t\\t\\trevert Ownable__NotOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _enforceIsTransitiveOwner() internal view {\\r\\n\\t\\t//require(msg.sender == _transitiveOwner(), \\\"Not transitive owner!\\\");\\r\\n\\t\\tif (msg.sender != _transitiveOwner()) {\\r\\n\\t\\t\\trevert Ownable__NotTransitiveOwner();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice assign role to given account\\r\\n\\t * @param _role role to assign\\r\\n\\t * @param _account recipient of role assignment\\r\\n\\t */\\r\\n\\tfunction _grantRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\tacls.roles[acls.owner][_role].members.add(_account);\\r\\n\\t\\t\\temit RoleGranted(acls.owner, _role, _account, msg.sender);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice unassign role from given account\\r\\n\\t * @param _role role to unassign\\r\\n\\t * @param _account account to revokeAccessControlStorage\\r\\n\\t */\\r\\n\\tfunction _revokeRole(bytes32 _role, address _account) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\t// require(_role != LibAccessControl.DEFAULT_ADMIN_ROLE && _account != acls.owner);\\r\\n\\t\\tacls.roles[acls.owner][_role].members.remove(_account);\\r\\n\\t\\temit RoleRevoked(acls.owner, _role, _account, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice relinquish role\\r\\n\\t * @param _role role to relinquish\\r\\n\\t */\\r\\n\\tfunction _renounceRole(bytes32 _role) internal {\\r\\n\\t\\t_revokeRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query one of the accounts that have role of the project\\r\\n\\t * @dev WARNING: When using _getProjectRoleMember and _getProjectRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _index index of role member\\r\\n\\t */\\r\\n\\tfunction _getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.at(_index);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query the number of accounts that have role.\\r\\n\\t * @dev WARNING: When using _getRoleMember and _getRoleMemberCount, make sure you perform all queries on the same block.\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _getRoleMemberCount(address, bytes32 _role) internal view returns (uint256) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.length();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query whether role is assigned to account\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account account to query\\r\\n\\t * @return bool whether role is assigned to account\\r\\n\\t */\\r\\n\\tfunction _hasRole(bytes32 _role, address _account) internal view returns (bool) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].members.contains(_account);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if sender does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role) internal view {\\r\\n\\t\\t_checkRole(_role, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if given account does not have given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @param _account to query\\r\\n\\t */\\r\\n\\tfunction _checkRole(bytes32 _role, address _account) internal view {\\r\\n\\t\\tif (!_hasRole(_role, _account)) {\\r\\n\\t\\t\\trevert AccessDenied({ role: _role, account: _account });\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query admin role for given role\\r\\n\\t * @param _role role to query\\r\\n\\t * @return admin role\\r\\n\\t */\\r\\n\\tfunction _getRoleAdmin(bytes32 _role) internal view returns (bytes32) {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\treturn acls.roles[acls.owner][_role].adminRole;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set role as admin role\\r\\n\\t * @param _role role to set\\r\\n\\t * @param _adminRole admin role to set\\r\\n\\t */\\r\\n\\tfunction _setRoleAdmin(bytes32 _role, bytes32 _adminRole) internal {\\r\\n\\t\\tAccessControllStorage storage acls = LibAccessControlStorage.layout();\\r\\n\\t\\tbytes32 previousAdminRole = _getRoleAdmin(_role);\\r\\n\\t\\tacls.roles[acls.owner][_role].adminRole = _adminRole;\\r\\n\\t\\temit RoleAdminChanged(acls.owner, _role, previousAdminRole, _adminRole);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x2c0da263bd49a5c7a6d1a9d8866bbe5936b43f3ee39bf2c9dc4600d7045b49e9\",\"license\":\"MIT\"},\"contracts/base/AccessControl/LibAccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport \\\"./RoleData.sol\\\";\\r\\n\\r\\nstruct AccessControllStorage {\\r\\n\\t//owner => role => adminRole, members mapping\\r\\n\\taddress owner;\\r\\n\\tmapping(address => mapping(bytes32 => RoleData)) roles;\\r\\n}\\r\\n\\r\\nlibrary LibAccessControlStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.access-control.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (AccessControllStorage storage acls_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tacls_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9ae5597ade94391b4f367368b5e6f5b4d15dce1e430e217ee5e549a652c8eb8b\",\"license\":\"MIT\"},\"contracts/base/AccessControl/ModifierRole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibAccessControl } from \\\"./LibAccessControl.sol\\\";\\r\\n\\r\\nabstract contract ModifierRole {\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyTransitiveOwner() {\\r\\n\\t\\tLibAccessControl._enforceIsTransitiveOwner();\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRole(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(role);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyRoleAdmin(bytes32 role) {\\r\\n\\t\\tLibAccessControl._checkRole(LibAccessControl._getRoleAdmin(role));\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x9a5f770772e3b447a47bbcacd0afe131c78c98bc87219da9e3dfe10a261ad64e\",\"license\":\"MIT\"},\"contracts/base/AccessControl/RoleData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct RoleData {\\r\\n\\tbytes32 adminRole;\\r\\n\\tEnumerableSet.AddressSet members;\\r\\n}\\r\\n\",\"keccak256\":\"0xf9d7eaf459b09f21c482e9b9df5b5c99572095e79174de3621f5ec9e32413ac7\",\"license\":\"MIT\"},\"contracts/base/BlackWhiteList/LibBlackWhiteList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibBlackWhiteListStorage.sol\\\";\\r\\n\\r\\nlibrary LibBlackWhiteList {\\r\\n\\t//_target: which list is belongs to...\\r\\n\\t//_account: an account on a _target\\r\\n\\t//_lockValue:\\r\\n\\t//  - if _target is a blackList than true _lockValue means that the account is prohibited\\r\\n\\t//  - if _target is a blackList than false _lockValue means that the account is acceptable\\r\\n\\t//  - if _target is a whiteList than true _lockValue means that the account is acceptable\\r\\n\\t//  - if _target is a whiteList than false _lockValue means that the account is prohibited\\r\\n\\tevent AccountBlackWhiteList(bytes32 indexed _target, address indexed _account, bool _lockValue);\\r\\n\\r\\n\\tfunction _getAccountBlackWhiteList(bytes32 _target, address _account) internal view returns (bool lockValue_) {\\r\\n\\t\\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\\r\\n\\t\\tlockValue_ = wls.whiteList[_target][_account];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setAccountBlackWhiteList(bytes32 _target, address _account, bool _lockValue) internal {\\r\\n\\t\\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\\r\\n\\t\\twls.whiteList[_target][_account] = _lockValue;\\r\\n\\t\\temit AccountBlackWhiteList(_target, _account, _lockValue);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setBatchAccountBlackWhiteList(bytes32 _target, address[] calldata _accounts, bool _lockValue) internal {\\r\\n\\t\\trequire(_accounts.length <= 255, \\\"Batch: too many addresses\\\");\\r\\n\\t\\tBlackWhiteListStorage storage wls = LibBlackWhiteListStorage.layout();\\r\\n\\t\\tfor (uint8 i = 0; i < _accounts.length; i++) {\\r\\n\\t\\t\\twls.whiteList[_target][_accounts[i]] = _lockValue;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x6cd8e2018edf787abee860a5b98f6c88f0302b04e8557a2ff0cb1e75e24b8241\",\"license\":\"MIT\"},\"contracts/base/BlackWhiteList/LibBlackWhiteListStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct BlackWhiteListStorage {\\r\\n\\tmapping(bytes32 => mapping(address => bool)) whiteList;\\r\\n}\\r\\n\\r\\nlibrary LibBlackWhiteListStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.white-list.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (BlackWhiteListStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x040e35cfc2497b8eecef40b205079d1b6dfd00a4d1e1724d31e9baa5e7752ee1\",\"license\":\"MIT\"},\"contracts/base/BridgeCentralized/IBridgeableToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IBridgeableToken {\\r\\n\\tfunction mint(address to, uint256 amount) external;\\r\\n\\r\\n\\tfunction burnFrom(address from, uint256 amount) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x82c931efcb760ff09de25b4b897f71cff783e1fbecee824cf8c92a8bbe6dc69e\",\"license\":\"MIT\"},\"contracts/base/Diamond/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport \\\"./LibDiamondStorage.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\nimport { LibAccessControl } from \\\"../AccessControl/LibAccessControl.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n\\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n\\tfunction setDiamondAddress(address _diamondAddress) internal {\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(ds.diamondAddress == address(0), \\\"Already initialized!\\\");\\n\\t\\tds.diamondAddress = _diamondAddress;\\n\\t}\\n\\n\\tfunction getDiamondAddress() internal view returns (address) {\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\treturn ds.diamondAddress;\\n\\t}\\n\\n\\tfunction setContractOwner(address _newOwner) internal {\\n\\t\\tLibAccessControl._setOwner(_newOwner);\\n\\t}\\n\\n\\tfunction enforceIsContractOwner() internal view {\\n\\t\\tLibAccessControl._enforceIsOwner();\\n\\t}\\n\\n\\t// Internal function version of diamondCut\\n\\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n\\t\\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n\\t\\t\\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n\\t\\t\\tif (action == IDiamondCut.FacetCutAction.Add) {\\n\\t\\t\\t\\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\\n\\t\\t\\t\\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\\n\\t\\t\\t\\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit DiamondCut(_diamondCut, _init, _calldata);\\n\\t\\tinitializeDiamondCut(_init, _calldata);\\n\\t}\\n\\n\\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n\\t\\t// add new facet address if it does not exist\\n\\t\\tif (selectorPosition == 0) {\\n\\t\\t\\taddFacet(ds, _facetAddress);\\n\\t\\t}\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\trequire(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\n\\t\\t\\tselectorPosition++;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n\\t\\t// add new facet address if it does not exist\\n\\t\\tif (selectorPosition == 0) {\\n\\t\\t\\taddFacet(ds, _facetAddress);\\n\\t\\t}\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\trequire(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\n\\t\\t\\tselectorPosition++;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n\\t\\trequire(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\t\\tDiamondStorage storage ds = LibDiamondStorage.layout();\\n\\t\\t// if function does not exist then do nothing and return\\n\\t\\trequire(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n\\t\\tenforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n\\t\\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n\\t\\tds.facetAddresses.push(_facetAddress);\\n\\t}\\n\\n\\tfunction addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n\\t\\tds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n\\t\\tds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n\\t}\\n\\n\\tfunction removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\n\\t\\trequire(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n\\t\\t// an immutable function is a function defined directly in a diamond\\n\\t\\trequire(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n\\t\\t// replace selector with last selector, then delete last selector\\n\\t\\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n\\t\\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n\\t\\t// if not the same then replace _selector with lastSelector\\n\\t\\tif (selectorPosition != lastSelectorPosition) {\\n\\t\\t\\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n\\t\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n\\t\\t\\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n\\t\\t}\\n\\t\\t// delete the last selector\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n\\t\\tdelete ds.selectorToFacetAndPosition[_selector];\\n\\n\\t\\t// if no more selectors for facet address then delete the facet address\\n\\t\\tif (lastSelectorPosition == 0) {\\n\\t\\t\\t// replace facet address with last facet address and delete last facet address\\n\\t\\t\\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n\\t\\t\\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n\\t\\t\\tif (facetAddressPosition != lastFacetAddressPosition) {\\n\\t\\t\\t\\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n\\t\\t\\t\\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n\\t\\t\\t\\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n\\t\\t\\t}\\n\\t\\t\\tds.facetAddresses.pop();\\n\\t\\t\\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n\\t\\tif (_init == address(0)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tenforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\t\\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\\n\\t\\tif (!success) {\\n\\t\\t\\tif (error.length > 0) {\\n\\t\\t\\t\\t// bubble up error\\n\\t\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(error)\\n\\t\\t\\t\\t\\trevert(add(32, error), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert InitializationFunctionReverted(_init, _calldata);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n\\t\\tuint256 contractSize;\\n\\t\\tassembly {\\n\\t\\t\\tcontractSize := extcodesize(_contract)\\n\\t\\t}\\n\\t\\trequire(contractSize > 0, _errorMessage);\\n\\t}\\n}\\n\",\"keccak256\":\"0x5f15f134edd02ce19fb55ce2c33ef634b5766bef24fee8dcc69f53d04bfe5219\",\"license\":\"MIT\"},\"contracts/base/Diamond/LibDiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct FacetAddressAndPosition {\\r\\n\\taddress facetAddress;\\r\\n\\tuint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\r\\n}\\r\\n\\r\\nstruct FacetFunctionSelectors {\\r\\n\\tbytes4[] functionSelectors;\\r\\n\\tuint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\r\\n}\\r\\n\\r\\nstruct DiamondStorage {\\r\\n\\taddress diamondAddress;\\r\\n\\t// maps function selector to the facet address and\\r\\n\\t// the position of the selector in the facetFunctionSelectors.selectors array\\r\\n\\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\r\\n\\t// maps facet addresses to function selectors\\r\\n\\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\r\\n\\t// facet addresses\\r\\n\\taddress[] facetAddresses;\\r\\n\\t// Used to query if a contract implements an interface.\\r\\n\\t// Used to implement ERC-165.\\r\\n\\tmapping(bytes4 => bool) supportedInterfaces;\\r\\n\\t//the whole diamond is paused or not\\r\\n\\tbool paused;\\r\\n}\\r\\n\\r\\nlibrary LibDiamondStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.contracts.diamond.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (DiamondStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x13a60db83059255e32f692e0508aaa9af49568a363e3aae233ae80aab0c75098\",\"license\":\"MIT\"},\"contracts/base/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * https://eips.ethereum.org/EIPS/eip-1155.\\n */\\ninterface IERC1155Receiver {\\n\\t/**\\n\\t * @notice Handle the receipt of a single ERC1155 token type.\\n\\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\\n\\t * This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\n\\t * This function MUST revert if it rejects the transfer.\\n\\t * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n\\t * @param _operator The address which initiated the transfer (i.e. msg.sender)\\n\\t * @param _from The address which previously owned the token\\n\\t * @param _id The ID of the token being transferred\\n\\t * @param _value The amount of tokens being transferred\\n\\t * @param _data Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n\\t */\\n\\tfunction onERC1155Received(\\n\\t\\taddress _operator,\\n\\t\\taddress _from,\\n\\t\\tuint256 _id,\\n\\t\\tuint256 _value,\\n\\t\\tbytes calldata _data\\n\\t) external returns (bytes4);\\n\\n\\t/**\\n\\t * @notice Handle the receipt of multiple ERC1155 token types.\\n\\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\\n\\t * This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\n\\t * This function MUST revert if it rejects the transfer(s).\\n\\t * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n\\t * @param _operator The address which initiated the batch transfer (i.e. msg.sender)\\n\\t * @param _from The address which previously owned the token\\n\\t * @param _ids An array containing ids of each token being transferred (order and length must match _values array)\\n\\t * @param _values An array containing amounts of each token being transferred (order and length must match _ids array)\\n\\t * @param _data Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n\\t */\\n\\tfunction onERC1155BatchReceived(\\n\\t\\taddress _operator,\\n\\t\\taddress _from,\\n\\t\\tuint256[] calldata _ids,\\n\\t\\tuint256[] calldata _values,\\n\\t\\tbytes calldata _data\\n\\t) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeba602761fec3810381b28625959f0b9053b66b7b097ea766225784ad49dfef4\",\"license\":\"MIT\"},\"contracts/base/ERC1155/base/LibERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibERC1155Storage.sol\\\";\\r\\n\\r\\nimport \\\"../customization/LibERC1155Customization.sol\\\";\\r\\n\\r\\nimport { AddressUtils } from \\\"../../../utils/AddressUtils.sol\\\";\\r\\nimport { EnumerableSet } from \\\"../../../utils/EnumerableSet.sol\\\";\\r\\nimport { IERC1155Receiver } from \\\"../IERC1155Receiver.sol\\\";\\r\\n\\r\\nerror LibERC1155__BalanceQueryZeroAddress(); //Ok\\r\\nerror LibERC1155__ArrayLengthMismatch(); //Ok\\r\\nerror LibERC1155__MintToZeroAddress(); //ok\\r\\nerror LibERC1155__BurnExceedsBalance(); ///Ok\\r\\nerror LibERC1155__BurnFromZeroAddress(); //Ok\\r\\nerror LibERC1155__ERC1155ReceiverRejected(); // OK\\r\\nerror LibERC1155__ERC1155ReceiverNotImplemented(); //ok\\r\\nerror LibERC1155__TransferExceedsBalance(); //Ok\\r\\nerror LibERC1155__TransferToZeroAddress(); //Ok\\r\\nerror LibERC1155__NotOwnerOrApproved(); //Ok\\r\\nerror LibERC1155__NotOwnerOrApprovedLimit(); //Ok\\r\\nerror LibERC1155__SelfApproval(); //OK\\r\\n\\r\\nlibrary LibERC1155 {\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * EVENTS from IERC1155\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tevent TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n\\tevent TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\r\\n\\r\\n\\tevent ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n\\tevent URI(string value, uint256 indexed tokenId);\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * EVENTS from IERC1155Allowance\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tevent Approval(address indexed owner, address indexed operator, uint256 indexed id, uint256 currenctValue, uint256 newValue);\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * EVENTS from IERC1155Paused\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tevent AllTokenPaused(address indexed account);\\r\\n\\r\\n\\tevent AllTokenUnpaused(address indexed account);\\r\\n\\r\\n\\tevent TokenPaused(address indexed account, uint256 indexed tokenId);\\r\\n\\r\\n\\tevent TokenUnpaused(address indexed account, uint256 indexed tokenId);\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * Usings\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tusing AddressUtils for address;\\r\\n\\tusing EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\tusing EnumerableSet for EnumerableSet.UintSet;\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query the balance of given token held by given address\\r\\n\\t * @param _account address to query\\r\\n\\t * @param _tokenId token to query\\r\\n\\t * @return token balance\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _account, uint256 _tokenId) internal view returns (uint256) {\\r\\n\\t\\tif (_account == address(0)) revert LibERC1155__BalanceQueryZeroAddress();\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.balances[_tokenId][_account];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query the balance of given token held by the given addresses\\r\\n\\t * @param _accounts addresses to query\\r\\n\\t * @param _tokenIds list of token IDs to query\\r\\n\\t * @return tokens' balance\\r\\n\\t */\\r\\n\\tfunction balanceOfBatch(address[] memory _accounts, uint256[] memory _tokenIds) internal view returns (uint256[] memory) {\\r\\n\\t\\trequire(_accounts.length == _tokenIds.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\r\\n\\t\\tif (_tokenIds.length != _accounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\tuint256[] memory batchBalances = new uint256[](_accounts.length);\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < _accounts.length; ++i) {\\r\\n\\t\\t\\tbatchBalances[i] = balanceOf(_accounts[i], _tokenIds[i]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn batchBalances;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice mint given quantity of tokens for given address\\r\\n\\t * @param _operator caller, msg.sender or msgSender()\\r\\n\\t * @param _toAccount beneficiary of minting\\r\\n\\t * @param _tokenId token ID\\r\\n\\t * @param _amount quantity of tokens to mint\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction mint(address _operator, address _toAccount, uint256 _tokenId, uint256 _amount, bytes memory _data) internal {\\r\\n\\t\\tif (_toAccount == address(0)) revert LibERC1155__MintToZeroAddress();\\r\\n\\r\\n\\t\\tuint256[] memory tokenIds = _asSingletonArray(_tokenId);\\r\\n\\t\\tuint256[] memory amounts = _asSingletonArray(_amount);\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, address(0), _toAccount, tokenIds, amounts, _data);\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\t_whenTokenNotPaused(e1155s, _tokenId);\\r\\n\\r\\n\\t\\te1155s.balances[_tokenId][_toAccount] += _amount;\\r\\n\\t\\temit TransferSingle(_operator, address(0), _toAccount, _tokenId, _amount);\\r\\n\\r\\n\\t\\t_afterTokenTransfer(_operator, address(0), _toAccount, tokenIds, amounts, _data);\\r\\n\\r\\n\\t\\t_doSafeTransferAcceptanceCheck(_operator, address(0), _toAccount, _tokenId, _amount, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice mint batch of tokens for given address\\r\\n\\t * @param _operator caller, msg.sender or msgSender()\\r\\n\\t * @param _toAccount beneficiary of minting\\r\\n\\t * @param _tokenIds list of token IDs\\r\\n\\t * @param _amounts list of quantities of tokens to mint\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction mintBatch(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tif (_toAccount == address(0)) revert LibERC1155__MintToZeroAddress();\\r\\n\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < _tokenIds.length; ) {\\r\\n\\t\\t\\tuint256 tokenId = _tokenIds[i];\\r\\n\\t\\t\\t_whenTokenNotPaused(e1155s, tokenId);\\r\\n\\t\\t\\te1155s.balances[tokenId][_toAccount] += _amounts[i];\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit TransferBatch(_operator, address(0), _toAccount, _tokenIds, _amounts);\\r\\n\\r\\n\\t\\t_afterTokenTransfer(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\\r\\n\\r\\n\\t\\t_doSafeBatchTransferAcceptanceCheck(_operator, address(0), _toAccount, _tokenIds, _amounts, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice burn given quantity of tokens held by given address\\r\\n\\t * @param _operator caller, msg.sender or msgSender()\\r\\n\\t * @param _fromAccount holder of tokens to burn\\r\\n\\t * @param _tokenId token ID\\r\\n\\t * @param _amount quantity of tokens to burn\\r\\n\\t */\\r\\n\\tfunction burn(address _operator, address _fromAccount, uint256 _tokenId, uint256 _amount) internal {\\r\\n\\t\\tif (_fromAccount == address(0)) revert LibERC1155__BurnFromZeroAddress();\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, _fromAccount, address(0), _asSingletonArray(_tokenId), _asSingletonArray(_amount), \\\"\\\");\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\t_whenTokenNotPaused(e1155s, _tokenId);\\r\\n\\r\\n\\t\\tif (_amount > e1155s.balances[_tokenId][_fromAccount]) revert LibERC1155__BurnExceedsBalance();\\r\\n\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\te1155s.balances[_tokenId][_fromAccount] -= _amount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit TransferSingle(_operator, _fromAccount, address(0), _tokenId, _amount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice burn given batch of tokens held by given address\\r\\n\\t * @param _operator caller, msg.sender or msgSender()\\r\\n\\t * @param _fromAccount holder of tokens to burn\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to burn\\r\\n\\t */\\r\\n\\tfunction burnBatch(address _operator, address _fromAccount, uint256[] memory _tokenIds, uint256[] memory _amounts) internal {\\r\\n\\t\\tif (_fromAccount == address(0)) revert LibERC1155__BurnFromZeroAddress();\\r\\n\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, _fromAccount, address(0), _tokenIds, _amounts, \\\"\\\");\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tfor (uint256 i; i < _tokenIds.length; i++) {\\r\\n\\t\\t\\t\\tuint256 tokenId = _tokenIds[i];\\r\\n\\t\\t\\t\\t_whenTokenNotPaused(e1155s, tokenId);\\r\\n\\t\\t\\t\\tif (_amounts[i] > e1155s.balances[tokenId][_fromAccount]) revert LibERC1155__BurnExceedsBalance();\\r\\n\\t\\t\\t\\te1155s.balances[tokenId][_fromAccount] -= _amounts[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit TransferBatch(_operator, _fromAccount, address(0), _tokenIds, _amounts);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice transfer tokens between given addresses\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenId token ID\\r\\n\\t * @param _amount quantity of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction safeTransfer(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\tuint256 _amount,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tif (_toAccount == address(0)) revert LibERC1155__TransferToZeroAddress();\\r\\n\\r\\n\\t\\tuint256[] memory tokenIds = _asSingletonArray(_tokenId);\\r\\n\\t\\tuint256[] memory amounts = _asSingletonArray(_amount);\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, _fromAccount, _toAccount, tokenIds, amounts, _data);\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\t_whenTokenNotPaused(e1155s, _tokenId);\\r\\n\\r\\n\\t\\tuint256 senderBalance = e1155s.balances[_tokenId][_fromAccount];\\r\\n\\r\\n\\t\\tif (_amount > senderBalance) revert LibERC1155__TransferExceedsBalance();\\r\\n\\t\\tcheckAllowance(_operator, _fromAccount, _tokenId, _amount);\\r\\n\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\te1155s.balances[_tokenId][_fromAccount] = senderBalance - _amount;\\r\\n\\t\\t\\tif (_operator != _fromAccount) {\\r\\n\\t\\t\\t\\tif (e1155s.operatorSpendingLimitEnabled[_tokenId]) {\\r\\n\\t\\t\\t\\t\\te1155s.allowances[_fromAccount][_operator][_tokenId] = e1155s.allowances[_fromAccount][_operator][_tokenId] - _amount;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\te1155s.balances[_tokenId][_toAccount] += _amount;\\r\\n\\r\\n\\t\\temit TransferSingle(_operator, _fromAccount, _toAccount, _tokenId, _amount);\\r\\n\\r\\n\\t\\t_afterTokenTransfer(_operator, _fromAccount, _toAccount, tokenIds, amounts, _data);\\r\\n\\r\\n\\t\\t_doSafeTransferAcceptanceCheck(_operator, _fromAccount, _toAccount, _tokenId, _amount, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice transfer batch of tokens between given addresses\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction safeTransferBatch(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tif (_toAccount == address(0)) revert LibERC1155__TransferToZeroAddress();\\r\\n\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\\r\\n\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\r\\n\\t\\tcheckAllowanceBach(_operator, _fromAccount, _tokenIds, _amounts);\\r\\n\\r\\n\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\tuint256 tokenId = _tokenIds[i];\\r\\n\\t\\t\\tuint256 amount = _amounts[i];\\r\\n\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t_whenTokenNotPaused(e1155s, tokenId);\\r\\n\\r\\n\\t\\t\\t\\tuint256 senderBalance = e1155s.balances[tokenId][_fromAccount];\\r\\n\\r\\n\\t\\t\\t\\tif (amount > senderBalance) revert LibERC1155__TransferExceedsBalance();\\r\\n\\r\\n\\t\\t\\t\\te1155s.balances[tokenId][_fromAccount] = senderBalance - amount;\\r\\n\\r\\n\\t\\t\\t\\tif (_operator != _fromAccount) {\\r\\n\\t\\t\\t\\t\\tif (e1155s.operatorSpendingLimitEnabled[tokenId]) {\\r\\n\\t\\t\\t\\t\\t\\te1155s.allowances[_fromAccount][_operator][tokenId] = e1155s.allowances[_fromAccount][_operator][tokenId] - amount;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\\r\\n\\t\\t\\te1155s.balances[tokenId][_toAccount] += amount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit TransferBatch(_operator, _fromAccount, _toAccount, _tokenIds, _amounts);\\r\\n\\r\\n\\t\\t_afterTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\\r\\n\\r\\n\\t\\t_doSafeBatchTransferAcceptanceCheck(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\r\\n\\t * @dev MUST emit the ApprovalForAll event on success.\\r\\n\\t * @param _account The owner of the tokens\\r\\n\\t * @param _operator Address to add to the set of authorized operators\\r\\n\\t * @param _approved True if the operator is approved, false to revoke approval\\r\\n\\t */\\r\\n\\tfunction setApprovalForAll(address _account, address _operator, bool _approved) internal {\\r\\n\\t\\tif (_account == _operator) revert LibERC1155__SelfApproval();\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\te1155s.operatorApprovals[_account][_operator] = _approved;\\r\\n\\t\\temit ApprovalForAll(_account, _operator, _approved);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Queries the approval status of an operator for a given owner.\\r\\n\\t * @param _account The owner of the tokens\\r\\n\\t * @param _operator Address of authorized operator\\r\\n\\t * @return True if the operator is approved, false if not\\r\\n\\t */\\r\\n\\tfunction isApprovedForAll(address _account, address _operator) internal view returns (bool) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.operatorApprovals[_account][_operator];\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155Receiver\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tbytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))\\r\\n\\tbytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))\\r\\n\\r\\n\\tfunction onERC1155Received(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _from,\\r\\n\\t\\tuint256 _id,\\r\\n\\t\\tuint256 _value,\\r\\n\\t\\tbytes calldata _data\\r\\n\\t) internal returns (bytes4) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tERC1155ReceiverStorage storage receivedData = e1155s.receivedTokens[e1155s.receivedTokensLength];\\r\\n\\t\\treceivedData.operator = _operator;\\r\\n\\t\\treceivedData.from = _from;\\r\\n\\t\\treceivedData.ids = _asSingletonArray(_id);\\r\\n\\t\\treceivedData.values = _asSingletonArray(_value);\\r\\n\\t\\treceivedData.data = _data;\\r\\n\\t\\te1155s.receivedTokensLength++;\\r\\n\\r\\n\\t\\t// if (shouldReject == true) {\\r\\n\\t\\t// \\trevert(\\\"onERC1155Received: transfer not accepted\\\");\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\treturn ERC1155_ACCEPTED;\\r\\n\\t\\t// }\\r\\n\\t\\treturn ERC1155_ACCEPTED;\\r\\n\\t}\\r\\n\\r\\n\\tfunction onERC1155BatchReceived(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _from,\\r\\n\\t\\tuint256[] calldata _ids,\\r\\n\\t\\tuint256[] calldata _values,\\r\\n\\t\\tbytes calldata _data\\r\\n\\t) internal returns (bytes4) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tERC1155ReceiverStorage storage receivedData = e1155s.receivedTokens[e1155s.receivedTokensLength];\\r\\n\\t\\treceivedData.operator = _operator;\\r\\n\\t\\treceivedData.from = _from;\\r\\n\\t\\treceivedData.ids = _ids;\\r\\n\\t\\treceivedData.values = _values;\\r\\n\\t\\treceivedData.data = _data;\\r\\n\\t\\te1155s.receivedTokensLength++;\\r\\n\\t\\treturn ERC1155_BATCH_ACCEPTED;\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155Allowance\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\r\\n\\tfunction isOperatorSpendingLimitEnabled(uint256 _tokenId) internal view returns (bool) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.operatorSpendingLimitEnabled[_tokenId];\\r\\n\\t}\\r\\n\\r\\n\\tfunction setOperatorSpendingLimitEnabled(uint256 _tokenId, bool _enabled) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\te1155s.operatorSpendingLimitEnabled[_tokenId] = _enabled;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Allow other accounts/contracts to spend tokens on behalf of msg.sender\\r\\n\\t * @dev MUST emit Approval event on success.\\r\\n\\t * To minimize the risk of the approve/transferFrom attack vector (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), this function will throw if the current approved allowance does not equal the expected _currentValue, unless _value is 0.\\r\\n\\t * @param _owner Address of token owner\\r\\n\\t * @param _operator Address to approve, _operator will ba able to send token\\r\\n\\t * @param _tokenId ID of the Token\\r\\n\\t * @param _currentValue Expected current value of approved allowance.\\r\\n\\t * @param _newValue Allowance amount\\r\\n\\t */\\r\\n\\tfunction approve(address _owner, address _operator, uint256 _tokenId, uint256 _currentValue, uint256 _newValue) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\trequire(e1155s.allowances[_owner][_operator][_tokenId] == _currentValue, \\\"Current value mismatch\\\");\\r\\n\\t\\te1155s.allowances[_owner][_operator][_tokenId] = _newValue;\\r\\n\\r\\n\\t\\temit Approval(_owner, _operator, _tokenId, _currentValue, _newValue);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Queries the spending limit approved for an account\\r\\n\\t * @param _owner The owner allowing the spending\\r\\n\\t * @param _operator The address allowed to spend.\\r\\n\\t * @param _tokenId ID of the Token\\r\\n\\t * @return The _operator's allowed spending balance of the Token requested\\r\\n\\t */\\r\\n\\tfunction allowance(address _owner, address _operator, uint256 _tokenId) internal view returns (uint256) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.allowances[_owner][_operator][_tokenId];\\r\\n\\t}\\r\\n\\r\\n\\tfunction checkAllowance(address _operator, address _fromAccount, uint256 _tokenId, uint256 _value) internal view {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tif (_fromAccount != _operator) {\\r\\n\\t\\t\\tif (!e1155s.operatorApprovals[_fromAccount][_operator]) {\\r\\n\\t\\t\\t\\trevert LibERC1155__NotOwnerOrApproved();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (e1155s.operatorSpendingLimitEnabled[_tokenId] && e1155s.allowances[_fromAccount][_operator][_tokenId] < _value) {\\r\\n\\t\\t\\t\\trevert LibERC1155__NotOwnerOrApprovedLimit();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction checkAllowanceBach(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts\\r\\n\\t) internal view {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tif (_fromAccount != _operator) {\\r\\n\\t\\t\\tif (!e1155s.operatorApprovals[_fromAccount][_operator]) {\\r\\n\\t\\t\\t\\trevert LibERC1155__NotOwnerOrApproved();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t\\tuint256 tokenId = _tokenIds[i];\\r\\n\\t\\t\\t\\t\\tuint256 amount = _amounts[i];\\r\\n\\t\\t\\t\\t\\tif (e1155s.operatorSpendingLimitEnabled[tokenId] && e1155s.allowances[_fromAccount][_operator][tokenId] < amount) {\\r\\n\\t\\t\\t\\t\\t\\trevert LibERC1155__NotOwnerOrApprovedLimit();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155Metadata\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Query global metadata URI, can contain {id}, client will replace with a valid token id\\r\\n\\t */\\r\\n\\tfunction getUri() internal view returns (string memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.uri;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set global metadata URI, can contain {id}, client will\\r\\n\\t * @param _URI global URI\\r\\n\\t */\\r\\n\\tfunction setURI(string memory _URI) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\te1155s.uri = _URI;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTokenBaseUri() internal view returns (string memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.baseURI;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set base metadata URI\\r\\n\\t * @dev base URI is a non-standard feature adapted from the ERC721 specification\\r\\n\\t * @param _baseURI base URI\\r\\n\\t */\\r\\n\\tfunction setTokenBaseURI(string memory _baseURI) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\te1155s.baseURI = _baseURI;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTokenUri(uint256 _tokenId) internal view returns (string memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.tokenURIs[_tokenId];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice set pre-token metadata URI\\r\\n\\t * @param _tokenId token whose metadata URI to set\\r\\n\\t * @param _tokenURI per-token URI\\r\\n\\t */\\r\\n\\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\te1155s.tokenURIs[_tokenId] = _tokenURI;\\r\\n\\t\\temit URI(_tokenURI, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * This implementation returns the concatenation of the `_baseURI`\\r\\n\\t * and the token-specific uri if the latter is set\\r\\n\\t *\\r\\n\\t * This enables the following behaviors:\\r\\n\\t *\\r\\n\\t * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation\\r\\n\\t *   of `_baseURI` and `_tokenURIs[tokenId]`\\r\\n\\t *\\r\\n\\t * - if `_tokenURIs[tokenId]` is NOT set then we fallback to the defaut URI\\r\\n\\t *   which contains `ERC1155.uri`;\\r\\n\\t */\\r\\n\\tfunction getUri(uint256 tokenId) internal view returns (string memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tstring memory tokenURI = e1155s.tokenURIs[tokenId];\\r\\n\\r\\n\\t\\t// If token URI is set, concatenate base URI and tokenURI (via abi.encodePacked).\\r\\n\\t\\treturn bytes(tokenURI).length > 0 ? string(abi.encodePacked(e1155s.baseURI, tokenURI)) : e1155s.uri;\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155Enumerable\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query total minted supply of given token\\r\\n\\t * @param _tokenId token id to query\\r\\n\\t * @return token supply\\r\\n\\t */\\r\\n\\tfunction totalSupply(uint256 _tokenId) internal view returns (uint256) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.totalSupply[_tokenId];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query total number of holders for given token\\r\\n\\t * @param id token id to query\\r\\n\\t * @return quantity of holders\\r\\n\\t */\\r\\n\\tfunction totalHolders(uint256 id) internal view returns (uint256) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\treturn e1155s.accountsByToken[id].length();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query holders of given token\\r\\n\\t * @param _tokenId token id to query\\r\\n\\t * @return list of holder addresses\\r\\n\\t */\\r\\n\\tfunction accountsByToken(uint256 _tokenId) internal view returns (address[] memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tEnumerableSet.AddressSet storage accounts = e1155s.accountsByToken[_tokenId];\\r\\n\\r\\n\\t\\taddress[] memory addresses = new address[](accounts.length());\\r\\n\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tfor (uint256 i; i < accounts.length(); i++) {\\r\\n\\t\\t\\t\\taddresses[i] = accounts.at(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn addresses;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice query tokens held by given address\\r\\n\\t * @param _account address to query\\r\\n\\t * @return list of token ids\\r\\n\\t */\\r\\n\\tfunction tokensByAccount(address _account) internal view returns (uint256[] memory) {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\tEnumerableSet.UintSet storage tokens = e1155s.tokensByAccount[_account];\\r\\n\\r\\n\\t\\tuint256[] memory ids = new uint256[](tokens.length());\\r\\n\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tfor (uint256 i; i < tokens.length(); i++) {\\r\\n\\t\\t\\t\\tids[i] = tokens.at(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ids;\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * IERC1155Pausable\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\tfunction _whenNotPaused(ERC1155Storage storage e1155s) internal view {\\r\\n\\t\\trequire(!e1155s.paused, \\\"All token is paused!\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction _whenTokenNotPaused(ERC1155Storage storage e1155s, uint256 _tokenId) internal view {\\r\\n\\t\\t_whenNotPaused(e1155s);\\r\\n\\t\\trequire(!e1155s.pausedToken[_tokenId], \\\"Token is paused!\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction whenNotPaused() internal view {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\t_whenNotPaused(e1155s);\\r\\n\\t}\\r\\n\\r\\n\\tfunction whenTokenNotPaused(uint256 _tokenId) internal view {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\t_whenTokenNotPaused(e1155s, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\tfunction pauseAllToken(address _operator) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\trequire(!e1155s.paused, \\\"All tokens are already paused\\\");\\r\\n\\t\\te1155s.paused = true;\\r\\n\\t\\temit AllTokenPaused(_operator);\\r\\n\\t}\\r\\n\\r\\n\\tfunction unpauseAllToken(address _operator) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\trequire(e1155s.paused, \\\"All tokens are not paused yet\\\");\\r\\n\\t\\te1155s.paused = false;\\r\\n\\t\\temit AllTokenUnpaused(_operator);\\r\\n\\t}\\r\\n\\r\\n\\tfunction pauseToken(address _operator, uint256 _tokenId) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\trequire(!e1155s.pausedToken[_tokenId], \\\"Token is already paused\\\");\\r\\n\\t\\te1155s.pausedToken[_tokenId] = true;\\r\\n\\t\\temit TokenPaused(_operator, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\tfunction unpauseToken(address _operator, uint256 _tokenId) internal {\\r\\n\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\t\\trequire(e1155s.pausedToken[_tokenId], \\\"Token is not paused yet\\\");\\r\\n\\t\\te1155s.pausedToken[_tokenId] = false;\\r\\n\\t\\temit TokenUnpaused(_operator, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/************************************************************************************************************\\r\\n\\t *\\r\\n\\t * Library internal helper functions\\r\\n\\t *\\r\\n\\t ************************************************************************************************************/\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenId token ID\\r\\n\\t * @param _amount quantity of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction _doSafeTransferAcceptanceCheck(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\tuint256 _amount,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tif (_toAccount.isContract()) {\\r\\n\\t\\t\\ttry IERC1155Receiver(_toAccount).onERC1155Received(_operator, _fromAccount, _tokenId, _amount, _data) returns (\\r\\n\\t\\t\\t\\tbytes4 response\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\tif (response != IERC1155Receiver.onERC1155Received.selector) revert LibERC1155__ERC1155ReceiverRejected();\\r\\n\\t\\t\\t} catch Error(string memory reason) {\\r\\n\\t\\t\\t\\trevert(reason);\\r\\n\\t\\t\\t} catch {\\r\\n\\t\\t\\t\\trevert LibERC1155__ERC1155ReceiverNotImplemented();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction _doSafeBatchTransferAcceptanceCheck(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) private {\\r\\n\\t\\tif (_toAccount.isContract()) {\\r\\n\\t\\t\\ttry IERC1155Receiver(_toAccount).onERC1155BatchReceived(_operator, _fromAccount, _tokenIds, _amounts, _data) returns (\\r\\n\\t\\t\\t\\tbytes4 response\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\tif (response != IERC1155Receiver.onERC1155BatchReceived.selector) revert LibERC1155__ERC1155ReceiverRejected();\\r\\n\\t\\t\\t} catch Error(string memory reason) {\\r\\n\\t\\t\\t\\trevert(reason);\\r\\n\\t\\t\\t} catch {\\r\\n\\t\\t\\t\\trevert LibERC1155__ERC1155ReceiverNotImplemented();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\\r\\n\\t\\tuint256[] memory array = new uint256[](1);\\r\\n\\t\\tarray[0] = element;\\r\\n\\t\\treturn array;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC1155 hook, called before all transfers including mint and burn\\r\\n\\t * The same hook is called on both single and batched variants. For single\\r\\n\\t * transfers, the length of the `ids` and `amounts` arrays will be 1.\\r\\n\\t * Calling conditions (for each `id` and `amount` pair):\\r\\n\\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\\r\\n\\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\\r\\n\\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\\r\\n\\t * - `from` and `to` are never both zero.\\r\\n\\t * - `ids` and `amounts` have the same, non-zero length.\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction _beforeTokenTransfer(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tif (_fromAccount != _toAccount) {\\r\\n\\t\\t\\tERC1155Storage storage e1155s = LibERC1155Storage.layout();\\r\\n\\r\\n\\t\\t\\tmapping(uint256 => EnumerableSet.AddressSet) storage tokenAccounts = e1155s.accountsByToken;\\r\\n\\r\\n\\t\\t\\tEnumerableSet.UintSet storage fromAccountTokens = e1155s.tokensByAccount[_fromAccount];\\r\\n\\t\\t\\tEnumerableSet.UintSet storage toAccountTokens = e1155s.tokensByAccount[_toAccount];\\r\\n\\r\\n\\t\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\t\\tuint256 amount = _amounts[i];\\r\\n\\r\\n\\t\\t\\t\\tif (amount > 0) {\\r\\n\\t\\t\\t\\t\\tuint256 id = _tokenIds[i];\\r\\n\\r\\n\\t\\t\\t\\t\\tif (_fromAccount == address(0)) {\\r\\n\\t\\t\\t\\t\\t\\te1155s.totalSupply[id] += amount;\\r\\n\\t\\t\\t\\t\\t} else if (balanceOf(_fromAccount, id) == amount) {\\r\\n\\t\\t\\t\\t\\t\\ttokenAccounts[id].remove(_fromAccount);\\r\\n\\t\\t\\t\\t\\t\\tfromAccountTokens.remove(id);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif (_toAccount == address(0)) {\\r\\n\\t\\t\\t\\t\\t\\te1155s.totalSupply[id] -= amount;\\r\\n\\t\\t\\t\\t\\t} else if (balanceOf(_toAccount, id) == 0) {\\r\\n\\t\\t\\t\\t\\t\\ttokenAccounts[id].add(_toAccount);\\r\\n\\t\\t\\t\\t\\t\\ttoAccountTokens.add(id);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tLibERC1155Customization._beforeTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC1155 hook, called after all transfers including mint and burn\\r\\n\\t * The same hook is called on both single and batched variants. For single\\r\\n\\t * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n\\t * Calling conditions (for each `id` and `amount` pair):\\r\\n\\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\\r\\n\\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\\r\\n\\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\\r\\n\\t * - `from` and `to` are never both zero.\\r\\n\\t * - `ids` and `amounts` have the same, non-zero length.\\r\\n\\t * @param _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t * @param _data data payload\\r\\n\\t */\\r\\n\\tfunction _afterTokenTransfer(\\r\\n\\t\\taddress _operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal {\\r\\n\\t\\tLibERC1155Customization._afterTokenTransfer(_operator, _fromAccount, _toAccount, _tokenIds, _amounts, _data);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xec6b5201d39937703eb059c34d4289ad4e2eb03f1dcbfd648165fe2e1ac7354f\",\"license\":\"MIT\"},\"contracts/base/ERC1155/base/LibERC1155Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct ERC1155ReceiverStorage {\\r\\n\\tbytes data;\\r\\n\\taddress operator;\\r\\n\\taddress from;\\r\\n\\tuint256[] ids;\\r\\n\\tuint256[] values;\\r\\n}\\r\\n\\r\\nstruct ERC1155Storage {\\r\\n\\tmapping(uint256 => mapping(address => uint256)) balances; // Mapping from token ID to account balances\\r\\n\\tmapping(address => mapping(address => bool)) operatorApprovals; // Mapping from account to operator approvals\\r\\n\\tmapping(uint256 => bool) operatorSpendingLimitEnabled;\\r\\n\\tmapping(address => mapping(address => mapping(uint256 => uint256))) allowances;\\r\\n\\tmapping(uint256 => uint256) totalSupply;\\r\\n\\tmapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\\r\\n\\tmapping(address => EnumerableSet.UintSet) tokensByAccount;\\r\\n\\tstring uri; // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n\\tstring baseURI; // Optional base URI, e.g. ipfs://53453534\\r\\n\\tmapping(uint256 => string) tokenURIs; // Optional mapping for token URIs, e.g. 4236464216781, so tokenURI will be: ipfs://53453534/4236464216781\\r\\n\\tbool paused;\\r\\n\\tmapping(uint256 => bool) pausedToken;\\r\\n\\tuint256 receivedTokensLength;\\r\\n\\tmapping(uint256 => ERC1155ReceiverStorage) receivedTokens;\\r\\n}\\r\\n\\r\\nlibrary LibERC1155Storage {\\r\\n\\tbytes32 internal constant ERC1155_STORAGE_SLOT = keccak256(\\\"usmart.contracts.erc1155-base.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (ERC1155Storage storage e1155s_) {\\r\\n\\t\\tbytes32 position = ERC1155_STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\te1155s_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x4e6183d99d461002f2e4873dd8ecc52d243537e0bb5f364b708c45e4ea533ba0\",\"license\":\"MIT\"},\"contracts/base/ERC1155/customization/LibERC1155Customization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"../../TokenRestriction/LibTokenRestriction.sol\\\";\\r\\nimport \\\"../../TokenPNL/LibTokenPNL.sol\\\";\\r\\n\\r\\nimport \\\"../../../ArexaPlatform/Platform/LibArexaPlatform.sol\\\";\\r\\n\\r\\nlibrary LibERC1155Customization {\\r\\n\\t/**\\r\\n\\t * @notice ERC1155 hook, called before all transfers including mint and burn\\r\\n\\t * The same hook is called on both single and batched variants. For single\\r\\n\\t * transfers, the length of the `ids` and `amounts` arrays will be 1.\\r\\n\\t * Calling conditions (for each `id` and `amount` pair):\\r\\n\\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\\r\\n\\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\\r\\n\\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\\r\\n\\t * - `from` and `to` are never both zero.\\r\\n\\t * - `ids` and `amounts` have the same, non-zero length.\\r\\n\\t *  param_operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t *  param_toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t *  param _data data payload\\r\\n\\t */\\r\\n\\tfunction _beforeTokenTransfer(\\r\\n\\t\\taddress, //_operator,\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress, //_toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory //_data\\r\\n\\t) internal view {\\r\\n\\t\\tif (_fromAccount != address(0)) {\\r\\n\\t\\t\\tLibTokenRestriction.checkRestrictions(_fromAccount, _tokenIds, _amounts);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC1155 hook, called after all transfers including mint and burn\\r\\n\\t * The same hook is called on both single and batched variants. For single\\r\\n\\t * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n\\t * Calling conditions (for each `id` and `amount` pair):\\r\\n\\t * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens of token type `id` will be  transferred to `to`.\\r\\n\\t * - When `from` is zero, `amount` tokens of token type `id` will be minted for `to`.\\r\\n\\t * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` will be burned.\\r\\n\\t * - `from` and `to` are never both zero.\\r\\n\\t * - `ids` and `amounts` have the same, non-zero length.\\r\\n\\t * _operator executor of transfer\\r\\n\\t * @param _fromAccount sender of tokens\\r\\n\\t * @param _toAccount receiver of tokens\\r\\n\\t * @param _tokenIds token IDs\\r\\n\\t * @param _amounts quantities of tokens to transfer\\r\\n\\t * _data data payload\\r\\n\\t */\\r\\n\\tfunction _afterTokenTransfer(\\r\\n\\t\\taddress, //_operator\\r\\n\\t\\taddress _fromAccount,\\r\\n\\t\\taddress _toAccount,\\r\\n\\t\\tuint256[] memory _tokenIds,\\r\\n\\t\\tuint256[] memory _amounts,\\r\\n\\t\\tbytes memory //_data\\r\\n\\t) internal {\\r\\n\\t\\tif (_fromAccount != address(0)) {\\r\\n\\t\\t\\tLibTokenRestriction.recalcRestrictions(_fromAccount, _tokenIds, _amounts, 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_toAccount != address(0)) {\\r\\n\\t\\t\\tLibTokenRestriction.recalcRestrictions(_toAccount, _tokenIds, _amounts, 1);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\tLibTokenPNL.refreshDivident(address(LibArexaPlatform.getPayingToken()), _tokenIds[i], _fromAccount, _toAccount, _amounts[i]);\\r\\n\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xa2fa034ab7aaeea33bba77ed66ff88ae0adcfa1c025761c46b686c1f091cfce7\",\"license\":\"MIT\"},\"contracts/base/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\t/**\\n\\t * @notice query the total minted token supply\\n\\t * @return token supply\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice query the token balance of given account\\n\\t * @param account address to query\\n\\t * @return token balance\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice query the allowance granted from given holder to given spender\\n\\t * @param holder approver of allowance\\n\\t * @param spender recipient of allowance\\n\\t * @return token allowance\\n\\t */\\n\\tfunction allowance(address holder, address spender) external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice grant approval to spender to spend tokens\\n\\t * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n\\t * @param spender recipient of allowance\\n\\t * @param amount quantity of tokens approved for spending\\n\\t * @return success status (always true; otherwise function should revert)\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @notice transfer tokens to given recipient\\n\\t * @param recipient beneficiary of token transfer\\n\\t * @param amount quantity of tokens to transfer\\n\\t * @return success status (always true; otherwise function should revert)\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @notice transfer tokens to given recipient on behalf of given holder\\n\\t * @param holder holder of tokens prior to transfer\\n\\t * @param recipient beneficiary of token transfer\\n\\t * @param amount quantity of tokens to transfer\\n\\t * @return success status (always true; otherwise function should revert)\\n\\t */\\n\\tfunction transferFrom(address holder, address recipient, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x2225a383553a4a87b9b6577c7b90eff90b4b6a0e967c97d0a3fd5291a290d8db\",\"license\":\"MIT\"},\"contracts/base/ERC20/metadata/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n\\t/**\\n\\t * @notice return token name\\n\\t * @return token name\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @notice return token symbol\\n\\t * @return token symbol\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @notice return token decimals, generally used only for display purposes\\n\\t * @return token decimals\\n\\t */\\n\\tfunction decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaef9c65c2330d80a184d3d59dbe37f80af62f88c5f707a2e36dd1377ba04898d\",\"license\":\"MIT\"},\"contracts/base/Shared/ProtectedCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibDiamond } from \\\"../Diamond/LibDiamond.sol\\\";\\r\\n\\r\\ncontract CallProtection {\\r\\n\\tmodifier protectedCall() {\\r\\n\\t\\trequire(address(this) == LibDiamond.getDiamondAddress(), \\\"NOT_ALLOWED\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xc15612f2411ec779b6036b14a4495f5b402178ebb0864d727cb5cc01f917b798\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/LibTargetedPausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibTargetedPausableStorage.sol\\\";\\r\\n\\r\\nlibrary LibTargetedPausable {\\r\\n\\terror TargetedPausable__TargetedPaused();\\r\\n\\terror TargetedPausable__NotTargetedPaused();\\r\\n\\r\\n\\t//target: what was paused\\r\\n\\t//account: the operator who is paused the target\\r\\n\\tevent TargetedPaused(bytes32 indexed target, address indexed account);\\r\\n\\r\\n\\t//target: what was unpaused\\r\\n\\t//account: the operator who is unpaused the target\\r\\n\\tevent TargetedUnpaused(bytes32 target, address indexed account);\\r\\n\\r\\n\\tfunction _whenNotPaused(bytes32 _target) internal view {\\r\\n\\t\\tif (LibTargetedPausable._paused(_target)) revert TargetedPausable__TargetedPaused();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _whenPaused(bytes32 _target) internal view {\\r\\n\\t\\tif (!LibTargetedPausable._paused(_target)) revert TargetedPausable__NotTargetedPaused();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _paused(bytes32 _target) internal view returns (bool paused_) {\\r\\n\\t\\tpaused_ = LibTargetedPausableStorage.layout().paused[_target];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _pause(bytes32 _target, address _operator) internal {\\r\\n\\t\\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\\r\\n\\t\\tif (ps.paused[_target]) revert TargetedPausable__TargetedPaused();\\r\\n\\t\\tps.paused[_target] = true;\\r\\n\\t\\temit TargetedPaused(_target, _operator);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _unpause(bytes32 _target, address _operator) internal {\\r\\n\\t\\tTargetedPausableStorage storage ps = LibTargetedPausableStorage.layout();\\r\\n\\t\\tif (!ps.paused[_target]) revert TargetedPausable__NotTargetedPaused();\\r\\n\\t\\tps.paused[_target] = false;\\r\\n\\t\\tdelete ps.paused[_target];\\r\\n\\t\\temit TargetedUnpaused(_target, _operator);\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x29bcbce5b5f8cc5c33029d568ffb11b1bc807cfb0ad22acd6c69b79acf2b3d8b\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/LibTargetedPausableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct TargetedPausableStorage {\\r\\n\\tmapping(bytes32 => bool) paused;\\r\\n}\\r\\n\\r\\nlibrary LibTargetedPausableStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.targeted-pausable.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (TargetedPausableStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x3a8d48db3da71fb9df91fe855d32fb0dd634556499739c6c277842021c92438d\",\"license\":\"MIT\"},\"contracts/base/TargetedPausable/ModifierPausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { LibTargetedPausable } from \\\"./LibTargetedPausable.sol\\\";\\r\\n\\r\\nabstract contract ModifierPausable {\\r\\n\\t//\\r\\n\\tmodifier whenNotPaused(bytes32 target) {\\r\\n\\t\\tLibTargetedPausable._whenNotPaused(target);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier whenPaused(bytes32 target) {\\r\\n\\t\\tLibTargetedPausable._whenPaused(target);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x5a08a624e6849e716dc267f8e1d6f171594ab1560bd0097b11d2f9950276a9a9\",\"license\":\"MIT\"},\"contracts/base/TokenDynamicPricing/LibTokenDynamicPricing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibTokenDynamicPricingStorage.sol\\\";\\r\\n\\r\\nimport \\\"../../utils/Math.sol\\\";\\r\\n\\r\\nlibrary LibTokenDynamicPricing {\\r\\n\\tfunction initialize(uint256 _tokenId, uint256 _initialQuantity, uint256 _min, uint256 _max) internal {\\r\\n\\t\\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\\r\\n\\t\\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\\r\\n\\r\\n\\t\\tpricing.isEnabled = true;\\r\\n\\t\\tpricing.quantity = _initialQuantity;\\r\\n\\t\\tpricing.k = (_min == 0) ? _initialQuantity * _initialQuantity : _initialQuantity * _initialQuantity * _min;\\r\\n\\t\\tpricing.min = _min; //must contain the decimals of the paying token!!!\\r\\n\\t\\tpricing.max = (_max == 0 || _max < _min) ? pricing.k : _max; //must contain the decimals of the paying token!!!\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calcTotalValue(DynamicPricing storage pricing, uint256 _quantity) internal view returns (uint256) {\\r\\n\\t\\trequire(pricing.isEnabled, \\\"Calculation is not enabled for the token!\\\");\\r\\n\\t\\trequire(_quantity <= pricing.quantity, \\\"Not enought quantity left!\\\");\\r\\n\\t\\tuint256 totalValue = (((10 * _quantity * pricing.k) / (pricing.quantity * (pricing.quantity - _quantity + 1))) + 5) / 10;\\r\\n\\t\\treturn Math.min(_quantity * pricing.max, Math.max(_quantity * pricing.min, totalValue));\\r\\n\\t}\\r\\n\\r\\n\\tfunction calcTotalValue(uint256 _tokenId, uint256 _quantity) internal view returns (uint256) {\\r\\n\\t\\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\\r\\n\\t\\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\\r\\n\\t\\treturn _calcTotalValue(pricing, _quantity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction buyQuantity(uint256 _tokenId, uint256 _quantity) internal returns (uint256) {\\r\\n\\t\\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\\r\\n\\t\\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\\r\\n\\t\\tuint256 totalValue = _calcTotalValue(pricing, _quantity);\\r\\n\\r\\n\\t\\tpricing.quantity = pricing.quantity - _quantity;\\r\\n\\t\\tpricing.totalValue = pricing.totalValue + totalValue;\\r\\n\\r\\n\\t\\tif (pricing.quantity == 0) {\\r\\n\\t\\t\\tpricing.isEnabled = false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn totalValue;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getEnabled(uint256 _tokenId) internal view returns (bool) {\\r\\n\\t\\t//\\r\\n\\t\\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\\r\\n\\t\\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\\r\\n\\t\\treturn pricing.isEnabled;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setPricingEnabled(uint256 _tokenId, bool _enabledValue) internal {\\r\\n\\t\\tTokenDynamicPricingStorage storage dynamicPricing = LibTokenDynamicPricingStorage.layout();\\r\\n\\t\\tDynamicPricing storage pricing = dynamicPricing.tokenDynamicPricing[_tokenId];\\r\\n\\t\\trequire(\\r\\n\\t\\t\\t!_enabledValue || (_enabledValue && pricing.quantity > 0),\\r\\n\\t\\t\\t\\\"Reenable of token pricing is only availabe is there is som token left to sell!\\\"\\r\\n\\t\\t);\\r\\n\\t\\tpricing.isEnabled = _enabledValue;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xc812e1d7630c7bd8fd1ea671d8071ea4073f795248963a24310c194d80aea06a\",\"license\":\"MIT\"},\"contracts/base/TokenDynamicPricing/LibTokenDynamicPricingStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct DynamicPricing {\\r\\n\\tbool isEnabled;\\r\\n\\tuint256 quantity;\\r\\n\\tuint256 totalValue;\\r\\n\\tuint256 k;\\r\\n\\tuint256 min;\\r\\n\\tuint256 max;\\r\\n}\\r\\n\\r\\nstruct TokenDynamicPricingStorage {\\r\\n\\t//tokenId => restriction, every token have\\r\\n\\tmapping(uint256 => DynamicPricing) tokenDynamicPricing;\\r\\n}\\r\\n\\r\\nlibrary LibTokenDynamicPricingStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.token-dynamic-pricing.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (TokenDynamicPricingStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xd2c22e58724632328816b6c260a176e5ed1788e37966f7775a0dd19ef0ae4d92\",\"license\":\"MIT\"},\"contracts/base/TokenPNL/LibTokenPNL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n//import \\\"hardhat/console.sol\\\";\\r\\n\\r\\nimport \\\"./LibTokenPNLStorage.sol\\\";\\r\\n\\r\\nlibrary LibTokenPNL {\\r\\n\\tfunction initTokenPNL(address _contract, uint256 _tokenId) internal {\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tinventory.isEnabled = true;\\r\\n\\t\\tinventory.sumQuantity = 0;\\r\\n\\t\\tinventory.sumAmount = 0;\\r\\n\\t\\tinventory.sumPnl = 0;\\r\\n\\t}\\r\\n\\r\\n\\tfunction changeTotalValue(address _contract, uint256 _tokenId, int256 _amount) internal {\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tif (!inventory.isEnabled) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//because every transfer, mint and burn do like ralizing the pnl\\r\\n\\t\\t//and after this realizing the user can payout the collected a PNL\\r\\n\\t\\t//so decreasing the value can cause money loss in the contract!!!\\r\\n\\t\\t//if wanted full inventory feature in a distributed way: ask uSmart ;)\\r\\n\\t\\trequire(_amount >= 0, \\\"Pool can only increase!\\\");\\r\\n\\r\\n\\t\\tinventory.sumAmount += _amount;\\r\\n\\t\\tinventory.sumPnl += _amount; //Here is the MAGIC!\\r\\n\\r\\n\\t\\t// console.log(\\\"ChangeTotalValue\\\");\\r\\n\\t\\t// console.log(\\\"_tokenId\\\", _tokenId);\\r\\n\\t\\t// if (inventory.sumAmount >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumAmount\\\", uint256(inventory.sumAmount));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumAmount -\\\", uint256(-1 * inventory.sumAmount));\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\t// if (inventory.sumPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl\\\", uint256(inventory.sumPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl -\\\", uint256(-1 * inventory.sumPnl));\\r\\n\\t\\t// }\\r\\n\\t}\\r\\n\\r\\n\\tfunction getInventory(\\r\\n\\t\\taddress _contract,\\r\\n\\t\\tuint256 _tokenId\\r\\n\\t) internal view returns (bool isEnabled, int256 sumQuantity, int256 sumAmount, int256 sumPnl) {\\r\\n\\t\\t//\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\treturn (inventory.isEnabled, inventory.sumQuantity, inventory.sumAmount, inventory.sumPnl);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getInventoryItem(\\r\\n\\t\\taddress _contract,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\taddress _account\\r\\n\\t) internal view returns (InventoryItem memory inventoryItem) {\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tinventoryItem = inventory.divident[_account];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _refreshDividentInternal(Inventory storage inventory, address _account, int256 _quantity) internal {\\r\\n\\t\\tInventoryItem storage inventoryItem = inventory.divident[_account];\\r\\n\\r\\n\\t\\trequire(inventory.sumQuantity + _quantity >= 0, \\\"Pool token quanity can't be less then zero!\\\");\\r\\n\\t\\trequire(inventoryItem.quantity + _quantity >= 0, \\\"User token quanity can't be less then zero!\\\");\\r\\n\\r\\n\\t\\t// console.log(\\\"_refreshDividentInternal\\\");\\r\\n\\t\\t// console.log(\\\"account\\\", _account);\\r\\n\\r\\n\\t\\t// if (inventory.sumQuantity >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumQuantity\\\", uint256(inventory.sumQuantity));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumQuantity -\\\", uint256(-1 * inventory.sumQuantity));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventory.sumPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl\\\", uint256(inventory.sumPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl -\\\", uint256(-1 * inventory.sumPnl));\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\tint256 addressPnlDelta = 0;\\r\\n\\t\\tif (inventory.sumQuantity != 0) {\\r\\n\\t\\t\\taddressPnlDelta = (inventory.sumPnl * _quantity) / inventory.sumQuantity;\\r\\n\\t\\t}\\r\\n\\t\\t// if (addressPnlDelta >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"addressPnlDelta\\\", uint256(addressPnlDelta));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"addressPnlDelta -\\\", uint256(-1 * addressPnlDelta));\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\tinventory.sumQuantity = inventory.sumQuantity + _quantity;\\r\\n\\t\\tinventory.sumPnl = inventory.sumPnl + addressPnlDelta;\\r\\n\\t\\tinventoryItem.quantity = inventoryItem.quantity + _quantity;\\r\\n\\t\\tinventoryItem.deltaPnl = inventoryItem.deltaPnl - addressPnlDelta;\\r\\n\\r\\n\\t\\t// if (inventory.sumQuantity >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventory.sumQuantity\\\", uint256(inventory.sumQuantity));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventory.sumQuantity -\\\", uint256(-1 * inventory.sumQuantity));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventory.sumPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventory.sumPnl\\\", uint256(inventory.sumPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventory.sumPnl -\\\", uint256(-1 * inventory.sumPnl));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventoryItem.quantity >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventoryItem.quantity\\\", uint256(inventoryItem.quantity));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventoryItem.quantity -\\\", uint256(-1 * inventoryItem.quantity));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventoryItem.deltaPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventoryItem.deltaPnl\\\", uint256(inventoryItem.deltaPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"NEW inventoryItem.deltaPnl -\\\", uint256(-1 * inventoryItem.deltaPnl));\\r\\n\\t\\t// }\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshDivident(address _contract, uint256 _tokenId, address _fromAccount, address _toAccount, uint256 _quantity) internal {\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tif (!inventory.isEnabled) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_fromAccount != address(0)) {\\r\\n\\t\\t\\t_refreshDividentInternal(inventory, _fromAccount, -1 * int256(_quantity));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_toAccount != address(0)) {\\r\\n\\t\\t\\t_refreshDividentInternal(inventory, _toAccount, int256(_quantity));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction calcDivident(address _contract, uint256 _tokenId, address _account) internal view returns (int256) {\\r\\n\\t\\tif (_account == address(0)) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tif (!inventory.isEnabled) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tInventoryItem storage inventoryItem = inventory.divident[_account];\\r\\n\\t\\t//calculate actual value of the token\\r\\n\\t\\tint256 actValue = 0;\\r\\n\\t\\tif (inventory.sumQuantity != 0) {\\r\\n\\t\\t\\tactValue = (inventory.sumPnl * inventoryItem.quantity) / inventory.sumQuantity;\\r\\n\\t\\t}\\r\\n\\t\\t//the divident is equal with the actual value minus the summa pnlDelta\\r\\n\\t\\t//note: the pnlDelta already have the negative sign!!!\\r\\n\\t\\tint256 actDivident = actValue + inventoryItem.deltaPnl - inventoryItem.payedPnl;\\r\\n\\r\\n\\t\\t// console.log(\\\"calcDivident\\\");\\r\\n\\t\\t// if (inventory.sumPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl\\\", uint256(inventory.sumPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumPnl -\\\", uint256(-1 * inventory.sumPnl));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventoryItem.quantity >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.quantity\\\", uint256(inventoryItem.quantity));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.quantity -\\\", uint256(-1 * inventoryItem.quantity));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventory.sumQuantity >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumQuantity\\\", uint256(inventory.sumQuantity));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventory.sumQuantity -\\\", uint256(-1 * inventory.sumQuantity));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventoryItem.deltaPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.deltaPnl\\\", uint256(inventoryItem.deltaPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.deltaPnl -\\\", uint256(-1 * inventoryItem.deltaPnl));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (inventoryItem.payedPnl >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.payedPnl\\\", uint256(inventoryItem.payedPnl));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"inventoryItem.payedPnl -\\\", uint256(-1 * inventoryItem.payedPnl));\\r\\n\\t\\t// }\\r\\n\\t\\t// if (actDivident >= 0) {\\r\\n\\t\\t// \\tconsole.log(\\\"actDivident\\\", uint256(actDivident));\\r\\n\\t\\t// } else {\\r\\n\\t\\t// \\tconsole.log(\\\"actDivident -\\\", uint256(-1 * actDivident));\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\treturn actDivident;\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshPayoutDivident(address _contract, uint256 _tokenId, address _account, int256 _amount) internal {\\r\\n\\t\\tTokenPNLStorage storage tokenPNL = LibTokenPNLStorage.layout();\\r\\n\\t\\tInventory storage inventory = tokenPNL.inventory[_contract][_tokenId];\\r\\n\\t\\tif (!inventory.isEnabled) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\trequire(_amount >= 0, \\\"Only positive amount can be payed out!\\\");\\r\\n\\r\\n\\t\\tint256 payableDivident = calcDivident(_contract, _tokenId, _account);\\r\\n\\r\\n\\t\\trequire(_amount <= payableDivident, \\\"The amount is bigger then tha payable divident!\\\");\\r\\n\\r\\n\\t\\tInventoryItem storage inventoryItem = inventory.divident[_account];\\r\\n\\t\\tinventoryItem.payedPnl = inventoryItem.payedPnl + _amount;\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x7fce11ffc01fd264db7b60cd5f9e250bb1e128f91d0be93aee6aef287233d707\",\"license\":\"MIT\"},\"contracts/base/TokenPNL/LibTokenPNLStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\nimport { IERC20 } from \\\"../../base/ERC20/IERC20.sol\\\";\\r\\n\\r\\nstruct InventoryItem {\\r\\n\\tint256 quantity;\\r\\n\\tint256 deltaPnl; //After calculating the act Pnl based on the quantity this is a Pnl modification factor!\\r\\n\\tint256 payedPnl;\\r\\n}\\r\\n\\r\\nstruct Inventory {\\r\\n\\tbool isEnabled;\\r\\n\\tint256 sumQuantity;\\r\\n\\tint256 sumAmount;\\r\\n\\tint256 sumPnl;\\r\\n\\t//Account - pool divident calculation\\r\\n\\tmapping(address => InventoryItem) divident;\\r\\n}\\r\\n\\r\\nstruct TokenPNLStorage {\\r\\n\\t//contract => tokenId => inventory map\\r\\n\\t//Eg: IERC20 => 0 => inventory\\r\\n\\t//Eg: IERC1155 => tokenId => Inventory\\r\\n\\tmapping(address => mapping(uint256 => Inventory)) inventory;\\r\\n}\\r\\n\\r\\nlibrary LibTokenPNLStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.token-pnl.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (TokenPNLStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x2ad5ccdae091ea94e36dce8d852d697f8569b438284f51a4a983a7c0d4b9de8b\",\"license\":\"MIT\"},\"contracts/base/TokenRestriction/LibTokenRestriction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n//import \\\"hardhat/console.sol\\\";\\r\\n\\r\\nimport \\\"./LibTokenRestrictionStorage.sol\\\";\\r\\nimport \\\"../../base/ERC1155/base/LibERC1155.sol\\\";\\r\\nimport \\\"../../utils/Math.sol\\\";\\r\\n\\r\\nimport { IERC20 } from \\\"../../base/ERC20/IERC20.sol\\\";\\r\\n\\r\\nlibrary LibTokenRestriction {\\r\\n\\tfunction initTokenRestriction(uint256 _tokenId, uint256 _endOfRestriction, uint256 _endOfRestrictionCalc, uint256 _timeDelta) internal {\\r\\n\\t\\t// require(block.number + 12 * _timeDelta < _endOfRestriction);\\r\\n\\t\\t// require(_endOfRestriction + 12 * _timeDelta < _endOfRestrictionCalc);\\r\\n\\r\\n\\t\\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\\r\\n\\t\\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\\r\\n\\t\\tif ((restriction.endOfRestrictionCalc == 0) || (restriction.endOfRestriction + 1 == restriction.endOfRestrictionCalc)) {\\r\\n\\t\\t\\trestriction.endOfRestriction = _endOfRestriction;\\r\\n\\t\\t\\trestriction.endOfRestrictionCalc = _endOfRestrictionCalc;\\r\\n\\t\\t\\trestriction.timeDelta = _timeDelta;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction calcUnrestrictedAmount(address _account, uint256 _tokenId, uint256 _amount) internal view returns (uint256) {\\r\\n\\t\\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\\r\\n\\t\\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\\r\\n\\r\\n\\t\\tif (restriction.endOfRestrictionCalc < block.number) {\\r\\n\\t\\t\\treturn _amount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if (restriction.endOfRestriction < block.number) {\\r\\n\\t\\t// \\treturn _amount;\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\tRestrictionCalc storage accRestr = restriction.restriction[_account];\\r\\n\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((K8-I8)/L8)*(E8-M8)/12)\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumulated)/12)\\r\\n\\t\\t// console.log(\\\"calcUnrestrictedAmount\\\");\\r\\n\\t\\t// console.log(\\\"account\\\", _account);\\r\\n\\t\\t// console.log(\\\"blocknumber\\\", block.number);\\r\\n\\t\\t// console.log(\\\"accRestr.time\\\", accRestr.time);\\r\\n\\t\\t// console.log(\\\"restriction.timeDelta\\\", restriction.timeDelta);\\r\\n\\t\\t// console.log(\\\"accRestr.bought\\\", accRestr.bought);\\r\\n\\t\\t// console.log(\\\"accRestr.accumulated\\\", accRestr.accumulated);\\r\\n\\t\\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\\r\\n\\t\\t// console.log(\\\"helper\\\", helper);\\r\\n\\r\\n\\t\\t//=MIN(M10+Q10;E10)-G10\\r\\n\\t\\t//=MIN(accumulated+helper;bought)-sold\\r\\n\\t\\tuint256 canSell = Math.min(accRestr.accumulated + helper, accRestr.bought) - accRestr.sold;\\r\\n\\t\\t// console.log(\\\"canSell\\\", canSell);\\r\\n\\r\\n\\t\\treturn canSell;\\r\\n\\t}\\r\\n\\r\\n\\tfunction checkRestriction(address _account, uint256 _tokenId, uint256 _amount) internal view {\\r\\n\\t\\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\\r\\n\\t\\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\\r\\n\\r\\n\\t\\tif (restriction.endOfRestrictionCalc <= block.number) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if (restriction.endOfRestriction < block.number) {\\r\\n\\t\\t// \\treturn;\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\tRestrictionCalc storage accRestr = restriction.restriction[_account];\\r\\n\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((K8-I8)/L8)*(E8-M8)/12)\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumulated)/12)\\r\\n\\t\\t// console.log(\\\"CheckRestriction\\\");\\r\\n\\t\\t// console.log(\\\"account\\\", _account);\\r\\n\\t\\t// console.log(\\\"blocknumber\\\", block.number);\\r\\n\\t\\t// console.log(\\\"accRestr.time\\\", accRestr.time);\\r\\n\\t\\t// console.log(\\\"restriction.timeDelta\\\", restriction.timeDelta);\\r\\n\\t\\t// console.log(\\\"accRestr.bought\\\", accRestr.bought);\\r\\n\\t\\t// console.log(\\\"accRestr.accumulated\\\", accRestr.accumulated);\\r\\n\\t\\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\\r\\n\\t\\t// console.log(\\\"helper\\\", helper);\\r\\n\\r\\n\\t\\t//=MIN(M10+Q10;E10)-G10\\r\\n\\t\\t//=MIN(accumulated+helper;bought)-sold\\r\\n\\t\\tuint256 canSell = Math.min(accRestr.accumulated + helper, accRestr.bought) - accRestr.sold;\\r\\n\\t\\t// console.log(\\\"canSell\\\", canSell);\\r\\n\\r\\n\\t\\trequire(_amount <= canSell, \\\"The amount is grater then the accumlated ('sellable') amount!\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction checkRestrictions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts) internal view {\\r\\n\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\tcheckRestriction(_account, _tokenIds[i], _amounts[i]);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction recalcRestriction(address _account, uint256 _tokenId, uint256 _amount, uint8 _direction) internal {\\r\\n\\t\\t//eladhat\\u00f3 mennyis\\u00e9g kalkul\\u00e1ci\\u00f3hoz\\r\\n\\t\\tTokenRestrictionStorage storage arexa = LibTokenRestrictionStorage.layout();\\r\\n\\t\\tRestriction storage restriction = arexa.tokenRestriction[_tokenId];\\r\\n\\r\\n\\t\\tif (restriction.endOfRestrictionCalc <= block.number) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tRestrictionCalc storage accRestr = restriction.restriction[_account];\\r\\n\\r\\n\\t\\tif (restriction.endOfRestriction <= block.number) {\\r\\n\\t\\t\\t//valami m\\u00e1st kell csin\\u00e1lni\\r\\n\\t\\t\\tif (_direction == 1) {\\r\\n\\t\\t\\t\\taccRestr.bought += _amount;\\r\\n\\t\\t\\t\\taccRestr.accumulated += _amount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//friss\\u00edteni \\u00fczemszer\\u0171en.\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((J12-I12)/L12)*(E12-M12)/12)\\r\\n\\t\\t//=FLOOR.MATH(FLOOR.MATH((actTime-time)/timeDelta)*(bought-accumlated)/12)\\r\\n\\t\\t// console.log(\\\"RecalcRestriction\\\");\\r\\n\\t\\t// console.log(\\\"account\\\", _account);\\r\\n\\t\\t// console.log(\\\"blocknumber\\\", block.number);\\r\\n\\t\\t// console.log(\\\"accRestr.time\\\", accRestr.time);\\r\\n\\t\\t// console.log(\\\"restriction.timeDelta\\\", restriction.timeDelta);\\r\\n\\t\\t// console.log(\\\"accRestr.bought\\\", accRestr.bought);\\r\\n\\t\\t// console.log(\\\"accRestr.accumulated\\\", accRestr.accumulated);\\r\\n\\t\\tuint256 helper = ((block.number - accRestr.time) / restriction.timeDelta) * ((accRestr.bought - accRestr.accumulated) / 12);\\r\\n\\t\\t// console.log(\\\"helper\\\", helper);\\r\\n\\r\\n\\t\\t//=MIN(M12+N12; E12)\\r\\n\\t\\t//=MIN(accumulated+helper; bought)\\r\\n\\t\\taccRestr.accumulated = Math.min(accRestr.accumulated + helper, accRestr.bought);\\r\\n\\t\\t// console.log(\\\"NEW accRestr.accumulated\\\", accRestr.accumulated);\\r\\n\\r\\n\\t\\t//vesz, elad\\r\\n\\t\\tif (_direction == 1) {\\r\\n\\t\\t\\taccRestr.bought += _amount;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\taccRestr.sold += _amount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taccRestr.time = block.number;\\r\\n\\r\\n\\t\\t// console.log(\\\"NEW accRestr.bought\\\", accRestr.bought);\\r\\n\\t\\t// console.log(\\\"NEW accRestr.sold\\\", accRestr.sold);\\r\\n\\t\\t// console.log(\\\"NEW accRestr.time\\\", accRestr.time);\\r\\n\\t}\\r\\n\\r\\n\\tfunction recalcRestrictions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts, uint8 _direction) internal {\\r\\n\\t\\tif (_tokenIds.length != _amounts.length) revert LibERC1155__ArrayLengthMismatch();\\r\\n\\r\\n\\t\\tfor (uint256 i; i < _tokenIds.length; ) {\\r\\n\\t\\t\\trecalcRestriction(_account, _tokenIds[i], _amounts[i], _direction);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x89720c71b9ad15ff53b33f2deaf750a63ffb4e568cb9b82ac38172d33613b179\",\"license\":\"MIT\"},\"contracts/base/TokenRestriction/LibTokenRestrictionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { EnumerableSet } from \\\"../../utils/EnumerableSet.sol\\\";\\r\\n\\r\\nstruct RestrictionCalc {\\r\\n\\tuint256 bought;\\r\\n\\tuint256 sold;\\r\\n\\tuint256 time; //blockheight * 1 000 000 000\\r\\n\\tuint256 accumulated;\\r\\n}\\r\\n\\r\\nstruct Restriction {\\r\\n\\tuint256 endOfRestriction; //if act-time is lower then endOfRestriction then only calculating the a previous data, new tokens do not restircted\\r\\n\\tuint256 endOfRestrictionCalc; //if act-time is lower then endOfRestrictionCalc then now calculation at all\\r\\n\\tuint256 timeDelta; //if time is blockHeight based then delta should be calculated like that. If second based then...\\r\\n\\t//Account - restriction calculation params\\r\\n\\tmapping(address => RestrictionCalc) restriction;\\r\\n}\\r\\n\\r\\nstruct TokenRestrictionStorage {\\r\\n\\t//tokenId => restriction, every token have\\r\\n\\tmapping(uint256 => Restriction) tokenRestriction;\\r\\n}\\r\\n\\r\\nlibrary LibTokenRestrictionStorage {\\r\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"usmart.common.token-restriction.storage.v1\\\");\\r\\n\\r\\n\\tfunction layout() internal pure returns (TokenRestrictionStorage storage layout_) {\\r\\n\\t\\tbytes32 position = STORAGE_SLOT;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlayout_.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0xe358c34214fecb91a975cd5269031d6b92f13d0d8af754b2d4dc56fc5246a744\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n\\tenum FacetCutAction {\\n\\t\\tAdd,\\n\\t\\tReplace,\\n\\t\\tRemove\\n\\t}\\n\\t// Add=0, Replace=1, Remove=2\\n\\n\\tstruct FacetCut {\\n\\t\\taddress facetAddress;\\n\\t\\tFacetCutAction action;\\n\\t\\tbytes4[] functionSelectors;\\n\\t}\\n\\n\\t/// @notice Add/replace/remove any number of functions and optionally execute\\n\\t///         a function with delegatecall\\n\\t/// @param _diamondCut Contains the facet addresses and function selectors\\n\\t/// @param _init The address of the contract or facet to execute _calldata\\n\\t/// @param _calldata A function call, including function selector and arguments\\n\\t///                  _calldata is executed with delegatecall on _init\\n\\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n\\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x38a0a1b25fb31d2205f5aaedb20f1788a38bc4147a4a20ee030335b7cdbaa0c4\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * Copyright (C) 2024 uSmart\\r\\n */\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\ninterface IERC173 {\\r\\n\\t/// @dev This emits when ownership of a contract changes.\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/// @notice Get the address of the owner\\r\\n\\t/// @return owner_ The address of the owner.\\r\\n\\tfunction owner() external view returns (address owner_);\\r\\n\\r\\n\\t/// @notice Set the address of the new owner of the contract\\r\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n\\t/// @param _newOwner The address of the new owner of the contract\\r\\n\\tfunction transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x92d3f89d7077a9b49b41fd69091ce8f8c1b20c5695dafbbb4b13e7b6f0d6e6ef\",\"license\":\"MIT\"},\"contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\nimport { UintUtils } from \\\"./UintUtils.sol\\\";\\n\\nlibrary AddressUtils {\\n\\tusing UintUtils for uint256;\\n\\n\\terror AddressUtils__InsufficientBalance();\\n\\terror AddressUtils__NotContract();\\n\\terror AddressUtils__SendValueFailed();\\n\\n\\tfunction toString(address account) internal pure returns (string memory) {\\n\\t\\treturn uint256(uint160(account)).toHexString(20);\\n\\t}\\n\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size > 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable account, uint256 amount) internal {\\n\\t\\t(bool success, ) = account.call{ value: amount }(\\\"\\\");\\n\\t\\tif (!success) revert AddressUtils__SendValueFailed();\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"AddressUtils: failed low-level call\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data, string memory error) internal returns (bytes memory) {\\n\\t\\treturn _functionCallWithValue(target, data, 0, error);\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"AddressUtils: failed low-level call with value\\\");\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) internal returns (bytes memory) {\\n\\t\\tif (value > address(this).balance) revert AddressUtils__InsufficientBalance();\\n\\t\\treturn _functionCallWithValue(target, data, value, error);\\n\\t}\\n\\n\\t/**\\n\\t * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n\\t * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n\\t * @param target recipient of call\\n\\t * @param gasAmount gas allowance for call\\n\\t * @param value native token value to include in call\\n\\t * @param maxCopy maximum number of bytes to copy from return data\\n\\t * @param data encoded call data\\n\\t * @return success whether call is successful\\n\\t * @return returnData copied return data\\n\\t */\\n\\tfunction excessivelySafeCall(\\n\\t\\taddress target,\\n\\t\\tuint256 gasAmount,\\n\\t\\tuint256 value,\\n\\t\\tuint16 maxCopy,\\n\\t\\tbytes memory data\\n\\t) internal returns (bool success, bytes memory returnData) {\\n\\t\\treturnData = new bytes(maxCopy);\\n\\n\\t\\tassembly {\\n\\t\\t\\t// execute external call via assembly to avoid automatic copying of return data\\n\\t\\t\\tsuccess := call(gasAmount, target, value, add(data, 0x20), mload(data), 0, 0)\\n\\n\\t\\t\\t// determine whether to limit amount of data to copy\\n\\t\\t\\tlet toCopy := returndatasize()\\n\\n\\t\\t\\tif gt(toCopy, maxCopy) {\\n\\t\\t\\t\\ttoCopy := maxCopy\\n\\t\\t\\t}\\n\\n\\t\\t\\t// store the length of the copied bytes\\n\\t\\t\\tmstore(returnData, toCopy)\\n\\n\\t\\t\\t// copy the bytes from returndata[0:toCopy]\\n\\t\\t\\treturndatacopy(add(returnData, 0x20), 0, toCopy)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _functionCallWithValue(address target, bytes memory data, uint256 value, string memory error) private returns (bytes memory) {\\n\\t\\tif (!isContract(target)) revert AddressUtils__NotContract();\\n\\n\\t\\t(bool success, bytes memory returnData) = target.call{ value: value }(data);\\n\\n\\t\\tif (success) {\\n\\t\\t\\treturn returnData;\\n\\t\\t} else if (returnData.length > 0) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet returnData_size := mload(returnData)\\n\\t\\t\\t\\trevert(add(32, returnData), returnData_size)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\trevert(error);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0xe7dec1466e1e606394a35fa837156a011f761ac6a6e9097b89a348fad1f2f692\",\"license\":\"MIT\"},\"contracts/utils/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n\\terror EnumerableSet__IndexOutOfBounds();\\n\\n\\tstruct Set {\\n\\t\\tbytes32[] _values;\\n\\t\\t// 1-indexed to allow 0 to signify nonexistence\\n\\t\\tmapping(bytes32 => uint256) _indexes;\\n\\t}\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index);\\n\\t}\\n\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index))));\\n\\t}\\n\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index));\\n\\t}\\n\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, value);\\n\\t}\\n\\n\\tfunction indexOf(AddressSet storage set, address value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction indexOf(UintSet storage set, uint256 value) internal view returns (uint256) {\\n\\t\\treturn _indexOf(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction toArray(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n\\t\\treturn set._inner._values;\\n\\t}\\n\\n\\tfunction toArray(AddressSet storage set) internal view returns (address[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\taddress[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction toArray(UintSet storage set) internal view returns (uint256[] memory) {\\n\\t\\tbytes32[] storage values = set._inner._values;\\n\\t\\tuint256[] storage array;\\n\\n\\t\\tassembly {\\n\\t\\t\\tarray.slot := values.slot\\n\\t\\t}\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\tif (index >= set._values.length) revert EnumerableSet__IndexOutOfBounds();\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\tfunction _indexOf(Set storage set, bytes32 value) private view returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn set._indexes[value] - 1;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\tset._indexes[value] = set._values.length;\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool status) {\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\n\\t\\tif (valueIndex != 0) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tbytes32 last = set._values[set._values.length - 1];\\n\\n\\t\\t\\t\\t// move last value to now-vacant index\\n\\n\\t\\t\\t\\tset._values[valueIndex - 1] = last;\\n\\t\\t\\t\\tset._indexes[last] = valueIndex;\\n\\t\\t\\t}\\n\\t\\t\\t// clear last index\\n\\n\\t\\t\\tset._values.pop();\\n\\t\\t\\tdelete set._indexes[value];\\n\\n\\t\\t\\tstatus = true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x442e9fd507b659095a1fec47f8cb6e540442165217af05db1afa2703a993e038\",\"license\":\"MIT\"},\"contracts/utils/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\nlibrary Math {\\n\\t/**\\n\\t * @notice calculate the absolute value of a number\\n\\t * @param a number whose absoluve value to calculate\\n\\t * @return absolute value\\n\\t */\\n\\tfunction abs(int256 a) internal pure returns (uint256) {\\n\\t\\treturn uint256(a < 0 ? -a : a);\\n\\t}\\n\\n\\t/**\\n\\t * @notice select the greater of two numbers\\n\\t * @param a first number\\n\\t * @param b second number\\n\\t * @return greater number\\n\\t */\\n\\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a > b ? a : b;\\n\\t}\\n\\n\\t/**\\n\\t * @notice select the lesser of two numbers\\n\\t * @param a first number\\n\\t * @param b second number\\n\\t * @return lesser number\\n\\t */\\n\\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a > b ? b : a;\\n\\t}\\n\\n\\t/**\\n\\t * @notice calculate the average of two numbers, rounded down\\n\\t * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n\\t * @param a first number\\n\\t * @param b second number\\n\\t * @return mean value\\n\\t */\\n\\tfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn (a & b) + ((a ^ b) >> 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice estimate square root of number\\n\\t * @dev uses Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n\\t * @param x input number\\n\\t * @return y square root\\n\\t */\\n\\tfunction sqrt(uint256 x) internal pure returns (uint256 y) {\\n\\t\\tuint256 z = (x + 1) >> 1;\\n\\t\\ty = x;\\n\\t\\twhile (z < y) {\\n\\t\\t\\ty = z;\\n\\t\\t\\tz = (x / z + z) >> 1;\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x032ee4f9c6cc152b1930c8c84a11bc736dc627a71a41a73e28b09b3ad7a231b3\",\"license\":\"MIT\"},\"contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * Copyright (C) 2024 uSmart\\n */\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n\\terror UintUtils__InsufficientHexLength();\\n\\n\\tbytes16 private constant HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n\\tfunction add(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? sub(a, -b) : a + uint256(b);\\n\\t}\\n\\n\\tfunction sub(uint256 a, int256 b) internal pure returns (uint256) {\\n\\t\\treturn b < 0 ? add(a, -b) : a - uint256(b);\\n\\t}\\n\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0x00\\\";\\n\\t\\t}\\n\\n\\t\\tuint256 length = 0;\\n\\n\\t\\tfor (uint256 temp = value; temp != 0; temp >>= 8) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tlength++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn toHexString(value, length);\\n\\t}\\n\\n\\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n\\t\\tbytes memory buffer = new bytes(2 * length + 2);\\n\\t\\tbuffer[0] = \\\"0\\\";\\n\\t\\tbuffer[1] = \\\"x\\\";\\n\\n\\t\\tunchecked {\\n\\t\\t\\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\\n\\t\\t\\t\\tbuffer[i] = HEX_SYMBOLS[value & 0xf];\\n\\t\\t\\t\\tvalue >>= 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\",\"keccak256\":\"0xec4d89ef08ad402e0c8b30b8e4e135991009384aa72f0cb7c6165721ec5050e2\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50614923806100206000396000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c80636442a5ed116100ad578063d19bcdf311610071578063d19bcdf3146102f9578063d5ddea0414610317578063da47320214610335578063dbcc4d9414610353578063f396f3d6146103715761012c565b80636442a5ed146102675780636a6128f41461028557806372b88f1b146102a1578063c1c64f0f146102d1578063cd304355146102db5761012c565b806336b01423116100f457806336b01423146101d55780634ba6348b146101f35780635aecf1891461020f5780635fc86ab91461022d57806361690b501461024b5761012c565b806303d1229c1461013157806308e7f2c51461014d5780631791bf201461016b5780632db4e5691461019b5780632dc00434146101b9575b600080fd5b61014b60048036038101906101469190613522565b61038f565b005b610155610421565b604051610162919061357e565b60405180910390f35b61018560048036038101906101809190613599565b610426565b60405161019291906135d5565b60405180910390f35b6101a36104ad565b6040516101b091906135d5565b60405180910390f35b6101d360048036038101906101ce91906135f0565b6104b5565b005b6101dd610558565b6040516101ea91906135d5565b60405180910390f35b61020d60048036038101906102089190613691565b610560565b005b6102176105f2565b604051610224919061357e565b60405180910390f35b6102356105f7565b604051610242919061357e565b60405180910390f35b610265600480360381019061026091906135f0565b6105fc565b005b61026f61069f565b60405161027c91906135d5565b60405180910390f35b61029f600480360381019061029a9190613691565b6106a7565b005b6102bb60048036038101906102b69190613522565b61073a565b6040516102c891906135d5565b60405180910390f35b6102d96107c3565b005b6102e361093c565b6040516102f0919061357e565b60405180910390f35b610301610941565b60405161030e919061357e565b60405180910390f35b61031f610946565b60405161032c919061357e565b60405180910390f35b61033d61094b565b60405161034a91906135d5565b60405180910390f35b61035b610953565b604051610368919061357e565b60405180910390f35b610379610958565b60405161038691906135d5565b60405180910390f35b610397610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610404576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103fb9061372e565b60405180910390fd5b6000801b61041181610998565b61041c8333846109db565b505050565b600581565b6000610430610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461049d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104949061372e565b60405180910390fd5b6104a682610b01565b9050919050565b631dcd650081565b6104bd610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461052a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105219061372e565b60405180910390fd5b6000801b61053781610998565b6000610546630bebc200610b01565b90506105538133856109db565b505050565b6317d7840081565b610568610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146105d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105cc9061372e565b60405180910390fd5b6000801b6105e281610998565b6105ed338484610b2c565b505050565b600081565b600481565b610604610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610671576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106689061372e565b60405180910390fd5b6000801b61067e81610998565b600061068d6305f5e100610b01565b905061069a8133856109db565b505050565b630bebc20081565b6106af610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461071c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107139061372e565b60405180910390fd5b6000801b61072981610998565b61073533338585610f4e565b505050565b6000610744610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146107b1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107a89061372e565b60405180910390fd5b6107bb83836112bd565b905092915050565b6107cb610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610838576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082f9061372e565b60405180910390fd5b6000801b61084581610998565b61086f7f6d6775b5e502c1f5932b823e8901beec555ffec897aad6fd00846e01363884c8336112d7565b6108ae576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108a5906137c0565b60405180910390fd5b6108da7f6d6775b5e502c1f5932b823e8901beec555ffec897aad6fd00846e01363884c833600061134d565b60006108ea33631dcd6500611418565b90506000811461092f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161092690613852565b60405180910390fd5b610938336114e7565b5050565b600381565b600281565b600181565b6311e1a30081565b600181565b6305f5e10081565b60008061096b61168f565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6109a1816116bc565b156109d8576040517f2d0a436a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b60006109e56116ef565b905060006109f9858463ffffffff1661171c565b90506000610a05610960565b90508260020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8683856040518463ffffffff1660e01b8152600401610a68939291906138b3565b6020604051808303816000875af1158015610a87573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aab9190613922565b5060006305f5e1008088610abf91906139ad565b610ac991906139de565b9050610ad581846117b6565b610af88283888a8963ffffffff16604051806020016040528060008152506118ec565b50505050505050565b600080610b0c6116ef565b905080600501600084815260200190815260200160002054915050919050565b60008160ff161480610b41575060018160ff16145b610b80576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b7790613a6c565b60405180910390fd5b6000610b8a6116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bfd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c219190613aa1565b600a610c2d9190613c01565b90506000600a90506000600a60018385610c4791906139de565b610c5191906139de565b610c5b91906139ad565b905060008060018760ff1603610d2757600a60058585600a8c610c7e9190613c4c565b6fffffffffffffffffffffffffffffffff16610c9a91906139de565b610ca491906139ad565b610cae9190613c89565b610cb891906139ad565b9150828483610cc791906139de565b610cd191906139ad565b9050600082118015610ce35750600081115b610d22576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d1990613d2f565b60405180910390fd5b610dbb565b8284896fffffffffffffffffffffffffffffffff16610d4691906139de565b610d5091906139ad565b9050838382610d5f91906139de565b610d6991906139ad565b9150600082118015610d7b5750600081115b610dba576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610db190613dc1565b60405180910390fd5b5b6000866000016000600160ff1660ff16815260200190815260200160002090508060000154828260010154610df09190613c89565b1115610e31576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e2890613e2d565b60405180910390fd5b818160010154610e419190613c89565b81600101819055506000610e53610960565b90508760020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8c83876040518463ffffffff1660e01b8152600401610eb6939291906138b3565b6020604051808303816000875af1158015610ed5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef99190613922565b50610f086317d78400856117b6565b610f2981828d6317d7840087604051806020016040528060008152506118ec565b828860070154610f399190613c89565b88600701819055505050505050505050505050565b60008160ff161480610f63575060018160ff16145b610fa2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f9990613a6c565b60405180910390fd5b6000610fac6116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190613aa1565b600a61104f9190613c01565b90506000600a905060006001828461106791906139de565b61107191906139de565b905060008060018760ff160361113d57600a60058585600a8c6110949190613c4c565b6fffffffffffffffffffffffffffffffff166110b091906139de565b6110ba91906139ad565b6110c49190613c89565b6110ce91906139ad565b91508284836110dd91906139de565b6110e791906139ad565b90506000821180156110f95750600081115b611138576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161112f90613ebf565b60405180910390fd5b6111d1565b8284896fffffffffffffffffffffffffffffffff1661115c91906139de565b61116691906139ad565b905083838261117591906139de565b61117f91906139ad565b91506000821180156111915750600081115b6111d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111c790613f51565b60405180910390fd5b5b60006111db610960565b90508660020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8b83866040518463ffffffff1660e01b815260040161123e939291906138b3565b6020604051808303816000875af115801561125d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112819190613922565b506112906311e1a300846117b6565b6112b08b8b6311e1a3008560405180602001604052806000815250611d17565b5050505050505050505050565b60006112cf838363ffffffff16611ecc565b905092915050565b6000806112e2611f06565b905080600001600085815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1691505092915050565b6000611357611f06565b90508181600001600086815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508273ffffffffffffffffffffffffffffffffffffffff16847f696f1e09104a0bef7512faf461f1a6962c3c8151a4d5979d4fdfa5112fccc5198460405161140a9190613f80565b60405180910390a350505050565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361147f576040517f4a772c2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611489611f33565b905080600001600084815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205491505092915050565b60006114f16116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611564573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115889190613aa1565b600a6115949190613c01565b905060008160646115a591906139de565b905060006115b1610960565b90508360020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8683856040518463ffffffff1660e01b8152600401611614939291906138b3565b6020604051808303816000875af1158015611633573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116579190613922565b5061167a818287631dcd65006001604051806020016040528060008152506118ec565b611688631dcd6500836117b6565b5050505050565b6000807ff72346055b4d7224c7ec19860d22963ca622fbb313761bfba507c1a3aeedf37290508091505090565b60006116c6611f60565b600001600083815260200190815260200160002060009054906101000a900460ff169050919050565b6000807f1a2f703e435318ee39feac62abda44020ca215505d5ba3284195182c842a2d3090508091505090565b600080611727611f8d565b905060008160000160008681526020019081526020016000209050600061174e8286611fba565b90508482600101546117609190613f9b565b82600101819055508082600201546117789190613c89565b826002018190555060008260010154036117aa5760008260000160006101000a81548160ff0219169083151502179055505b80935050505092915050565b60006117c06116ef565b9050600081600101600085815260200190815260200160002060000160049054906101000a900463ffffffff1682600101600086815260200190815260200160002060000160009054906101000a900463ffffffff166118209190613fcf565b63ffffffff1682600101600086815260200190815260200160002060000160009054906101000a900463ffffffff1663ffffffff168461186091906139de565b61186a91906139ad565b90506000818461187a9190613f9b565b90506118af8360020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166317d78400846120fb565b818360030160008282546118c39190613c89565b92505081905550808360040160008282546118de9190613c89565b925050819055505050505050565b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603611952576040517fa25202b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061195d846121fc565b9050600061196a846121fc565b905061197a888888858588612276565b6000611984611f33565b90506119908187612527565b600081600001600088815260200190815260200160002060008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905080861115611a21576040517fb38aedf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611a2d8a8a8989612597565b85810382600001600089815260200190815260200160002060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff1614611c085781600201600088815260200190815260200160002060009054906101000a900460ff1615611c0757858260030160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600089815260200190815260200160002054038260030160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000898152602001908152602001600020819055505b5b8582600001600089815260200190815260200160002060008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611c6a9190613c89565b925050819055508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f628a8a604051611ce7929190614007565b60405180910390a4611cfd8a8a8a87878a612794565b611d0b8a8a8a8a8a8a6127aa565b50505050505050505050565b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603611d7d576040517fefac521700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611d88846121fc565b90506000611d95846121fc565b9050611da687600088858588612276565b6000611db0611f33565b9050611dbc8187612527565b8481600001600088815260200190815260200160002060008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611e1e9190613c89565b925050819055508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f628989604051611e9c929190614007565b60405180910390a4611eb388600089868689612794565b611ec2886000898989896127aa565b5050505050505050565b600080611ed7611f8d565b905060008160000160008681526020019081526020016000209050611efc8185611fba565b9250505092915050565b6000807f7fb8776fdb93079091f516133d7bb98c82f37f53f39f39f153c42a90e5e5891290508091505090565b6000807fe20f5a7f7e820e4505f9ef8ed1186e372d3490e37d8001618819927829be4e0590508091505090565b6000807fe8ceb94393aac3e803a9d4b376f7c5ffd7e8b6caab697212a5360c34a283caa190508091505090565b6000807f47b8e8b32475ba6530f41efddbadc333684d4f798e5f4689344334684c5f262590508091505090565b60008260000160009054906101000a900460ff1661200d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612004906140a2565b60405180910390fd5b8260010154821115612054576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161204b9061410e565b60405180910390fd5b6000600a6005600185876001015461206c9190613f9b565b6120769190613c89565b866001015461208591906139de565b866003015486600a61209791906139de565b6120a191906139de565b6120ab91906139ad565b6120b59190613c89565b6120bf91906139ad565b90506120f28460050154846120d491906139de565b6120ed8660040154866120e791906139de565b8461296f565b612988565b91505092915050565b60006121056129a1565b905060008160000160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085815260200190815260200160002090508060000160009054906101000a900460ff1661217a5750506121f7565b60008312156121be576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121b59061417a565b60405180910390fd5b828160020160008282546121d291906141a4565b92505081905550828160030160008282546121ed91906141a4565b9250508190555050505b505050565b60606000600167ffffffffffffffff81111561221b5761221a6141e8565b5b6040519080825280602002602001820160405280156122495781602001602082028036833780820191505090505b509050828160008151811061226157612260614217565b5b60200260200101818152505080915050919050565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16146125115760006122b3611f33565b9050600081600501905060008260060160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008360060160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060005b875181101561250b57600087828151811061236857612367614217565b5b6020026020010151905060008111156124fd5760008983815181106123905761238f614217565b5b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff16036123ff578187600401600083815260200190815260200160002060008282546123f39190613c89565b9250508190555061244a565b8161240a8d83611418565b03612449576124338c8760008481526020019081526020016000206129ce90919063ffffffff16565b5061244781866129fe90919063ffffffff16565b505b5b600073ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff16036124af578187600401600083815260200190815260200160002060008282546124a39190613f9b565b925050819055506124fb565b60006124bb8c83611418565b036124fa576124e48b876000848152602001908152602001600020612a1890919063ffffffff16565b506124f88185612a4890919063ffffffff16565b505b5b505b81806001019250505061234a565b50505050505b61251f868686868686612a62565b505050505050565b61253082612aaa565b81600b01600082815260200190815260200160002060009054906101000a900460ff1615612593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161258a90614292565b60405180910390fd5b5050565b60006125a1611f33565b90508473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161461278d578060010160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16612698576040517f3d2f0b3700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80600201600084815260200190815260200160002060009054906101000a900460ff1680156127555750818160030160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085815260200190815260200160002054105b1561278c576040517f32af163800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5050505050565b6127a2868686868686612aff565b505050505050565b6127c98473ffffffffffffffffffffffffffffffffffffffff16612bed565b15612967578373ffffffffffffffffffffffffffffffffffffffff1663f23a6e6187878686866040518663ffffffff1660e01b815260040161280f959493929190614342565b6020604051808303816000875af192505050801561284b57506040513d601f19601f8201168201806040525081019061284891906143f4565b60015b6128e75761285761442e565b806308c379a0036128b3575061286b614481565b8061287657506128b5565b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128aa9190614555565b60405180910390fd5b505b6040517f4eebd08100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63f23a6e6160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614612965576040517f542073e700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505b505050505050565b600081831161297e5781612980565b825b905092915050565b60008183116129975782612999565b815b905092915050565b6000807ff0375085caeab71645bf74d020ee2aa37bc7b653d9e55911c1084d8c88b3c05c90508091505090565b60006129f6836000018373ffffffffffffffffffffffffffffffffffffffff1660001b612c00565b905092915050565b6000612a10836000018360001b612c00565b905092915050565b6000612a40836000018373ffffffffffffffffffffffffffffffffffffffff1660001b612ce4565b905092915050565b6000612a5a836000018360001b612ce4565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612aa257612aa1858484612d4b565b5b505050505050565b80600a0160009054906101000a900460ff1615612afc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612af3906145c3565b60405180910390fd5b50565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612b4157612b408584846000612de4565b5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614612b8357612b828484846001612de4565b5b60005b8351811015612be457612bd7612b9a612e7f565b858381518110612bad57612bac614217565b5b60200260200101518888878681518110612bca57612bc9614217565b5b6020026020010151612eb7565b8080600101915050612b86565b50505050505050565b600080823b905060008111915050919050565b60008083600101600084815260200190815260200160002054905060008114612cdd57600084600001600186600001805490500381548110612c4557612c44614217565b5b9060005260206000200154905080856000016001840381548110612c6c57612c6b614217565b5b906000526020600020018190555081856001016000838152602001908152602001600020819055505083600001805480612ca957612ca86145e3565b5b6001900381819060005260206000200160009055905583600101600084815260200190815260200160002060009055600191505b5092915050565b6000612cf08383612feb565b612d455782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b8051825114612d86576040517f583b4bea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8251811015612dde57612dd184848381518110612da957612da8614217565b5b6020026020010151848481518110612dc457612dc3614217565b5b602002602001015161300e565b8080600101915050612d89565b50505050565b8151835114612e1f576040517f583b4bea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8351811015612e7857612e6b85858381518110612e4257612e41614217565b5b6020026020010151858481518110612e5d57612e5c614217565b5b602002602001015185613155565b8080600101915050612e22565b5050505050565b600080612e8a6116ef565b90508060020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6000612ec16129a1565b905060008160000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002090508060000160009054906101000a900460ff16612f36575050612fe4565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612fa157612fa08186857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612f9b9190614612565b6132f3565b5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614612fe157612fe08185856132f3565b5b50505b5050505050565b600080836001016000848152602001908152602001600020541415905092915050565b6000613018613474565b90506000816000016000858152602001908152602001600020905043816001015411613045575050613150565b60008160030160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000600c826003015483600001546130a29190613f9b565b6130ac91906139ad565b83600201548360020154436130c19190613f9b565b6130cb91906139ad565b6130d591906139de565b9050600082600101546130fb8385600301546130f19190613c89565b8560000154612988565b6131059190613f9b565b90508086111561314a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613141906146fc565b60405180910390fd5b50505050505b505050565b600061315f613474565b9050600081600001600086815260200190815260200160002090504381600101541161318c5750506132ed565b60008160030160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050438260000154116132265760018460ff160361321e57848160000160008282546131fb9190613c89565b92505081905550848160030160008282546132169190613c89565b925050819055505b5050506132ed565b6000600c8260030154836000015461323e9190613f9b565b61324891906139ad565b836002015483600201544361325d9190613f9b565b61326791906139ad565b61327191906139de565b90506132908183600301546132869190613c89565b8360000154612988565b826003018190555060018560ff16036132c357858260000160008282546132b79190613c89565b925050819055506132df565b858260010160008282546132d79190613c89565b925050819055505b438260020181905550505050505b50505050565b60008360040160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600082856001015461334a91906141a4565b121561338b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016133829061478e565b60405180910390fd5b600082826000015461339d91906141a4565b12156133de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016133d590614820565b60405180910390fd5b60008085600101541461340d5784600101548386600301546134009190614612565b61340a9190614840565b90505b82856001015461341d91906141a4565b856001018190555080856003015461343591906141a4565b856003018190555082826000015461344d91906141a4565b826000018190555080826001015461346591906148aa565b82600101819055505050505050565b6000807fb666c964c288db81fc3205a9feeb13cfebbde2a4a4664c45ea26ef9d3d8de79290508091505090565b6000604051905090565b600080fd5b6000819050919050565b6134c3816134b0565b81146134ce57600080fd5b50565b6000813590506134e0816134ba565b92915050565b600063ffffffff82169050919050565b6134ff816134e6565b811461350a57600080fd5b50565b60008135905061351c816134f6565b92915050565b60008060408385031215613539576135386134ab565b5b6000613547858286016134d1565b92505060206135588582860161350d565b9150509250929050565b600060ff82169050919050565b61357881613562565b82525050565b6000602082019050613593600083018461356f565b92915050565b6000602082840312156135af576135ae6134ab565b5b60006135bd848285016134d1565b91505092915050565b6135cf816134b0565b82525050565b60006020820190506135ea60008301846135c6565b92915050565b600060208284031215613606576136056134ab565b5b60006136148482850161350d565b91505092915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b6136428161361d565b811461364d57600080fd5b50565b60008135905061365f81613639565b92915050565b61366e81613562565b811461367957600080fd5b50565b60008135905061368b81613665565b92915050565b600080604083850312156136a8576136a76134ab565b5b60006136b685828601613650565b92505060206136c78582860161367c565b9150509250929050565b600082825260208201905092915050565b7f4e4f545f414c4c4f574544000000000000000000000000000000000000000000600082015250565b6000613718600b836136d1565b9150613723826136e2565b602082019050919050565b600060208201905081810360008301526137478161370b565b9050919050565b7f4f6e6c7920616e20617070726f766564206163636f756e742063616e2062757960008201527f20746865204d6167696320746f6b656e00000000000000000000000000000000602082015250565b60006137aa6030836136d1565b91506137b58261374e565b604082019050919050565b600060208201905081810360008301526137d98161379d565b9050919050565b7f4f6e6c792031204d6167696320746f6b656e2063616e20626520626f7567687460008201527f206e6f7721000000000000000000000000000000000000000000000000000000602082015250565b600061383c6025836136d1565b9150613847826137e0565b604082019050919050565b6000602082019050818103600083015261386b8161382f565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061389d82613872565b9050919050565b6138ad81613892565b82525050565b60006060820190506138c860008301866138a4565b6138d560208301856138a4565b6138e260408301846135c6565b949350505050565b60008115159050919050565b6138ff816138ea565b811461390a57600080fd5b50565b60008151905061391c816138f6565b92915050565b600060208284031215613938576139376134ab565b5b60006139468482850161390d565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006139b8826134b0565b91506139c3836134b0565b9250826139d3576139d261394f565b5b828204905092915050565b60006139e9826134b0565b91506139f4836134b0565b9250828202613a02816134b0565b91508282048414831517613a1957613a1861397e565b5b5092915050565b7f76616c7565547970652063616e2062652030206f722031206f6e6c7921000000600082015250565b6000613a56601d836136d1565b9150613a6182613a20565b602082019050919050565b60006020820190508181036000830152613a8581613a49565b9050919050565b600081519050613a9b81613665565b92915050565b600060208284031215613ab757613ab66134ab565b5b6000613ac584828501613a8c565b91505092915050565b60008160011c9050919050565b6000808291508390505b6001851115613b2557808604811115613b0157613b0061397e565b5b6001851615613b105780820291505b8081029050613b1e85613ace565b9450613ae5565b94509492505050565b600082613b3e5760019050613bfa565b81613b4c5760009050613bfa565b8160018114613b625760028114613b6c57613b9b565b6001915050613bfa565b60ff841115613b7e57613b7d61397e565b5b8360020a915084821115613b9557613b9461397e565b5b50613bfa565b5060208310610133831016604e8410600b8410161715613bd05782820a905083811115613bcb57613bca61397e565b5b613bfa565b613bdd8484846001613adb565b92509050818404811115613bf457613bf361397e565b5b81810290505b9392505050565b6000613c0c826134b0565b9150613c1783613562565b9250613c447fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484613b2e565b905092915050565b6000613c578261361d565b9150613c628361361d565b9250828202613c708161361d565b9150808214613c8257613c8161397e565b5b5092915050565b6000613c94826134b0565b9150613c9f836134b0565b9250828201905080821115613cb757613cb661397e565b5b92915050565b7f54686520696e707574207175616e7469747920697320746f6f20736d616c6c2060008201527f666f7220706179696e6720746f6b656e00000000000000000000000000000000602082015250565b6000613d196030836136d1565b9150613d2482613cbd565b604082019050919050565b60006020820190508181036000830152613d4881613d0c565b9050919050565b7f54686520696e70757420616d6f756e7420697320746f6f20736d616c6c20666f60008201527f7220627579696e67206120746f6b656e00000000000000000000000000000000602082015250565b6000613dab6030836136d1565b9150613db682613d4f565b604082019050919050565b60006020820190508181036000830152613dda81613d9e565b9050919050565b7f4e6f7420656e6f75676820746f6b656e20746f2073656c6c0000000000000000600082015250565b6000613e176018836136d1565b9150613e2282613de1565b602082019050919050565b60006020820190508181036000830152613e4681613e0a565b9050919050565b7f54686520696e707574207175616e7469747920697320746f6f20736d616c6c2060008201527f666f7220706179696e6720746f6b656e21000000000000000000000000000000602082015250565b6000613ea96031836136d1565b9150613eb482613e4d565b604082019050919050565b60006020820190508181036000830152613ed881613e9c565b9050919050565b7f54686520696e70757420616d6f756e7420697320746f6f20736d616c6c20666f60008201527f7220627579696e67206120746f6b656e21000000000000000000000000000000602082015250565b6000613f3b6031836136d1565b9150613f4682613edf565b604082019050919050565b60006020820190508181036000830152613f6a81613f2e565b9050919050565b613f7a816138ea565b82525050565b6000602082019050613f956000830184613f71565b92915050565b6000613fa6826134b0565b9150613fb1836134b0565b9250828203905081811115613fc957613fc861397e565b5b92915050565b6000613fda826134e6565b9150613fe5836134e6565b9250828201905063ffffffff8111156140015761400061397e565b5b92915050565b600060408201905061401c60008301856135c6565b61402960208301846135c6565b9392505050565b7f43616c63756c6174696f6e206973206e6f7420656e61626c656420666f72207460008201527f686520746f6b656e210000000000000000000000000000000000000000000000602082015250565b600061408c6029836136d1565b915061409782614030565b604082019050919050565b600060208201905081810360008301526140bb8161407f565b9050919050565b7f4e6f7420656e6f75676874207175616e74697479206c65667421000000000000600082015250565b60006140f8601a836136d1565b9150614103826140c2565b602082019050919050565b60006020820190508181036000830152614127816140eb565b9050919050565b7f506f6f6c2063616e206f6e6c7920696e63726561736521000000000000000000600082015250565b60006141646017836136d1565b915061416f8261412e565b602082019050919050565b6000602082019050818103600083015261419381614157565b9050919050565b6000819050919050565b60006141af8261419a565b91506141ba8361419a565b9250828201905082811215600083121683821260008412151617156141e2576141e161397e565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f546f6b656e206973207061757365642100000000000000000000000000000000600082015250565b600061427c6010836136d1565b915061428782614246565b602082019050919050565b600060208201905081810360008301526142ab8161426f565b9050919050565b600081519050919050565b600082825260208201905092915050565b60005b838110156142ec5780820151818401526020810190506142d1565b60008484015250505050565b6000601f19601f8301169050919050565b6000614314826142b2565b61431e81856142bd565b935061432e8185602086016142ce565b614337816142f8565b840191505092915050565b600060a08201905061435760008301886138a4565b61436460208301876138a4565b61437160408301866135c6565b61437e60608301856135c6565b81810360808301526143908184614309565b90509695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6143d18161439c565b81146143dc57600080fd5b50565b6000815190506143ee816143c8565b92915050565b60006020828403121561440a576144096134ab565b5b6000614418848285016143df565b91505092915050565b60008160e01c9050919050565b600060033d111561444d5760046000803e61444a600051614421565b90505b90565b614459826142f8565b810181811067ffffffffffffffff82111715614478576144776141e8565b5b80604052505050565b600060443d1061450e576144936134a1565b60043d036004823e80513d602482011167ffffffffffffffff821117156144bb57505061450e565b808201805167ffffffffffffffff8111156144d9575050505061450e565b80602083010160043d0385018111156144f657505050505061450e565b61450582602001850186614450565b82955050505050505b90565b600081519050919050565b600061452782614511565b61453181856136d1565b93506145418185602086016142ce565b61454a816142f8565b840191505092915050565b6000602082019050818103600083015261456f818461451c565b905092915050565b7f416c6c20746f6b656e2069732070617573656421000000000000000000000000600082015250565b60006145ad6014836136d1565b91506145b882614577565b602082019050919050565b600060208201905081810360008301526145dc816145a0565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b600061461d8261419a565b91506146288361419a565b92508282026146368161419a565b91507f8000000000000000000000000000000000000000000000000000000000000000841460008412161561466e5761466d61397e565b5b82820584148315176146835761468261397e565b5b5092915050565b7f54686520616d6f756e7420697320677261746572207468656e2074686520616360008201527f63756d6c6174656420282773656c6c61626c65272920616d6f756e7421000000602082015250565b60006146e6603d836136d1565b91506146f18261468a565b604082019050919050565b60006020820190508181036000830152614715816146d9565b9050919050565b7f506f6f6c20746f6b656e207175616e6974792063616e2774206265206c65737360008201527f207468656e207a65726f21000000000000000000000000000000000000000000602082015250565b6000614778602b836136d1565b91506147838261471c565b604082019050919050565b600060208201905081810360008301526147a78161476b565b9050919050565b7f5573657220746f6b656e207175616e6974792063616e2774206265206c65737360008201527f207468656e207a65726f21000000000000000000000000000000000000000000602082015250565b600061480a602b836136d1565b9150614815826147ae565b604082019050919050565b60006020820190508181036000830152614839816147fd565b9050919050565b600061484b8261419a565b91506148568361419a565b9250826148665761486561394f565b5b600160000383147f80000000000000000000000000000000000000000000000000000000000000008314161561489f5761489e61397e565b5b828205905092915050565b60006148b58261419a565b91506148c08361419a565b92508282039050818112600084121682821360008512151617156148e7576148e661397e565b5b9291505056fea2646970667358221220fc9c4272cd38f6900f3669ca6676f46a8f734dbacab5e199f17c61cffee4141464736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061012c5760003560e01c80636442a5ed116100ad578063d19bcdf311610071578063d19bcdf3146102f9578063d5ddea0414610317578063da47320214610335578063dbcc4d9414610353578063f396f3d6146103715761012c565b80636442a5ed146102675780636a6128f41461028557806372b88f1b146102a1578063c1c64f0f146102d1578063cd304355146102db5761012c565b806336b01423116100f457806336b01423146101d55780634ba6348b146101f35780635aecf1891461020f5780635fc86ab91461022d57806361690b501461024b5761012c565b806303d1229c1461013157806308e7f2c51461014d5780631791bf201461016b5780632db4e5691461019b5780632dc00434146101b9575b600080fd5b61014b60048036038101906101469190613522565b61038f565b005b610155610421565b604051610162919061357e565b60405180910390f35b61018560048036038101906101809190613599565b610426565b60405161019291906135d5565b60405180910390f35b6101a36104ad565b6040516101b091906135d5565b60405180910390f35b6101d360048036038101906101ce91906135f0565b6104b5565b005b6101dd610558565b6040516101ea91906135d5565b60405180910390f35b61020d60048036038101906102089190613691565b610560565b005b6102176105f2565b604051610224919061357e565b60405180910390f35b6102356105f7565b604051610242919061357e565b60405180910390f35b610265600480360381019061026091906135f0565b6105fc565b005b61026f61069f565b60405161027c91906135d5565b60405180910390f35b61029f600480360381019061029a9190613691565b6106a7565b005b6102bb60048036038101906102b69190613522565b61073a565b6040516102c891906135d5565b60405180910390f35b6102d96107c3565b005b6102e361093c565b6040516102f0919061357e565b60405180910390f35b610301610941565b60405161030e919061357e565b60405180910390f35b61031f610946565b60405161032c919061357e565b60405180910390f35b61033d61094b565b60405161034a91906135d5565b60405180910390f35b61035b610953565b604051610368919061357e565b60405180910390f35b610379610958565b60405161038691906135d5565b60405180910390f35b610397610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610404576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103fb9061372e565b60405180910390fd5b6000801b61041181610998565b61041c8333846109db565b505050565b600581565b6000610430610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461049d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104949061372e565b60405180910390fd5b6104a682610b01565b9050919050565b631dcd650081565b6104bd610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461052a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105219061372e565b60405180910390fd5b6000801b61053781610998565b6000610546630bebc200610b01565b90506105538133856109db565b505050565b6317d7840081565b610568610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146105d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105cc9061372e565b60405180910390fd5b6000801b6105e281610998565b6105ed338484610b2c565b505050565b600081565b600481565b610604610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610671576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106689061372e565b60405180910390fd5b6000801b61067e81610998565b600061068d6305f5e100610b01565b905061069a8133856109db565b505050565b630bebc20081565b6106af610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461071c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107139061372e565b60405180910390fd5b6000801b61072981610998565b61073533338585610f4e565b505050565b6000610744610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146107b1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107a89061372e565b60405180910390fd5b6107bb83836112bd565b905092915050565b6107cb610960565b73ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614610838576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082f9061372e565b60405180910390fd5b6000801b61084581610998565b61086f7f6d6775b5e502c1f5932b823e8901beec555ffec897aad6fd00846e01363884c8336112d7565b6108ae576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108a5906137c0565b60405180910390fd5b6108da7f6d6775b5e502c1f5932b823e8901beec555ffec897aad6fd00846e01363884c833600061134d565b60006108ea33631dcd6500611418565b90506000811461092f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161092690613852565b60405180910390fd5b610938336114e7565b5050565b600381565b600281565b600181565b6311e1a30081565b600181565b6305f5e10081565b60008061096b61168f565b90508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6109a1816116bc565b156109d8576040517f2d0a436a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b60006109e56116ef565b905060006109f9858463ffffffff1661171c565b90506000610a05610960565b90508260020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8683856040518463ffffffff1660e01b8152600401610a68939291906138b3565b6020604051808303816000875af1158015610a87573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aab9190613922565b5060006305f5e1008088610abf91906139ad565b610ac991906139de565b9050610ad581846117b6565b610af88283888a8963ffffffff16604051806020016040528060008152506118ec565b50505050505050565b600080610b0c6116ef565b905080600501600084815260200190815260200160002054915050919050565b60008160ff161480610b41575060018160ff16145b610b80576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b7790613a6c565b60405180910390fd5b6000610b8a6116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bfd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c219190613aa1565b600a610c2d9190613c01565b90506000600a90506000600a60018385610c4791906139de565b610c5191906139de565b610c5b91906139ad565b905060008060018760ff1603610d2757600a60058585600a8c610c7e9190613c4c565b6fffffffffffffffffffffffffffffffff16610c9a91906139de565b610ca491906139ad565b610cae9190613c89565b610cb891906139ad565b9150828483610cc791906139de565b610cd191906139ad565b9050600082118015610ce35750600081115b610d22576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d1990613d2f565b60405180910390fd5b610dbb565b8284896fffffffffffffffffffffffffffffffff16610d4691906139de565b610d5091906139ad565b9050838382610d5f91906139de565b610d6991906139ad565b9150600082118015610d7b5750600081115b610dba576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610db190613dc1565b60405180910390fd5b5b6000866000016000600160ff1660ff16815260200190815260200160002090508060000154828260010154610df09190613c89565b1115610e31576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e2890613e2d565b60405180910390fd5b818160010154610e419190613c89565b81600101819055506000610e53610960565b90508760020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8c83876040518463ffffffff1660e01b8152600401610eb6939291906138b3565b6020604051808303816000875af1158015610ed5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef99190613922565b50610f086317d78400856117b6565b610f2981828d6317d7840087604051806020016040528060008152506118ec565b828860070154610f399190613c89565b88600701819055505050505050505050505050565b60008160ff161480610f63575060018160ff16145b610fa2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f9990613a6c565b60405180910390fd5b6000610fac6116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190613aa1565b600a61104f9190613c01565b90506000600a905060006001828461106791906139de565b61107191906139de565b905060008060018760ff160361113d57600a60058585600a8c6110949190613c4c565b6fffffffffffffffffffffffffffffffff166110b091906139de565b6110ba91906139ad565b6110c49190613c89565b6110ce91906139ad565b91508284836110dd91906139de565b6110e791906139ad565b90506000821180156110f95750600081115b611138576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161112f90613ebf565b60405180910390fd5b6111d1565b8284896fffffffffffffffffffffffffffffffff1661115c91906139de565b61116691906139ad565b905083838261117591906139de565b61117f91906139ad565b91506000821180156111915750600081115b6111d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111c790613f51565b60405180910390fd5b5b60006111db610960565b90508660020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8b83866040518463ffffffff1660e01b815260040161123e939291906138b3565b6020604051808303816000875af115801561125d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112819190613922565b506112906311e1a300846117b6565b6112b08b8b6311e1a3008560405180602001604052806000815250611d17565b5050505050505050505050565b60006112cf838363ffffffff16611ecc565b905092915050565b6000806112e2611f06565b905080600001600085815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1691505092915050565b6000611357611f06565b90508181600001600086815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508273ffffffffffffffffffffffffffffffffffffffff16847f696f1e09104a0bef7512faf461f1a6962c3c8151a4d5979d4fdfa5112fccc5198460405161140a9190613f80565b60405180910390a350505050565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361147f576040517f4a772c2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611489611f33565b905080600001600084815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205491505092915050565b60006114f16116ef565b905060008160020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611564573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115889190613aa1565b600a6115949190613c01565b905060008160646115a591906139de565b905060006115b1610960565b90508360020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd8683856040518463ffffffff1660e01b8152600401611614939291906138b3565b6020604051808303816000875af1158015611633573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116579190613922565b5061167a818287631dcd65006001604051806020016040528060008152506118ec565b611688631dcd6500836117b6565b5050505050565b6000807ff72346055b4d7224c7ec19860d22963ca622fbb313761bfba507c1a3aeedf37290508091505090565b60006116c6611f60565b600001600083815260200190815260200160002060009054906101000a900460ff169050919050565b6000807f1a2f703e435318ee39feac62abda44020ca215505d5ba3284195182c842a2d3090508091505090565b600080611727611f8d565b905060008160000160008681526020019081526020016000209050600061174e8286611fba565b90508482600101546117609190613f9b565b82600101819055508082600201546117789190613c89565b826002018190555060008260010154036117aa5760008260000160006101000a81548160ff0219169083151502179055505b80935050505092915050565b60006117c06116ef565b9050600081600101600085815260200190815260200160002060000160049054906101000a900463ffffffff1682600101600086815260200190815260200160002060000160009054906101000a900463ffffffff166118209190613fcf565b63ffffffff1682600101600086815260200190815260200160002060000160009054906101000a900463ffffffff1663ffffffff168461186091906139de565b61186a91906139ad565b90506000818461187a9190613f9b565b90506118af8360020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166317d78400846120fb565b818360030160008282546118c39190613c89565b92505081905550808360040160008282546118de9190613c89565b925050819055505050505050565b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603611952576040517fa25202b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061195d846121fc565b9050600061196a846121fc565b905061197a888888858588612276565b6000611984611f33565b90506119908187612527565b600081600001600088815260200190815260200160002060008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905080861115611a21576040517fb38aedf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611a2d8a8a8989612597565b85810382600001600089815260200190815260200160002060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff1614611c085781600201600088815260200190815260200160002060009054906101000a900460ff1615611c0757858260030160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600089815260200190815260200160002054038260030160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000898152602001908152602001600020819055505b5b8582600001600089815260200190815260200160002060008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611c6a9190613c89565b925050819055508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f628a8a604051611ce7929190614007565b60405180910390a4611cfd8a8a8a87878a612794565b611d0b8a8a8a8a8a8a6127aa565b50505050505050505050565b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603611d7d576040517fefac521700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611d88846121fc565b90506000611d95846121fc565b9050611da687600088858588612276565b6000611db0611f33565b9050611dbc8187612527565b8481600001600088815260200190815260200160002060008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611e1e9190613c89565b925050819055508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f628989604051611e9c929190614007565b60405180910390a4611eb388600089868689612794565b611ec2886000898989896127aa565b5050505050505050565b600080611ed7611f8d565b905060008160000160008681526020019081526020016000209050611efc8185611fba565b9250505092915050565b6000807f7fb8776fdb93079091f516133d7bb98c82f37f53f39f39f153c42a90e5e5891290508091505090565b6000807fe20f5a7f7e820e4505f9ef8ed1186e372d3490e37d8001618819927829be4e0590508091505090565b6000807fe8ceb94393aac3e803a9d4b376f7c5ffd7e8b6caab697212a5360c34a283caa190508091505090565b6000807f47b8e8b32475ba6530f41efddbadc333684d4f798e5f4689344334684c5f262590508091505090565b60008260000160009054906101000a900460ff1661200d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612004906140a2565b60405180910390fd5b8260010154821115612054576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161204b9061410e565b60405180910390fd5b6000600a6005600185876001015461206c9190613f9b565b6120769190613c89565b866001015461208591906139de565b866003015486600a61209791906139de565b6120a191906139de565b6120ab91906139ad565b6120b59190613c89565b6120bf91906139ad565b90506120f28460050154846120d491906139de565b6120ed8660040154866120e791906139de565b8461296f565b612988565b91505092915050565b60006121056129a1565b905060008160000160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085815260200190815260200160002090508060000160009054906101000a900460ff1661217a5750506121f7565b60008312156121be576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121b59061417a565b60405180910390fd5b828160020160008282546121d291906141a4565b92505081905550828160030160008282546121ed91906141a4565b9250508190555050505b505050565b60606000600167ffffffffffffffff81111561221b5761221a6141e8565b5b6040519080825280602002602001820160405280156122495781602001602082028036833780820191505090505b509050828160008151811061226157612260614217565b5b60200260200101818152505080915050919050565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16146125115760006122b3611f33565b9050600081600501905060008260060160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008360060160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060005b875181101561250b57600087828151811061236857612367614217565b5b6020026020010151905060008111156124fd5760008983815181106123905761238f614217565b5b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff16036123ff578187600401600083815260200190815260200160002060008282546123f39190613c89565b9250508190555061244a565b8161240a8d83611418565b03612449576124338c8760008481526020019081526020016000206129ce90919063ffffffff16565b5061244781866129fe90919063ffffffff16565b505b5b600073ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff16036124af578187600401600083815260200190815260200160002060008282546124a39190613f9b565b925050819055506124fb565b60006124bb8c83611418565b036124fa576124e48b876000848152602001908152602001600020612a1890919063ffffffff16565b506124f88185612a4890919063ffffffff16565b505b5b505b81806001019250505061234a565b50505050505b61251f868686868686612a62565b505050505050565b61253082612aaa565b81600b01600082815260200190815260200160002060009054906101000a900460ff1615612593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161258a90614292565b60405180910390fd5b5050565b60006125a1611f33565b90508473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161461278d578060010160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16612698576040517f3d2f0b3700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80600201600084815260200190815260200160002060009054906101000a900460ff1680156127555750818160030160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085815260200190815260200160002054105b1561278c576040517f32af163800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5050505050565b6127a2868686868686612aff565b505050505050565b6127c98473ffffffffffffffffffffffffffffffffffffffff16612bed565b15612967578373ffffffffffffffffffffffffffffffffffffffff1663f23a6e6187878686866040518663ffffffff1660e01b815260040161280f959493929190614342565b6020604051808303816000875af192505050801561284b57506040513d601f19601f8201168201806040525081019061284891906143f4565b60015b6128e75761285761442e565b806308c379a0036128b3575061286b614481565b8061287657506128b5565b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128aa9190614555565b60405180910390fd5b505b6040517f4eebd08100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63f23a6e6160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614612965576040517f542073e700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505b505050505050565b600081831161297e5781612980565b825b905092915050565b60008183116129975782612999565b815b905092915050565b6000807ff0375085caeab71645bf74d020ee2aa37bc7b653d9e55911c1084d8c88b3c05c90508091505090565b60006129f6836000018373ffffffffffffffffffffffffffffffffffffffff1660001b612c00565b905092915050565b6000612a10836000018360001b612c00565b905092915050565b6000612a40836000018373ffffffffffffffffffffffffffffffffffffffff1660001b612ce4565b905092915050565b6000612a5a836000018360001b612ce4565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612aa257612aa1858484612d4b565b5b505050505050565b80600a0160009054906101000a900460ff1615612afc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612af3906145c3565b60405180910390fd5b50565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612b4157612b408584846000612de4565b5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614612b8357612b828484846001612de4565b5b60005b8351811015612be457612bd7612b9a612e7f565b858381518110612bad57612bac614217565b5b60200260200101518888878681518110612bca57612bc9614217565b5b6020026020010151612eb7565b8080600101915050612b86565b50505050505050565b600080823b905060008111915050919050565b60008083600101600084815260200190815260200160002054905060008114612cdd57600084600001600186600001805490500381548110612c4557612c44614217565b5b9060005260206000200154905080856000016001840381548110612c6c57612c6b614217565b5b906000526020600020018190555081856001016000838152602001908152602001600020819055505083600001805480612ca957612ca86145e3565b5b6001900381819060005260206000200160009055905583600101600084815260200190815260200160002060009055600191505b5092915050565b6000612cf08383612feb565b612d455782600001829080600181540180825580915050600190039060005260206000200160009091909190915055826000018054905083600101600084815260200190815260200160002081905550600190505b92915050565b8051825114612d86576040517f583b4bea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8251811015612dde57612dd184848381518110612da957612da8614217565b5b6020026020010151848481518110612dc457612dc3614217565b5b602002602001015161300e565b8080600101915050612d89565b50505050565b8151835114612e1f576040517f583b4bea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8351811015612e7857612e6b85858381518110612e4257612e41614217565b5b6020026020010151858481518110612e5d57612e5c614217565b5b602002602001015185613155565b8080600101915050612e22565b5050505050565b600080612e8a6116ef565b90508060020160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6000612ec16129a1565b905060008160000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600087815260200190815260200160002090508060000160009054906101000a900460ff16612f36575050612fe4565b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614612fa157612fa08186857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612f9b9190614612565b6132f3565b5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614612fe157612fe08185856132f3565b5b50505b5050505050565b600080836001016000848152602001908152602001600020541415905092915050565b6000613018613474565b90506000816000016000858152602001908152602001600020905043816001015411613045575050613150565b60008160030160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000600c826003015483600001546130a29190613f9b565b6130ac91906139ad565b83600201548360020154436130c19190613f9b565b6130cb91906139ad565b6130d591906139de565b9050600082600101546130fb8385600301546130f19190613c89565b8560000154612988565b6131059190613f9b565b90508086111561314a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613141906146fc565b60405180910390fd5b50505050505b505050565b600061315f613474565b9050600081600001600086815260200190815260200160002090504381600101541161318c5750506132ed565b60008160030160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050438260000154116132265760018460ff160361321e57848160000160008282546131fb9190613c89565b92505081905550848160030160008282546132169190613c89565b925050819055505b5050506132ed565b6000600c8260030154836000015461323e9190613f9b565b61324891906139ad565b836002015483600201544361325d9190613f9b565b61326791906139ad565b61327191906139de565b90506132908183600301546132869190613c89565b8360000154612988565b826003018190555060018560ff16036132c357858260000160008282546132b79190613c89565b925050819055506132df565b858260010160008282546132d79190613c89565b925050819055505b438260020181905550505050505b50505050565b60008360040160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600082856001015461334a91906141a4565b121561338b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016133829061478e565b60405180910390fd5b600082826000015461339d91906141a4565b12156133de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016133d590614820565b60405180910390fd5b60008085600101541461340d5784600101548386600301546134009190614612565b61340a9190614840565b90505b82856001015461341d91906141a4565b856001018190555080856003015461343591906141a4565b856003018190555082826000015461344d91906141a4565b826000018190555080826001015461346591906148aa565b82600101819055505050505050565b6000807fb666c964c288db81fc3205a9feeb13cfebbde2a4a4664c45ea26ef9d3d8de79290508091505090565b6000604051905090565b600080fd5b6000819050919050565b6134c3816134b0565b81146134ce57600080fd5b50565b6000813590506134e0816134ba565b92915050565b600063ffffffff82169050919050565b6134ff816134e6565b811461350a57600080fd5b50565b60008135905061351c816134f6565b92915050565b60008060408385031215613539576135386134ab565b5b6000613547858286016134d1565b92505060206135588582860161350d565b9150509250929050565b600060ff82169050919050565b61357881613562565b82525050565b6000602082019050613593600083018461356f565b92915050565b6000602082840312156135af576135ae6134ab565b5b60006135bd848285016134d1565b91505092915050565b6135cf816134b0565b82525050565b60006020820190506135ea60008301846135c6565b92915050565b600060208284031215613606576136056134ab565b5b60006136148482850161350d565b91505092915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b6136428161361d565b811461364d57600080fd5b50565b60008135905061365f81613639565b92915050565b61366e81613562565b811461367957600080fd5b50565b60008135905061368b81613665565b92915050565b600080604083850312156136a8576136a76134ab565b5b60006136b685828601613650565b92505060206136c78582860161367c565b9150509250929050565b600082825260208201905092915050565b7f4e4f545f414c4c4f574544000000000000000000000000000000000000000000600082015250565b6000613718600b836136d1565b9150613723826136e2565b602082019050919050565b600060208201905081810360008301526137478161370b565b9050919050565b7f4f6e6c7920616e20617070726f766564206163636f756e742063616e2062757960008201527f20746865204d6167696320746f6b656e00000000000000000000000000000000602082015250565b60006137aa6030836136d1565b91506137b58261374e565b604082019050919050565b600060208201905081810360008301526137d98161379d565b9050919050565b7f4f6e6c792031204d6167696320746f6b656e2063616e20626520626f7567687460008201527f206e6f7721000000000000000000000000000000000000000000000000000000602082015250565b600061383c6025836136d1565b9150613847826137e0565b604082019050919050565b6000602082019050818103600083015261386b8161382f565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061389d82613872565b9050919050565b6138ad81613892565b82525050565b60006060820190506138c860008301866138a4565b6138d560208301856138a4565b6138e260408301846135c6565b949350505050565b60008115159050919050565b6138ff816138ea565b811461390a57600080fd5b50565b60008151905061391c816138f6565b92915050565b600060208284031215613938576139376134ab565b5b60006139468482850161390d565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006139b8826134b0565b91506139c3836134b0565b9250826139d3576139d261394f565b5b828204905092915050565b60006139e9826134b0565b91506139f4836134b0565b9250828202613a02816134b0565b91508282048414831517613a1957613a1861397e565b5b5092915050565b7f76616c7565547970652063616e2062652030206f722031206f6e6c7921000000600082015250565b6000613a56601d836136d1565b9150613a6182613a20565b602082019050919050565b60006020820190508181036000830152613a8581613a49565b9050919050565b600081519050613a9b81613665565b92915050565b600060208284031215613ab757613ab66134ab565b5b6000613ac584828501613a8c565b91505092915050565b60008160011c9050919050565b6000808291508390505b6001851115613b2557808604811115613b0157613b0061397e565b5b6001851615613b105780820291505b8081029050613b1e85613ace565b9450613ae5565b94509492505050565b600082613b3e5760019050613bfa565b81613b4c5760009050613bfa565b8160018114613b625760028114613b6c57613b9b565b6001915050613bfa565b60ff841115613b7e57613b7d61397e565b5b8360020a915084821115613b9557613b9461397e565b5b50613bfa565b5060208310610133831016604e8410600b8410161715613bd05782820a905083811115613bcb57613bca61397e565b5b613bfa565b613bdd8484846001613adb565b92509050818404811115613bf457613bf361397e565b5b81810290505b9392505050565b6000613c0c826134b0565b9150613c1783613562565b9250613c447fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484613b2e565b905092915050565b6000613c578261361d565b9150613c628361361d565b9250828202613c708161361d565b9150808214613c8257613c8161397e565b5b5092915050565b6000613c94826134b0565b9150613c9f836134b0565b9250828201905080821115613cb757613cb661397e565b5b92915050565b7f54686520696e707574207175616e7469747920697320746f6f20736d616c6c2060008201527f666f7220706179696e6720746f6b656e00000000000000000000000000000000602082015250565b6000613d196030836136d1565b9150613d2482613cbd565b604082019050919050565b60006020820190508181036000830152613d4881613d0c565b9050919050565b7f54686520696e70757420616d6f756e7420697320746f6f20736d616c6c20666f60008201527f7220627579696e67206120746f6b656e00000000000000000000000000000000602082015250565b6000613dab6030836136d1565b9150613db682613d4f565b604082019050919050565b60006020820190508181036000830152613dda81613d9e565b9050919050565b7f4e6f7420656e6f75676820746f6b656e20746f2073656c6c0000000000000000600082015250565b6000613e176018836136d1565b9150613e2282613de1565b602082019050919050565b60006020820190508181036000830152613e4681613e0a565b9050919050565b7f54686520696e707574207175616e7469747920697320746f6f20736d616c6c2060008201527f666f7220706179696e6720746f6b656e21000000000000000000000000000000602082015250565b6000613ea96031836136d1565b9150613eb482613e4d565b604082019050919050565b60006020820190508181036000830152613ed881613e9c565b9050919050565b7f54686520696e70757420616d6f756e7420697320746f6f20736d616c6c20666f60008201527f7220627579696e67206120746f6b656e21000000000000000000000000000000602082015250565b6000613f3b6031836136d1565b9150613f4682613edf565b604082019050919050565b60006020820190508181036000830152613f6a81613f2e565b9050919050565b613f7a816138ea565b82525050565b6000602082019050613f956000830184613f71565b92915050565b6000613fa6826134b0565b9150613fb1836134b0565b9250828203905081811115613fc957613fc861397e565b5b92915050565b6000613fda826134e6565b9150613fe5836134e6565b9250828201905063ffffffff8111156140015761400061397e565b5b92915050565b600060408201905061401c60008301856135c6565b61402960208301846135c6565b9392505050565b7f43616c63756c6174696f6e206973206e6f7420656e61626c656420666f72207460008201527f686520746f6b656e210000000000000000000000000000000000000000000000602082015250565b600061408c6029836136d1565b915061409782614030565b604082019050919050565b600060208201905081810360008301526140bb8161407f565b9050919050565b7f4e6f7420656e6f75676874207175616e74697479206c65667421000000000000600082015250565b60006140f8601a836136d1565b9150614103826140c2565b602082019050919050565b60006020820190508181036000830152614127816140eb565b9050919050565b7f506f6f6c2063616e206f6e6c7920696e63726561736521000000000000000000600082015250565b60006141646017836136d1565b915061416f8261412e565b602082019050919050565b6000602082019050818103600083015261419381614157565b9050919050565b6000819050919050565b60006141af8261419a565b91506141ba8361419a565b9250828201905082811215600083121683821260008412151617156141e2576141e161397e565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f546f6b656e206973207061757365642100000000000000000000000000000000600082015250565b600061427c6010836136d1565b915061428782614246565b602082019050919050565b600060208201905081810360008301526142ab8161426f565b9050919050565b600081519050919050565b600082825260208201905092915050565b60005b838110156142ec5780820151818401526020810190506142d1565b60008484015250505050565b6000601f19601f8301169050919050565b6000614314826142b2565b61431e81856142bd565b935061432e8185602086016142ce565b614337816142f8565b840191505092915050565b600060a08201905061435760008301886138a4565b61436460208301876138a4565b61437160408301866135c6565b61437e60608301856135c6565b81810360808301526143908184614309565b90509695505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6143d18161439c565b81146143dc57600080fd5b50565b6000815190506143ee816143c8565b92915050565b60006020828403121561440a576144096134ab565b5b6000614418848285016143df565b91505092915050565b60008160e01c9050919050565b600060033d111561444d5760046000803e61444a600051614421565b90505b90565b614459826142f8565b810181811067ffffffffffffffff82111715614478576144776141e8565b5b80604052505050565b600060443d1061450e576144936134a1565b60043d036004823e80513d602482011167ffffffffffffffff821117156144bb57505061450e565b808201805167ffffffffffffffff8111156144d9575050505061450e565b80602083010160043d0385018111156144f657505050505061450e565b61450582602001850186614450565b82955050505050505b90565b600081519050919050565b600061452782614511565b61453181856136d1565b93506145418185602086016142ce565b61454a816142f8565b840191505092915050565b6000602082019050818103600083015261456f818461451c565b905092915050565b7f416c6c20746f6b656e2069732070617573656421000000000000000000000000600082015250565b60006145ad6014836136d1565b91506145b882614577565b602082019050919050565b600060208201905081810360008301526145dc816145a0565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b600061461d8261419a565b91506146288361419a565b92508282026146368161419a565b91507f8000000000000000000000000000000000000000000000000000000000000000841460008412161561466e5761466d61397e565b5b82820584148315176146835761468261397e565b5b5092915050565b7f54686520616d6f756e7420697320677261746572207468656e2074686520616360008201527f63756d6c6174656420282773656c6c61626c65272920616d6f756e7421000000602082015250565b60006146e6603d836136d1565b91506146f18261468a565b604082019050919050565b60006020820190508181036000830152614715816146d9565b9050919050565b7f506f6f6c20746f6b656e207175616e6974792063616e2774206265206c65737360008201527f207468656e207a65726f21000000000000000000000000000000000000000000602082015250565b6000614778602b836136d1565b91506147838261471c565b604082019050919050565b600060208201905081810360008301526147a78161476b565b9050919050565b7f5573657220746f6b656e207175616e6974792063616e2774206265206c65737360008201527f207468656e207a65726f21000000000000000000000000000000000000000000602082015250565b600061480a602b836136d1565b9150614815826147ae565b604082019050919050565b60006020820190508181036000830152614839816147fd565b9050919050565b600061484b8261419a565b91506148568361419a565b9250826148665761486561394f565b5b600160000383147f80000000000000000000000000000000000000000000000000000000000000008314161561489f5761489e61397e565b5b828205905092915050565b60006148b58261419a565b91506148c08361419a565b92508282039050818112600084121682821360008512151617156148e7576148e661397e565b5b9291505056fea2646970667358221220fc9c4272cd38f6900f3669ca6676f46a8f734dbacab5e199f17c61cffee4141464736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}